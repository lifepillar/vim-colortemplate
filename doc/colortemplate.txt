*colortemplate.txt*	For Vim version 8.2	Last change: 2021 Oct 20

	  .,-:::::     ...      :::         ...    :::::::.. :::::::::::: ~
	,;;;'````'  .;;;;;;;.   ;;;      .;;;;;;;. ;;;;``;;;;;;;;;;;;'''' ~
	[[[        ,[[     \[[, [[[     ,[[     \[[,[[[,/[[['     [[ ~
	$$$        $$$,     $$$ $$'     $$$,     $$$$$$$$$c       $$ ~
	`88bo,__,o,"888,_ _,88Po88oo,.__"888,_ _,88P888b "88bo,   88, ~
	  "YUMMMMMP" "YMMMMMP" """"YUMMM  "YMMMMMP" MMMM   "W"    MMM ~
	.,::::::  .        :::::::::::. :::      :::. ::::::::::::.,:::::: ~
	;;;;''''  ;;,.    ;;;`;;;```.;;;;;;      ;;`;;;;;;;;;;'''';;;;'''' ~
	 [[cccc   [[[[, ,[[[[,`]]nnn]]' [[[     ,[[ '[[,   [[      [[cccc ~
	 $$""""   $$$$$$$$"$$$ $$$""    $$'    c$$$cc$$$c  $$      $$"""" ~
	 888oo,__ 888 Y88" 888o888o    o88oo,.__888   888, 88,     888oo,__ ~
	 """"YUMMMMMM  M'  "MMMYMMMb   """"YUMMMYMM   ""`  MMM     """"YUMMM ~

	The Toolkit for Color Scheme Designers!
	Author:  Lifepillar <https://github.com/lifepillar>
	License: Same terms as Vim itself (see |license|)
==============================================================================
CONTENTS						*ft-colortemplate*

    1. Introduction ......... |colortemplate-intro|
    2. Getting started ...... |colortemplate-quickstart|
    3. Templates' structure . |colortemplate-structure|
    4. Metadata block ....... |colortemplate-meta|
    5. Backgrounds .......... |colortemplate-background|
    6. Variants ............. |colortemplate-variants|
    7. Color definitions .... |colortemplate-colors|
    8. Terminal colors ...... |colortemplate-termcolors|
    9. Highlight groups ..... |colortemplate-hi-groups|
   10. Verbatim blocks ...... |colortemplate-verbatim|
   11. Documentation blocks . |colortemplate-doc-blocks|
   12. Auxiliary files ...... |colortemplate-auxfiles|
   13. Include directive .... |colortemplate-include|
   14. Colors statistics..... |colortemplate-stats|
   15. Mappings ............. |colortemplate-mappings|
   16. Options .............. |colortemplate-options|
   17. Commands ............. |colortemplate-commands|
   18. Window toolbar ....... |colortemplate-toolbar|
   19. The style picker ..... |colortemplate-popup|
   20. Functions ............ |colortemplate-functions|
   21. Best practices ....... |colortemplate-best-practices|
   22. Providing feedback ... |colortemplate-feedback|

==============================================================================
Color templates					*colortemplate-intro*

A colortemplate file is designed to help users create their own color schemes
without much effort. It can also be used to create color schemes suitable for
distribution with Vim. Color schemes created using a colortemplate have the
following features:

- they support gVim, true-color terminal, 256-color terminals and possibly
  less capable terminals (including terminals not supporting colors);
- they have a consistent structure, they are guaranteed to follow best
  practices and they load quickly;
- they can be easily customised by the user;
- they are licensed under the Vim license by default.

==============================================================================
Getting Started					*colortemplate-quickstart*

To get started quickly, |:edit| `templates/dark.colortemplate`, which is
located in colortemplate's plugin folder, and type:
>
	:Colortemplate ~/.vim
<
If you use Vim 8.0.1123 or later, you may also execute commands by clicking on
a window toolbar. Click on "OutDir" and set the output directory to `~/.vim`,
then click on "Build!" to create the color scheme.

Note: |Colortemplate| and other plugin's commands are filetype-specific. That
means that they are available only if the filetype is set to `colortemplate`.
You may need to explicitly type `:set ft=colortemplate` to make them available
in new buffers.

Note: |:Colortemplate| gives an error if the color scheme already exists at
the given location (`~/.vim/colors` in the example above): use
`:Colortemplate!` to overwrite existing files. Vice versa, the "Build!" menu
silently overwrites any existing file.

If there are errors in your template, they are shown in the quickfix window.
If the template builds successfully, Colortemplate tells you so with a message
in the command line.

To enable the generated color scheme, you may use |:colorscheme| or (better)
click on "Show" in the toolbar (the dark template uses only two colors out of
its palette, so it does not stand out as a catchy color scheme). If you enable
the color scheme by clicking on "Show" in the toolbar, you may switch back to
the original color scheme by clicking on "Hide".

You may validate your color scheme against Vim's built-in script
`$VIMRUNTIME/colors/tools/check_colors.vim` with |:ColortemplateCheck| or by
clicking on "Check" in the toolbar. If there are no issues, you will see this
message:
>
	---------------
	    colors_name: OK
	---------------
<
You may compute some statistics about the colors used by your theme with
|:ColortemplateStats| or by clicking on "Stats" in the toolbar. For more
details, see |colortemplate-stats|. Click on "Source" to view and edit your
color scheme.

You may use `dark.colortemplate`, `light.colortemplate` or
`dark_and_light.colortemplate` in the `templates` folder as starting points
for creating your own color scheme. The process consists of five (not
necessarily sequential) steps:

1. edit your color scheme's information;
2. define a color palette;
3. define the necessary highlight groups;
4. document your color scheme's options, if any;
5. build your color scheme.

If you want to start from scratch instead of using one of the predefined
templates, set the modeline in your template to
>
	; vim: ft=colortemplate

or save your template with a `.colortemplate` suffix.

==============================================================================
Templates' structure				*colortemplate-structure*

(You may skim through this section on a first read and come back to it after
you have read the rest of the documentation and have understood the examples
in the `templates` folder.)

A template consists of:

1. metadata;
2. `Color` and `Term colors` definitions;
3. `Background` and `Variant` directives;
4. `Include` directives;
5. verbatim blocks (`verbatim`/`auxfile`/`documentation`, `#if`, `#let`, ...);
6. highlight group definitions;
7. line comments (starting with `;`), which are ignored by Colortemplate.

Each template has one global section and one or more local sections. The
global section starts at the beginning of the file and lasts until the first
`Background` or `Variant` directive is encountered. The global section may
contain anything except highlight group definitions (linked group definitions
are allowed, though). When translated, linked group definitions and verbatim
blocks in the global section appear at the start of the generated color
scheme. This is useful if you need to set up your color scheme in some way or
override some variables. For example, Colortemplate defines two script
variables inside color schemes, called `s:t_Co` and `s:italics`. If you want
to override their default value, you may do so in the global section.

A local section starts when a `Background` or `Variant` directive is
encountered and lasts until the next `Background` or `Variant` directive. Each
local section contains the highlight group definitions and `verbatim` blocks
that apply to the current backgrounds and variants. A local section may also
contain `Color` definitions that apply to the current backgrounds. For
instance, if a template contains these two lines:
>
	Variant: gui 256
	Background: dark
<
anything following such directives and until the next `Variant` or
`Background` directive will be applied to the dark version of GUI and
256-color variants of your color scheme. `Variant` and `Background` may appear
several times in the same template. Combining them gives you great
flexibility, e.g.:
>
	Variant: gui
	Background: any
	  ; Defs. for both backgrounds, apply only to GUI
	Background: dark
	  ; Defs. for dark background, apply only to GUI
	Variant: gui 256 16
	  ; Defs. for dark background, apply to GUI/256/16 colors
	Background: any
	  ; Defs. for both backgrounds, apply to GUI/256/16 colors
	Background: light
	Variant: 16
	  ; Defs. for light background, apply only to 16 colors
<
A template like the above will generate code with the following structure:
>
	let s:t_Co = ...
	if [has termguicolors set or is GUI vim]
	  " Defs. for both backgrounds, apply only to GUI
	  " Defs. for both backgrounds, apply to GUI/256/16 colors
	  if &background ==# 'dark'
	    " Defs. for dark background, apply only to GUI
	    " Defs. for dark background, apply to GUI/256/16 colors
	    finish
	  endif
	  finish
	endif
	if s:t_Co >= 256
	  " Defs. for both backgrounds, apply to GUI/256/16 colors
	  if &background ==# 'dark'
	    " Defs. for dark background, apply to GUI/256/16 colors
	    finish
	  endif
	  finish
	endif
	if s:t_Co >= 16
	  " Defs. for both backgrounds, apply to GUI/256/16 colors
	  if &background ==# 'dark'
	    " Defs. for dark background, apply to GUI/256/16 colors
	    finish
	  endif
	  " Defs. for light background, apply only to 16 colors
	  finish
	endif
<
Note how the code is reordered. In particular, code in the scope of `any`
background is put before the background is checked, for each variant to which
it applies (the "local preamble" of each variant).

==============================================================================
Metadata block					*colortemplate-meta*

Information about a color scheme consists of the following mandatory and
optional fields, usually appearing at the top of your template:
>
	; Mandatory information
	Full name:       A unique and attractive name
	Short name:      all_lowercase_with_no_spaces
	Author:          Myself <myself@somewhere.org>

	; Optional information
	Maintainer:      [Uses Author's value by default]
	Description:     [Empty]
        URL:             [Empty]
	Website:         [Empty]
	License:         [Vim license]
        Version:         [Empty]
	Option Prefix:   [Uses Short name's value by default]
	Neovim:          [No]
	Colortemplate Options: []
<
Each metadata field must fit in one line. The default values for optional
fields in shown in square brackets. All the fields should be self-descriptive
except for the last two.

When `Neovim` is set to `yes` or `1` then additional code is generated to
support Neovim.

`Colortemplate Options` allows you to set some options for the current
template, overriding the corresponding global options (see
|colortemplate-options|). The value of this metadata field is
a space-separated sequence of items of the form `option=value`, where `option`
is the name of a global option with the `g:colortemplate_` prefix removed. For
example:
>
	Colortemplate Options: creator=0 timestamp=1

The options that can be set in this way are `backward_compatible`, `creator`,
`ignore_missing`, `quiet`, `source_comment`, `timestamp`, `use_tabs` and
`warnings`.

==============================================================================
Color scheme background				*colortemplate-background*

You must specify whether color definitions and highlight group definitions
apply to a dark background, to a light background or to any background. You do
so with a `Background` directive, which may have one of three values:
>
	Background: dark
	Background: light
	Background: any
<
All definitions appearing after a `Background` directive until the end of the
file or until another `Background` directive apply to the specified
background(s).

If only one background is mentioned in the template, the generated color
scheme will have a command to set it accordingly, e.g.:
>
	set background=dark
<
If the template uses both backgrounds then the generated color scheme will
adapt to the current background, e.g., the generated code will be equivalent
to:
>
	" Local preamble here
	if &background ==# 'dark'
	  " Dark variant of the color scheme
	else
	  " Light variant of the color scheme
	endif
<
Template code in the scope of `any` background will be put in the "local
preamble", i.e., before checking the value of |background|.

==============================================================================
Variants						*colortemplate-variants*

A `Variant` directive declares to which environments the subsequent
definitions apply. All definitions appearing after a `Variant` directive until
the end of the file or until another `Variant` directive apply to the
specified variant(s).

The allowed values are `gui` (for gVim or when |termguicolors| is set) or
a number between `0` and `256` specifying the minimum |t_Co| required for the
following definitions. Multiple values in the same directive are allowed,
separated by spaces.

For example, consider the following snippet:
>
	Color: white #ffffff 231 White
	Color: black #000000 16 Black
	Color: ivory #ebebeb 255 LightGray
	Color: dust  #343436 236 Brown

	Variant: gui 8
	Normal ivory dust
	Variant: 256
	Normal white black
<
This will be translated into something similar to this:
>
	if (has('termguicolors') && &termguicolors) || has('gui_running')
	  hi Normal guifg=#ebebeb guibg=#343436 gui=NONE cterm=NONE
	  finish
	endif

	if &t_Co >= 256
	  hi Normal ctermfg=231 ctermbg=16 cterm=NONE
	  finish
	endif

	if &t_Co >= 8
	  hi Normal ctermfg=LightGray ctermbg=Brown cterm=NONE
	  finish
	endif

Text before the first `Variant` directive, but after a `Background` directive,
applies by default to `gui` and `256` color variants. This rule exists mostly
for backward compatibility: it is recommended to always use `Variant`
explicitly before specifying the background.

==============================================================================
Color definitions					*colortemplate-colors*

Color definitions consist of lines with the following syntax:
>
	Color: <Name> <GUI spec> <Base-256 spec> <Base-16 spec>

For example:
>
	Color: red  #e64547  167  DarkRed
<
The name is an arbitrary string (only letters, numbers and underscore
allowed). Color definitions that appear before all `Background` directives or
are in the scope of `Background: any`, are assumed to apply to any background.
Color definitions in the scope of `Background: dark` or `Background: light`
apply only to the specified background. So, you may have two different colors
with the same name for light and dark background. You may not have different
colors with the same name for different variants, though: as far as color
definitions are concerned, `Variant` directives are simply ignored.

The `<GUI spec>` may be given as a hexadecimal value, as in the example above,
or as an RGB value. Standard color names from `$VIMRUNTIME/rgb.txt` may be
used as well, although their use is discouraged. For instance:
>
	Color: white    rgb(255,255,255)    206    White
	Color: gold     dark goldenrod      136    Brown
<
The `<Base-256 spec>` and `<Base-16 spec>` fields are used for terminals that
do not support more than 256 colors, or when |termguicolors| is not set. For
variants with at least 16 colors, the base-256 values are used; base-16 values
are used for variants with no more than 16 colors. The color numbers must not
exceed the limits imposed by the current variants. For example, if you
declare:
>
	Variant: 256 88
<
then you may use only base-256 colors between `0` and `87`. On the other hand,
if you declare:
>
	Variant: 256 8 4
<
you will be able to use all base-256 colors, but only the first four base-16
colors.

In general, only the GUI value of a color specification is necessary. Base-256
values may be replaced by a `~` symbol, which means that the color should be
inferred automatically from the GUI value. Base-16 values may be omitted
entirely: it is safe to do so when no variant with 16 colors or less is used.
So, a minimal color definition looks as follows:
>
	Color: black #000000 ~
<
==============================================================================
Terminal colors					*colortemplate-termcolors*

The 16 ASCII colors for Vim terminal windows should be specified using
a `Term Colors` directive:
>
	Term Colors: mydarkblack  mydarkred      mydarkgreen  mydarkyellow
	Term Colors: mydarkblue   mydarkmagenta  mydarkcyan   mydarkwhite
	Term Colors: mylightblack mylightred     mylightgreen mylightyellow
	Term Colors: mylightblue  mylightmagenta mylightcyan  mylightwhite
<
The directive may be repeated on several lines, but it must define 16 colors
in total, in the order in which they should be assigned to the terminal. The
used color names must have been previously defined with the `Color` directive.

==============================================================================
Highlight group definitions			*colortemplate-hi-groups*

Highlight group definitions consist of lines having the following syntax:
>
	<Group name> <foreground color> <background color> <style attributes>
<
For example:
>
	SpellRare  white  black  bold,reverse guisp=cyan
<
Colors must be specified using the color names defined by the `Color`
directives.

The <style attributes> part of a highlight group definition is used to specify
comma-separated lists of attributes (see |attr-list|) and the special color to
use in the GUI (|highlight-guisp|). The following are examples of valid
highlight group specifications:
>
	Normal    white   black
	DiffAdd   orange  blue   reverse
	SpellBad  white   black  guisp=red underline
<
The foreground and background colors must always be present: if you want to
skip a color, you may use the special keyword `omit` (see below). You may use
the special values `fg`, `bg`, and `none` for the default foreground color,
the default background color and for disabling the corresponding highlighting,
respectively.

Attributes specified as above are used for both |cterm| and |gui|
highlighting. If you want to use different values for the terminal and the
GUI, you must prepend `term=` or `gui=`, respectively, as is done in Vim color
schemes. For example:
>
	IncSearch  white  black  term=bold,reverse  gui=bold,standout
<
`term=` may be abbreviated `t=`, and `gui=` may be abbreviated `g=`. Instead
of `guisp=`, you may also use `s=`.

The special keyword `omit` may be used when you want to inherit a color or an
attribute from Vim's default color scheme. For instance, this directive:
>
	CursorLine  white  omit   t=underline g=omit
<
may generate something like this for the GUI:
>
	hi CursorLine guifg=#ffffff

and for the terminal:
>
	hi CursorLine ctermfg=255 cterm=underline
<
In both definitions, the background color is missing; additionally, for the
GUI the special color and attributes are not specified either. Note that
`omit` is the default for the special color, if the `guisp` attribute is not
specified.

Colortemplate also supports |highlight-start| and |highlight-stop|: the syntax
is the same as in Vim color schemes.

Note: variants also determine which attributes are used. For example, if this
definition:
>
	IncSearch white black term=underline
<
is in the scope of `Variant: gui`, the `term` attribute will be ignored.

Linked groups are defined using the following syntax:
>
	<SourceGroup> -> <TargetGroup>

For example:
>
	QuickFixLine  ->  Search
<
==============================================================================
Verbatim blocks					*colortemplate-verbatim*

Colortemplate offers the possibility to add arbitrary code to a color scheme.
Code between `verbatim` and `endverbatim` is copied almost verbatim into the
output. The exception is that you may still use your color names by prepending
an @ sign: such names will be interpolated and replaced by suitable color
values. For example:
>
	verbatim
	if get(g:, 'fancyflag', 0)
	  hi! Normal ctermfg=@red guifg=@red gui=NONE,undercurl guisp=@yellow
	endif
	endverbatim
<
might be translated into something like:
>
	if get(g:, 'fancyflag', 0)
	  hi! Normal ctermfg=88 guifg=#ff6400 gui=NONE,undercurl guisp=#ffff00
	endif
<
If you need to interpolate a color that does not occur in a highlight group
definition, you must specify whether you want to interpolate a GUI value or
a terminal value by using `@gui<color>`, `@term16<color>`, or
`@term256<color>`, where `<color>` is a color name. For example:
>
	let g:terminal_color_@term16black = '@guiblack'
<
might generate the following code:
>
	let g:terminal_color_0 = '#000000'
<
Other values may be interpolated: metadata keywords, converted to lower case
and without spaces (e.g., `@shortname` may be used to insert the value of
`Short name`); `@date` (to insert the current date), `@background` (to insert
the value of the current background: dark/light) and `@vimversion` (to insert
the current Vim version).

Verbatim blocks are most often used for conditionals or to set and get
variables or to invoke functions. Therefore, Colortemplate provides convenient
shortcuts for such cases. When `#if`, `#else`, `#elseif`, `#endif`, `#let`,
`#unlet[!]` or `#call[!]` appear at the start of a line, they act as one-line
verbatim blocks. Such directives are replaced by the corresponding Vim
commands and what follows until the end of the line is copied verbatim (but
interpolated) to the output. So, for instance, this template:
>
	#if get(g:, 'some_option', 0)
	  #let s:color = '@guiMyColor'
	#endif

	#call foo()
	#call! bar()
<
is translated into
>
	if get(g:, 'some_option', 0)
	  let s:color  = '#abcdef'
	endif

	call foo()
	silent! call bar()
<
assuming that `MyColor` is a color with GUI value `#abcdef`.

Note: `#call!` generates a function invocation that silently ignore errors.

Finally, a special type of verbatim block can be used to override the reset
block generated by Colortemplate. The default reset block consists of the
following lines, added at the beginning of each color scheme:
>
	hi clear
	let g:colors_name = '@shortname'
<
In some very rare cases you might want to customize this code. For that, put
a `reset`/`endreset` block at the beginning of your template. That will
override the default code. For instance:
>
	reset
	    hi clear
	    let g:colors_name = '@shortname'
	    let s:myvar = 'I **need** this to be defined at this point!'
	endreset
<
Customizing the reset block is seldom needed. Do it only if you really know
what you are doing.

==============================================================================
Documentation blocks				*colortemplate-doc-blocks*

Any settings that your color scheme provides should be documented in
a documentation block. For instance, if you add a `g:mytheme_transp_bg` flag
to enable a transparent background, you may document it as follows:
>
  documentation
  ===========================================================================
  @fullname options                                *@shortname-options*

                                                   *g:@shortname_transp_bg*

  Set to 1 if you want a transparent background. Takes effect only in the
  terminal.
  >
    let g:@shortname_transp_bg = 0
  <
  enddocumentation

A documentation block starts with a `documentation` keyword and ends with
`enddocumentation`. Interpolation works as in verbatim blocks. Multiple
documentation blocks are chained together in the order in which they are
encountered.

A documentation block will generate a help file in a `doc` directory inside
the output directory. You may suppress the generation of the help file with
|g:colortemplate_no_doc|.

==============================================================================
Auxiliary files					*colortemplate-auxfiles*

If you want to generate additional files besides the color scheme itself, you
may put the content of each file into a separate `auxfile` block. For example:
>
	auxfile autoload/airline/themes/@shortname.vim
	" Anything can go here
	endauxfile
<
This will write the content of the auxfile block into the specified file
(creating the intermediate directories if necessary). The path is mandatory
and must be a relative path (relative to the output directory). No comment may
appear in an `auxline` line. The content of an `auxfile` block is interpolated
as in verbatim blocks. As you can see in the example above, the path is also
interpolated.

Multiple `auxfile` blocks referring to the same path are chained together in
the order in which they are encountered. For instance:
>
	auxfile autoload/foobar.vim
	" First part of auxiliary file
	endauxfile

        ; Some other code

	auxfile autoload/foobar.vim
	" Second part of auxiliary file
	endauxfile
<
will result in `autoload/foobar.vim` with the following content:
>
	" First part of auxiliary file
        " Second part of auxiliary file
<
You may suppress the generation of all auxiliary files
(including the help file) with |g:colortemplate_no_aux_files|.

==============================================================================
Include directive					*colortemplate-include*

You may split your template into several files, and include snippets from one
file into another. You do so with an `Include` directive. For example, you
might put the documentation of your color scheme into a separate template, say
`_help` or `_help.colortemplate`, and include it into the main template as
follows:
>
	Include: _help
<
The result is the same as if the content of `_help` or `_help.colortemplate`
had been written at the inclusion point. If the suffix of the included file is
`.colortemplate` then it may be omitted, as in the example above.

Conventionally, templates that are not meant to be used directly, but only
included into other templates, have names starting with an underscore.

You may include the same file more than once. This is useful, for example, if
you have highlight group definitions that are common to a dark and light
background. Then, you may put them into a `_common` file, and include it
twice:
>
	Background: dark
	Include: _common
	; Other definitions specific to dark background
	Background: light
	Include: _common
	; Other definitions specific to light background
<
NOTE: avoid cyclic inclusions: they will cause Colortemplate to run into an
infinite loop!

==============================================================================
Colors statistics					*colortemplate-stats*

Colortemplate can compute some useful statistics to help you assess the
quality of your color scheme. Such information is displayed in a scratch
buffer in a split window by |:ColortemplateStats| or by clicking on "Stats" in
the window toolbar. The following statistics are provided.

Color similarity table ~
A color similarity table contains a detailed summary of the generated color
values, presented in the following form:
>
  red: GUI=#9e0006/rgb(158,0,6) Term=88 #870000/rgb(135,0,0) [delta=4.473285]
<
Here, the delta value is the distance between the GUI value (`#9e0006`) and
the corresponding terminal color (`88`, which corresponds to `#870000`
according to xterm tables). The used distance is a sophisticated variant of
the CIELAB ΔE* metric, which takes into account the perceptual characteristics
of the human eye. Roughly speaking, colors at distance less than 2.3
correspond to "just noticeable differences". The greater the distance, the
greater the discrepancy between the GUI color and its base-256 counterpart.

Keep in mind that the "most similar" terminal color may not necessarily be the
"best looking" color, because the overall look&feel of a color scheme
ultimately depends on the interactions among all the colors.

Critical pairs ~
Pairs of colors that are used as a foreground/background combo by at least one
highlight group and have contrast ratio less than 3.0 (as per ISO-9241-3) are
reported in this section, for exact colors and for xterm approximations. For
each pair of colors, its contrast ratio (CR), color brightness (CB) and color
difference (CD) are shown (see below), and the highlight groups using such
pair are listed in the following line. Generally speaking, pairs of fg/bg
colors with low contrast ratio may be acceptable if they are used for
decorative elements (e.g., for |hl-VertSplit|), but should be avoided for
text, and especially for |hl-Normal|.

Contrast ratio matrix ~
The contrast ratio statistics compares the relative luminance of two colors.
This is useful, in particular, to determine whether there is enough contrast
between a foreground color and the background. Values that are too low may be
problematic for people with color deficits and are highlighted. Although
Colortemplate calculates the contrast ratio for each pair of colors, you
should mostly pay attention to the pairs that are used as
a foreground/background combination in your color scheme.

ISO-9241-3 recommends at least a 3:1 contrast ratio between the foreground and
the background color. W3C's WCAG guidelines suggest 4.5:1 as a minimum.

Contrast ratio ranges between 1.0 (no contrast difference) and 21.0 (maximum
contrast).

Brightness and color difference matrices ~
Two colors provide good color visibility if their brightness difference and
their color difference exceed a certain threshold. Colortemplate computes
color and brightness difference for each pair of colors in your color scheme.

Color difference ranges between 0.0 (no difference) and 765.0 (maximum
difference). At least for the Normal highlight group, the difference should be
no less than 500.

Brightness difference ranges between 0.0 (no difference) and 255.0 (maximum
difference). At least for the Normal highlight group, the difference should be
no less than 125.

==============================================================================
Colortemplate mappings				*colortemplate-mappings*

If you do not want Colortemplate to define any mapping, set
|g:colortemplate_no_mappings|. Colortemplate also honours |g:no_plugin_maps|.

Buffer-local mappings ~
							*colortemplate-ga*
ga			If the cursor is on a `Color` line, display some
			information about the given color, including [count]
			best xterm approximations for the color.

							*colortemplate-gl*
gl			Toggle the display of highlight group information
			under the mouse pointer and/or under the cursor.
			To choose what display to use, set
			|g:colortemplate_higroup_command_line| or
			|g:colortemplate_higroup_balloon|.

							*colortemplate-gs*
gs			Open the style picker.

							*colortemplate-gx*
gx			If the cursor is on a `Color` line, replace `~` with
			the [count]th best xterm approximation of the color.

							*colortemplate-gy*
gy			If the cursor is on a `Color` line, show the xterm
			approximations of the color at distance at most
			[count] from the GUI value in the command line.

							*colortemplate-ctrl-l*
CTRL-L			Show/redraw the window toolbar and redraw the screen.

Other suggested mappings ~
Being a filetype plugin, Colortemplate does not define any global mapping.
Some functionality provided by Colortemplate, however, can be useful in other
buffers as well. Here are some mappings you may want to add to your |vimrc|:

- Make the style picker available everywhere:
>
	nnoremap <silent> gs :<c-u>call colortemplate#style#open()<cr>
<
- Toggle the display of highlight group information globally:
>
	nnoremap <silent> gl :<c-u>call colortemplate#syn#toggle()<cr>
<
  For the balloon to show up, you also need to define |balloonexpr|:
>
	set balloonexpr=colortemplate#syn#balloonexpr()
<
- Generate a template from the currently active highlight groups:
>
	nnoremap <silent> gc :<c-u>call colortemplate#import#run()<cr>
<
Adjust to your taste.

==============================================================================
Colortemplate options				*colortemplate-options*

					*g:colortemplate_backward_compatible*
When set to 1, Colortemplate generates code that works better with older
versions of Vim under some very specific circumstances. The additional code is
generated only if necessary. Unless you plan your color scheme to be used with
Vim 8.0.0616 or earlier, you may safely leave this to 0.
>
	let g:colortemplate_backward_compatible = 0
<
					*g:colortemplate_creator*
Set to 0 if you do not want the `Generated by Colortemplate` comment in the
output color scheme.
>
	let g:colortemplate_creator = 1
<
					*g:colortemplate_fancy_import*
When importing a color scheme (see |colortemplate#import#run()|),
Colortemplate by default generates random fancy names for colors. Set this to
0 if you prefer dull names such as Color0001, Color0002, etc., instead.
>
	let g:colortemplate_fancy_import = 1
<
					*g:colortemplate_higroup_balloon*
When set to 1, Colortemplate displays the details of the highlight group under
the mouse pointer in a popup balloon, when requested to do so (see |gl|).
>
	let g:colortemplate_higroup_balloon = 1
<
					*g:colortemplate_higroup_command_line*
When set to 1, Colortemplate displays the details of the highlight group under
the cursor in the command line, when requested to do so (see |gl|).
>
	let g:colortemplate_higroup_command_line = 1
<
					*g:colortemplate_ignore_missing*
Set to 1 if you want Colortemplate to automatically add `@suppress` lines for
the highlight groups that are not defined by your template. Such lines are
used by Vim's `check_colors.vim` script (see |:ColortemplateCheck|) to ignore
undefined highlight groups.
>
	let g:colortemplate_ignore_missing = 0
<
					*g:colortemplate_no_aux_files*
Set to 1 if you do not want to generate any auxiliary file (including the help
file).
>
	let g:colortemplate_no_aux_files = 0
<
					*g:colortemplate_no_doc*
Set to 1 if you do not want to generate the help file.
>
	let g:colortemplate_no_doc = 0
<
					*g:colortemplate_no_mappings*
Set to 1 to suppress mappings.
>
	let g:colortemplate_no_mappings = 0
<
					*b:colortemplate_outdir*
The directory for the generated color scheme and optional auxiliary files.
This is set automatically when opening a template and is usually set to
a reasonable default. You may view and change the current value of this option
with |:ColortemplateOutdir| or by clicking on "OutDir" in the window toolbar.

					*g:colortemplate_popup_bg*
The name of a highlight group to be used for the background of the style
picker.
>
	let g:colortemplate_popup_bg = 'Normal'
<
For example, to use a black background no matter what the color scheme
is, you may define:
>
	hi MyBlack ctermbg=16 guibg=#000000
	let g:colortemplate_popup_bg = 'MyBlack'
<
					*g:colortemplate_popup_borderchars*
A list with eight character elements, which is used for drawing the border of
the style picker. See |popup_create-arguments|.
>
	let g:colortemplate_popup_borderchars =
	    \ ['─', '│', '─', '│', '┌', '┐', '┘', '└']
<
					*g:colortemplate_popup_default_pane*
The default pane that should be presented to the user when the style picker is
opened. The possible values are `'rgb'`, `'hsb'`, `'gray`', and `'help'`.
>
	let g:colortemplate_popup_default_pane = 'rgb'
<
					*g:colortemplate_popup_fav_path*
The path where the style picker's favorite colors are saved.
>
	let g:colortemplate_popup_fav_path =
	    \ '$HOME/.vim/colortemplate_favorites.txt'
<
					*g:colortemplate_popup_keys*
A Dictionary used to customize the keys used by the style picker. For example,
to use `q` to close the popup, put this in your |vimrc|:
>
	let g:colortemplate_popup_keys = { 'close': 'q' }
<
Keep in mind that, by default, mappings are processed before passing keys to
the popup. In practice, the keys used in the popup should not be mapped in
Normal mode. See also |g:colortemplate_popup_mapping|.

Note: multiple-keystroke mappings are not allowed!
>
	let g:colortemplate_popup_keys = {
	    \ 'close':            "x",
	    \ 'cancel':           "X",
	    \ 'yank':             "Y",
	    \ 'down':             "\<down>",
	    \ 'up':               "\<up>",
	    \ 'top':              "T",
	    \ 'decrement':        "\<left>",
	    \ 'increment':        "\<right>",
	    \ 'next-color':       "\<tab>",
	    \ 'prev-color':       "\<s-tab>",
	    \ 'toggle-bold':      "B",
	    \ 'toggle-italic':    "I",
	    \ 'toggle-underline': "U",
	    \ 'toggle-standout':  "S",
	    \ 'toggle-inverse':   "V",
	    \ 'toggle-undercurl': "~",
	    \ 'toggle-strike':    "-",
	    \ 'new-color':        "E",
	    \ 'new-higroup':      "N",
	    \ 'clear':            "Z",
	    \ 'rgb':              "R",
	    \ 'hsb':              "H",
	    \ 'gray':             "G",
	    \ 'help':             "?",
	\ }
<
					*g:colortemplate_popup_mapping*
Set the "mapping" attribute of the style picker. When set to 1, any key
arrives to the popup after any mapping. This may interfere with the keyboard
controls of the style picker. In such cases, you may set this to 0 or
(probably better) redefine some keys with |g:colortemplate_popup_keys|.
>
	let g:colortemplate_popup_mapping = 1
<
					*g:colortemplate_popup_marker*
The String used to mark the selected line in the style picker. The width of
the style picker adapts to accommodate symbols of arbitrary length.
>
	let g:colortemplate_popup_marker = '❯❯ '
<
					*g:colortemplate_popup_notifications*
Set to 0 if you want to suppress the notification popups (such as 'Color
cleared', 'Color yanked', etc.) in the style picker.
>
	let g:colortemplate_popup_notifications = 1
<
					*g:colortemplate_popup_quotes*
A List of quotes to be displayed as sample text in the style picker.
>
	let g:colortemplate_popup_quotes = [<some wisdom>]
<
					*g:colortemplate_popup_star*
The one-character symbol used for stars in the style picker.
>
	let g:colortemplate_popup_marker = '*'
<
					*g:colortemplate_quiet*
Set to 0 if you want Colortemplate to open the generated color scheme in
a split window immediately after building it.
>
	let g:colortemplate_quiet = 1
<
					*g:colortemplate_rtp*
By default, Colortemplate prepends the default output directory (see
|b:colortemplate_outdir|) to |runtimepath| to make sure that the correct color
scheme is found when you test your color scheme. Set this option to 0 if you
do not want Colortemplate to ever touch your |runtimepath|.
>
	let g:colortemplate_rtp = 1
<
					*g:colortemplate_slider_ascii*
Set to 1 to use ASCII symbols for the level bars in the style picker. This
option is ignored if |g:colortemplate_slider_symbols| is defined.
>
	let g:colortemplate_slider_ascii = 0
<
					*g:colortemplate_slider_symbols*
A List of nine elements to be used to draw level bars in the style picker.
>
	let g:colortemplate_slider_symbols =
            \ [" ", "▏", "▎", "▍", "▌", "▋", "▊", "▉", '█']
<
					*g:colortemplate_source_comment*
Set to 0 if you do not want Colortemplate to append the source template as
a comment at the end of the generated color scheme. Set to 1 if you want only
color definitions to be appended (this is the default). Set to 2 if you want
most of the source directives to be appended to the output files, including
color definitions, terminal colors, highlight group definitions and verbatim
blocks.
>
	let g:colortemplate_source_comment = 1
<
					*g:colortemplate_timestamp*
Set to 0 if you do not want a timestamp in the generated color scheme.
>
	let g:colortemplate_timestamp = 1
<
					*g:colortemplate_toolbar*
Set to 0 if you do not want to use the toolbar.
>
	let g:colortemplate_toolbar = 1
<
					*g:colortemplate_toolbar_items*
A List with the names of the menu entries to be used in the window toolbar.
Each menu entry must have a corresponding definition in
|g:colortemplate_toolbar_actions|.
>
	let g:colortemplate_toolbar_items = [
	      \ 'Build!',
	      \ 'BuildAll!',
	      \ 'Show',
	      \ 'Hide',
	      \ 'Check',
	      \ 'Stats',
	      \ 'Source',
	      \ 'HiTest',
	      \ 'OutDir',
	      \ ])
<
					*g:colortemplate_toolbar_actions*
A Dictionary mapping menu entries to the corresponding commands. For instance:
>
	let g:colortemplate_toolbar_actions = {
	     \ 'Build!': ':Colortemplate!<cr>'
	     \ }
<
This option only defines the actions associated to each label. For a menu
entry to actually be visible in the toolbar, it must be listed in
|g:colortemplate_toolbar_items| as well.

					*g:colortemplate_use_tabs*
Set to 1 if you want the generated color schemes to use hard tabs instead of
spaces.
>
	let g:colortemplate_use_tabs = 0
<
					*g:colortemplate_warnings*
Set to 0 if you want Colortemplate to report only errors (not recommended).
>
	let g:colortemplate_warnings = 1
<
==============================================================================
Colortemplate commands				*colortemplate-commands*

Global commands ~

Note: Global commands are available in any buffer, but only after a template
has been opened.

						*:ColortemplateStyle*
Opens a |popup| window that allows you to dynamically change the colors and
style of highlight groups. The command takes the name of a highlight group as
an optional argument. See |colortemplate-popup| for the details.

Buffer-local commands ~
						*:Colortemplate[!]*
Creates a Vim color scheme from the template in the current buffer. If used
without arguments, the output is written in |b:colortemplate_outdir|. The
command takes an optional argument, which is an alternative path to
a directory where the output should be saved. If `!` is present, any existing
files will be overwritten.

						*:ColortemplateAll[!]*
Builds the template in the current buffer and all the other templates in the
same directory as the current buffer (if any). This is useful to build several
color schemes at once. If used without arguments, the output is written in
|b:colortemplate_outdir|. The command takes an optional argument, which is an
alternative path to a directory where the output should be saved. If `!` is
present, any existing files will be overwritten.

						*:ColortemplateCheck*
Runs a series of checks on the generated color scheme using Vim's validation
script `$VIMRUNTIME/colors/tools/check_colors.vim`.

						*:ColortemplateOutdir*
Shows the current value of |b:colortemplate_outdir| in the command line and
prompts for a new path. Leave empty and press Enter or press Esc if you do not
want to change the path.

						*:ColortemplateStats*
Computes some color statistics and shows them in a scratch buffer.
See |colortemplate-stats| for more information.

==============================================================================
Window toolbar					*colortemplate-toolbar*

The window toolbar (|WinBar|) is available in Vim 8.0.1123 or later and
provides a quick way to execute the most common tasks, streamlining your
workflow. The toolbar appears automaticaly when you open a template file whose
name does not start with an underscore.

A close button is present at the rightmost end of the toolbar if you wish to
close it. To show a hidden toolbar or refresh the current toolbar, press
CTRL-L. If you do not want the toolbar, unset |g:colortemplate_toolbar|.

The menu entries and the corresponding actions may be customised with
|g:colortemplate_toolbar_items| and |g:colortemplate_toolbar_actions|. By
default, the window toolbar has the following menu entries:

Build! ~
Executes |:Colortemplate!| in the current buffer and writes the output inside
the default output directory (see |b:colortemplate_outdir|).

BuildAll! ~
Executes |:ColortemplateAll!| in the current buffer and writes the output
inside the default output directory (see |b:colortemplate_outdir|).

Show ~
Enables the color scheme corresponding to the template in the current buffer.

Hide ~
Switches back to the original color scheme.

Check ~
Executes |:ColortemplateCheck|.

Stats ~
Executes |:ColortemplateStats|.

Source ~
Edits the generated color scheme in a split window.

HiTest ~
Enables the color scheme and executes `runtime` `syntax/hitest.vim`.

OutDir ~
Shows the current output directory and allows you to change it. See
|b:colortemplate_oudir|.

==============================================================================
The style picker					*colortemplate-popup*

Colortemplate implements a sophisticated "style picker", with which you can
modify a color scheme in real time. This enables frictionless experimentation
with color schemes directly within Vim. This feature is based on Vim's |popup|
and |text-properties|.

The style picker can be opened with |gs|, |ColortemplateStyle| or by invoking
|colortemplate#style#open()|. Both the command and the function take the name
of a highlight group as an optional argument. When no argument is given, the
popup reflects the status of the highlight group under the cursor. Providing
a highlight group is necessary for editing the elements of Vim's interface
that are not inside buffers, such as status lines. Note that |gs| is
a filetype-specific mapping and |ColortemplateStyle| becomes available only
after opening a Colortemplate buffer. The function, however, can be invoked
anywhere at any time. See |colortemplate-mappings| if you want to open the
style picker from any buffer.

If this is the first time you use the style picker, you may want to open it
now and try using it while reading this section.

The popup window consists of four panes: RGB, HSB, Grayscale, and Help, which
can be selected by typing |R|, |H|, |G|, and |?|, respectively.

Use up and down arrow keys to choose an item in the popup. The current item
has a marker on the side. When a level bar is selected, you may change the
corresponding value with the left and right keys. Changes are applied
immediately. The amount by which a slider is changed can be set by simply
typing a number between 1 and 99 while the marker is on a level bar. The
current step is shown below the sliders. When the marker is elsewhere, the
numbers you type are passed to the underlying buffer, so you can continue
using counts with your mappings (e.g., you may type `5j` to move down five
lines).

To choose a new color, press |E|. If the environment supports millions of
colors, you will be asked to enter a hex value. If the value has one, two, or
three characters, it will be automatically expanded to its six character
version (e.g., `#cd` will be interpreted as `#cdcdcd`). If the environment
does not support true colors, you will be asked to enter a new terminal color,
i.e., a value between 16 and 255. To clear a color (i.e., to set it to
`NONE`), press |Z|.

To choose a specific highlight group, press |N|. Attributes such as boldface,
italics, and so on, can be toggled by pressing a key: |B| for bolface, |I| for
italics, etc. See the Help pane for the details. Press |Tab| or |S-Tab| to
cycle through the foreground, background, and special color for the current
highlight group.

In the middle of the pane, some information is displayed about the current
color. It looks as follows:
>
	██ #9fbec6 ****  ██ 109 **    Δ7.1 BIUSV~-
<
Here you may see the hex value of the color (`#9fbec6`), its best terminal
approximation (`109`), the difference between the GUI and terminal color
(`7.1`, see |colortemplate-stats|), and which attributes are applied to the
current highlight group (`BIUSV~-`, attributes that are active are
highlighted). Besides, an evaluation of the "quality" of the GUI and terminal
colors against the background of the current highlight group are provided in
the form of stars. A color can have up to five stars, according to how many of
the following tests it passes:

- the contrast ratio (CR) between the (foreground/special) color and the
  background is >=3.0;
- CR >= 4.5;
- CR >= 7.0;
- the color difference between the color and the background is >=500;
- the brightness difference between the color and the background is >=125.

When the background color is active, the foreground of the highlight group is
used for comparison.

The thresholds are based on W3C guidelines:

    https://www.w3.org/TR/AERT/
    https://www.w3.org/TR/2008/REC-WCAG20-20081211/

Generally speaking, I'd say that you should aim at getting at least two/three
stars for each highlight group, and at least four/five for the |Normal| group.
This will ensure that your color scheme will have good legibility, even for
people with color deficits. That said, use with a grain of salt: if you are
developing a low-contrast color scheme for your programming night sessions,
your colors will most likely get zero or one star. That does not necessarily
make your color scheme "bad"—just one that can be used subject to some
constraints (e.g, low-light conditions and visually unimpaired users).

As you modify a color scheme, the style picker remembers the ten most recently
used colors. With the marker in the Recent section, you may press |Enter| to
select a recent color, |D| to remove a color from the list, or |Y| to yank a
recent color into the unnamed register.

The bottom part of the style picker hosts a section for your favorite colors.
To make a color a favorite one, type |A|. Choosing, deleting or yanking
a favorite color is done in the same way as for recent colors. Favorite colors
persist across Vim sessions: they are written to disk at the location
specified by |g:colortemplate_popup_fav_path|. The saved file is just a text
file with one color per line; it can be easily edited by hand if desired.

When the marker is on a level bar, type |Y| to yank the current color. The
reverse is also possible: if the unnamed register contains a hex color, you
may paste it into the style picker as the current color by typing |P|.

Press |x| or click on the upper-right corner of the popup window to dismiss
it. If you want to revert your changes by resetting the current color scheme,
press |X| instead.

You may drag the popup around with the mouse. The window is not resizable.

Note: when the popup is open all keystrokes are filtered by the popup. Only
the keys that are not used by the popup are "passed through" to the underlying
buffer. That means that none of the keys used by the popup are available to
the underlying buffer. For instance, you cannot select text with |V| while the
popup is open, because |V| is used by the popup to toggle reverse text. But
you can still use |v|, because the style popup does not map that key. If the
popup gets in the way, just close it with |x|.

==============================================================================
Colortemplate functions				*colortemplate-functions*

These are some utility functions that advanced users may find useful.

					*colortemplate#format_palette()*
Formats a Dictionary of color name/value pairs into Colortemplate format. The
returned value is a List, each item of which contains a color definition. To
insert the color definitions at the current cursor's position, you may use
something like:
>
	:call append('.', colortemplate#format_palette(some_color_dictionary))
<
					*colortemplate#import#run()*
Creates a template document in a new buffer by extracting information from the
currently defined highlight groups. For optimal results, it is recommended to
run a GUI version of Vim or to run terminal Vim in an environment supporting
`termguicolors`, and to proceed as follows:

- run `vim --clean`;
- load (with |:colorscheme|) the color scheme to be imported;
- add Colortemplate to |runtimepath|;
- `:call` `colortemplate#import#run()`.

Note: although the generated template should compile out of the box and
faithfully reproduce your currently active color scheme, keep in mind that
this function is only meant to facilitate the initial scaffolding of a new
template.

					*colortemplate#vimspectr#palette()*
Returns a Dictionary of color name/value pairs corresponding to the given
Vimspectr parameters. The function takes two arguments: the first argument is
the saturation curve (allowed values are `'grey'`, `'flat'`, `'wflat'`,
`'curve'`, and `'wcurve'`); the second argument is a hue value between 0 and
359. For example:
>
	:echo colortemplate#vimspectr#palette('curve', 0)
<
The color names are `g0`, `g1`, ... through `g7`.

See also: https://github.com/nightsense/vimspectr

					*colortemplate#style#favorite()*
Returns the list of favorite colors in the style picker.

					*colortemplate#style#recent()*
Returns the list of recent colors currently in the style picker.

					*colortemplate#syn#balloonexpr()*
This function can be used to display some information about the highlight
group under the mouse pointer when |ballooneval| or |balloonevalterm| is set.
The information that is displayed is similar to the output of
|colortemplate#syn#toggle()|.

To enable these popups in Colortemplate buffers, just set |ballooneval| or
|balloonevalterm|. To enable these popups globally, you also need to set
|balloonexpr| to this function.

Note: these popups require |+popupwin| and |+textprop|.

					*colortemplate#syn#toggle()*
Toggles the display of highlight group information for the text under the
cursor. The information is displayed in the command line and has the following
form:
>
	vimVar ⊂ vimFuncBody xxx vimVar → Identifier
	██ fg=14/#00aba5    bg=NONE/NONE    sp=NONE/NONE
<
From left to right and top to bottom, this shows:

- the nesting of highlight groups, or "synstack" (`⊂`);
- a sample of how the text looks like with the current hi group (`xxx`);
- the hi group to which the current hi group resolves, if any (`→`);
- the terminal/GUI values of the foreground, background, and special color.

See also |colortemplate-mappings|.

==============================================================================
Best practices					*colortemplate-best-practices*

Here are some guidelines to develop outstanding hackable color schemes:

- Give each of your colors a short distinctive name.

- Provide support for all terminals, including those with few colors. You
  should define at least three variants: `gui`, `256`, and `8` (or `16`). You
  may add support for black and white terminals with minimal effort by
  including `templates/_bw.colortemplate` in your own templates.

- Do not use too many colors. For maximum portability, you should define eight
  or sixteen colors that map nicely to terminal ANSI colors (black, red,
  green, yellow, blue, magenta, cyan, white, and their bright variants).

- For base-16 colors, prefer color names to numbers for maximum portability
  (see |cterm-colors|).

- Do not define many options. The ideal number of options for a color scheme
  is… zero. Colortemplate does not define any option by default. Note that
  some features such as italics are detected automatically, so in general you
  won't need an option for italics.

- If your color scheme has some option, document it!

- Do not rely only on boldface, italics, or underlined text to visually
  distinguish an element: some setups do not support any of those.

- Visually check every part of your color scheme. Use as many text samples as
  possible: string-heavy languages may look completely different from
  keyword-heavy ones. If you support transparent backgrounds, make sure to
  test your color scheme both against an opaque and a transparent background.
  A few areas that are often overlooked include:

  a. The tabline (|hl-TabLine|, |hl-TabLineFill|, |hl-TabLineSel|). You may
     open a new tab with |tabnew|. See also |showtabline|.

  b. Folded text (|hl-Folded|, |hl-FoldColumn|). Set |foldcolumn| to
     a positive value to test the latter; for the former, create a buffer and
     execute:
>
	:set fdm=marker
<
     then type something like:
>
	{{{
	some text
	}}}
<
     Position the cursor on the text and use |zc| and |zv| to toggle the fold.

  c. The signs column (|hl-SignColumn|). Try placing a sign as explained in
     |sign-commands|:
>
	:sign define piet text=>>
	:exe ":sign place 2 line=23 name=piet file=" . expand("%:p")
<
  d. The cursor's appearance (|hl-Cursor|), especially with |cursorline| and
     |cursorcolumn| on. For this, you may need to use some GUI version of Vim,
     as most terminals override the cursor's color.

  e. Matching parentheses (|hl-MatchParen|) and cursor/visual highlighting.
     Is the cursor clearly visible over a parenthesis? Is the
     matching parenthesis easily spotted? Even when |cursorline| and
     |cursorcolumn| are set?
     Use different highlighting for |hl-MatchParen| and |hl-Visual|:
     |hl-MatchParen| may be used to highlight several words or whole lines,
     and you want a selection within an area highlighted with |hl-MatchParen|
     to be distinguishable.

  f. Search highlight (|hl-Search|, |hl-IncSearch|), especially with
     |cursorline| and |cursorcolumn| on. The |hl-Search| and |hl-IncSearch|
     highlight groups must be distinguishable: set |incsearch| and |hlsearch|,
     search for a pattern with multiple occurrences and move between them with
     CTRL-G and CTRL-T. Can you spot where the cursor is? With |cursorcolumn|
     and |cursorline| on, the highlighted column and cursor line should "pass
     behind" highlighted search results. You may achieve that effect by
     adapting the following snippet:
>
	CursorLine   none   grey            ; No foreground color
	CursorColumn none   grey            ; No foreground color
	Search       yellow fg    reverse   ; Use reverse
<
  g. Diffs (|hl-DiffAdd|, |hl-DiffChange|, |hl-DiffDelete|, |hl-DiffText|).
     Open two buffers in a split window and execute |diffthis| on both of
     them.

  h. The completion menu (|hl-Pmenu|, |hl-PmenuSbar|, |hl-PmenuSel|,
     |hl-PmenuThumb|). A simple way to test that is to define a dictionary:
>
	:set dictionary=/usr/share/dict/words
<
     then type something like `vi`<c-x><c-k>. Scroll through the entries with
     CTRL-N and CTRL-P to make sure that the sidebar is properly visible.

  i. Line numbers (|hl-LineNr|, |hl-CursorLineNr|). Set |number| and check
     that everything looks right.

  j. Command-line completion (|hl-WildMenu|). Set |wildmenu| and try to
     complete something in the command-line. Can you easily see the possible
     completions and the current completion above the command-line?

  k. The window toolbar (|hl-ToolbarLine|, |hl-ToolbarButton|). See
     |window-toolbar|. This is a feature introduced in Vim 8.0.1123. You may
     test this in a Colortemplate buffer! Just press CTRL-L if the toolbar is
     not already visible.
>
- Execute:
>
	:set showtabline=2 laststatus=2
	:vsplit
<
  Do the statuslines (|hl-StatusLine|, |hl-StatusLineNC|), the tabline (see
  above), and the vertical split (|hl-VertSplit|) merge harmoniously or do
  they appear like disconnected components?

  Keeping in mind the above, make the vertical splits distinguishable from the
  status lines. This can be achieved by using different colors for
  |hl-VertSplit| and |hl-StatusLine|/|hl-StatusLineNC| and/or by using
  different foreground and background colors for |hl-VertSplit|, so that the
  separator character (a vertical bar by default) is visible. The user can
  always suppress (or replace) the separator character with 'fillchars'.

  The rationale for this guideline is that it makes it clear how a window has
  been split. For example, a vertical split followed by two horizontal splits
  produces this layout:
>
	      |
	      |
	------|-------
	      |
	      |
<
  A horizontal split followed by two vertical splits produces this instead:
>
	      |
	      |
	--------------
	      |
	      |
<
  In the former case, the two status lines can be dragged independently, while
  in the latter case they move together as if they were a single status line.
  Similarly, in the former case there is only one long vertical split, while
  in the latter there are two independent vertical bars.

- Some users like to use a transparent background (e.g., with custom images)
  in the terminal. You may easily support that by adapting this snippet:
  >
	Variant: 256 16 8
	#if get(g:, '@optionprefix_transp_bg', 0)
	  Normal some_color none
	  ; Other definitions specific for transparency
	#else
	  Normal some_color some_other_color
	  ; Other definitions specific for opaqueness
	#endif
<
  Do not forget to document `@optionprefix_transp_bg`!

- Verbatim blocks and aux files allow you to get fancy. Avoid getting too
  fancy.

=============================================================================
Providing feedback				*colortemplate-feedback*

For bug reports and feature requests please use:

    https://github.com/lifepillar/vim-colortemplate/issues

Pull requests are welcome, too!

 vim:tw=78:ts=8:ft=help:norl:
