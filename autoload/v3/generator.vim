vim9script

import './colorscheme.vim'
import './version.vim'
import 'librelalg.vim' as ra

# Aliases {{{
const AntiJoin             = ra.AntiJoin
const Avg                  = ra.Avg
const AvgBy                = ra.AvgBy
const Bool                 = ra.Bool
const Build                = ra.Build
const CoddDivide           = ra.CoddDivide
const Count                = ra.Count
const CountBy              = ra.CountBy
const CountDistinct        = ra.CountDistinct
const Divide               = ra.Divide
const Extend               = ra.Extend
const EquiJoin             = ra.EquiJoin
const EquiJoinPred         = ra.EquiJoinPred
const Filter               = ra.Filter
const Float                = ra.Float
const ForeignKey           = ra.ForeignKey
const Frame                = ra.Frame
const From                 = ra.From
const GroupBy              = ra.GroupBy
const Int                  = ra.Int
const Intersect            = ra.Intersect
const Join                 = ra.Join
const LeftNatJoin          = ra.LeftNatJoin
const ListAgg              = ra.ListAgg
const Max                  = ra.Max
const MaxBy                = ra.MaxBy
const Min                  = ra.Min
const MinBy                = ra.MinBy
const Minus                = ra.Minus
const NatJoin              = ra.NatJoin
const NotIn                = ra.NotIn
const Product              = ra.Product
const Project              = ra.Project
const Query                = ra.Query
const Rel                  = ra.Rel
const RelEq                = ra.RelEq
const Rename               = ra.Rename
const Select               = ra.Select
const SemiJoin             = ra.SemiJoin
const Sort                 = ra.Sort
const SortBy               = ra.SortBy
const Split                = ra.Split
const Str                  = ra.Str
const StringAgg            = ra.StringAgg
const Sum                  = ra.Sum
const SumBy                = ra.SumBy
const Table                = ra.Table
const Transform            = ra.Transform
const Union                = ra.Union
const Zip                  = ra.Zip
# }}}

const VERSION  = version.VERSION
const NO_DISCR = colorscheme.DEFAULT_DISCR_VALUE
const Database = colorscheme.Database
const Metadata = colorscheme.Metadata

# Helper functions {{{
def In(item: string, collection: list<string>): bool
  return index(collection, item) != -1
enddef
# }}}

# Integrity checks {{{
def CheckMetadata(meta: Metadata)
  if empty(meta.fullname)
    throw 'Please define the full name of the color scheme'
  endif

  if empty(meta.shortname)
    throw 'Please define the short name of the color scheme'
  endif

  if empty(meta.author)
    throw 'Please define the author of the color scheme'
  endif
enddef

def CheckMissingGroups(db: Database)
  const missing = Query(
    db.HiGroup
    ->AntiJoin(db.HiGroupVersion,
               (t, u) => t.HiGroupName == u.HiGroupName)
  )

  if !empty(missing)
    const names = mapnew(missing, (_, t) => t.HiGroupName)
    echomsg printf(
      "Missing %s definitions for %s", db.background,
      join(names, ', ')
    )
  endif
enddef

def CheckMissingDefaultDefinitions(db: Database)
  const missingDefault = Query(
    db.HiGroupVersion
    ->AntiJoin((db.HiGroupVersion->Select((t): bool => t.IsDefault)),
               (t, u) => t.HiGroupName == u.HiGroupName)
    ->Project('HiGroupName')
  )

  if !empty(missingDefault)
    const names = mapnew(missingDefault, (_, t) => t.HiGroupName)
    throw printf(
      "Missing %s default definition for %s", db.background,
      join(names, ', ')
    )
  endif
enddef
# }}}

# Header {{{
def AddMeta(header: list<string>, text: string, value: string): list<string>
  if !empty(value)
    header->add(printf(text, value))
  endif

  return header
enddef

def AddList(header: list<string>, text: string, items: list<string>): list<string>
  if !empty(items)
    header->AddMeta(text, items[0])

    const n = len(items)
    const spaces = repeat(' ', len(text) - 3)
    var i = 1
    while i < n
      header->add(printf('#%s%s', spaces, items[i]))
      ++i
    endwhile
  endif

  return header
enddef

def Header(meta: Metadata): list<string>
  const license     = empty(meta.license) ? 'Vim License (see `:help license`)' : meta.license
  var   header      = ['vim9script', '']

  header->AddMeta('# Name:           %s', meta.fullname)
  header->AddMeta('# Version:        %s', meta.version)
  header->AddList('# Description:    %s', meta.description)
  header->AddList('# Author(s):      %s', meta.author)
  header->AddList('# Maintainers(s): %s', meta.maintainer)
  header->AddList('# URL(s):         %s', meta.url)
  header->AddMeta('# License:        %s', meta.license)
  header->AddMeta('# Last Updated:   %s', strftime("%c"))
  header->add('')
  header->AddMeta('# Generated by Colortemplate v%s', VERSION)
  header->add('')

  if !meta.backgrounds.light
    header->add('set background=dark')->add('')
  elseif !meta.backgrounds.dark
    header->add('set background=light')->add('')
  endif

  header->add('hi clear')
  header->AddMeta("g:colors_name = '%s'", meta.shortname)->add('')
  header->add("const t_Co = exists('&t_Co') && !has('gui_running') ? (&t_Co ?? 0) : -1")
  header->add('')

  return header
enddef
# }}}

# Variant generation {{{
def Cmp(s1: string, s2: string): number
  return s1 < s2 ? -1 : 1
enddef

def SortByHiGroupName(t: dict<any>, u: dict<any>): number
  if t.HiGroupName == 'Normal'
    return u.HiGroupName == 'Normal' ? 0 : -1
  elseif u.HiGroupName == 'Normal'
    return 1
  else
    return Cmp(t.HiGroupName, u.HiGroupName)
  endif
enddef

def SortByDiscrValueAndHiGroupName(t: dict<any>, u: dict<any>): number
  if t.DiscrValue == u.DiscrValue
    if t.HiGroupName == u.HiGroupName
      return 0
    else
      return SortByHiGroupName(t, u)
    endif
  else
    return Cmp(t.DiscrName, u.DiscrName)
  endif
enddef

def Variant(db: Database, variant: string): dict<list<dict<any>>>
  var linkedGroups = Query(
    db.LinkedGroup
    ->Select((t) => t.Variant == variant)
    ->NatJoin(db.HiGroup)
  )

  var baseGroups = Query(
    db.BaseGroup
    ->Select((t) => t.Variant == variant)

    ->NatJoin(
      db.Attribute->Extend((t): dict<any> => {
        return {StyleAttrs: t.AttrKey .. '=' .. t.AttrValue}
      })->GroupBy(['HiGroupName', 'Variant', 'DiscrValue'],
                  StringAgg('StyleAttrs', ' ', ''), 'StyleAttrs'))

    ->LeftNatJoin(
      db.ColorAttribute
      ->NatJoin(db.ColorVariant)
      ->Extend((t): dict<any> => {
        return {ColorAttrs: t.ColorKey .. '=' .. t.ColorValue}
      })->GroupBy(['HiGroupName', 'Variant', 'DiscrValue'],
                  StringAgg('ColorAttrs', ' ', ''), 'ColorAttrs'),
      [{ColorAttrs: ''}])

    ->NatJoin(db.HiGroup)
  )

  return {'linked': linkedGroups, 'base': baseGroups}
enddef
# }}}

def LinkedGroupToString(t: dict<any>): string
  return printf("hi! link %s %s", t.HiGroupName, t.TargetGroup)
enddef

def BaseGroupToString(t: dict<any>): string
  return printf("hi %s %s %s", t.HiGroupName, t.ColorAttrs, t.StyleAttrs)
enddef

# groups is a list of highlight groups definitions sharing the same DiscrName
def Override(
    theme: list<string>, groups: list<dict<any>>, ToString: func(dict<any>): string
): list<string>
  sort(groups, SortByDiscrValueAndHiGroupName)
  const discrName  = groups[0].DiscrName
  var   discrValue = groups[0].DiscrValue

  theme->add(printf("if %s == %s", discrName, discrValue))

  for g in groups
    if g.DiscrValue != discrValue
      discrValue = g.DiscrValue
      theme->add(printf("elseif %s == %s", discrName, discrValue))
    endif
    theme->add(ToString(g))
  endfor

  theme->add("endif")

  return theme
enddef

def ProcessOverrides(theme: list<string>, override: dict<list<dict<any>>>, ToString: func(dict<any>): string): list<string>
  for groups in values(override)
    Override(theme, groups, ToString)
  endfor

  return theme
enddef

def ProcessDefaults(theme: list<string>, defaults: list<dict<any>>, ToString: func(dict<any>): string): list<string>
  sort(defaults, SortByHiGroupName)

  for g in defaults
    theme->add(ToString(g))
  endfor

  return theme
enddef

def Partition(groups: list<dict<any>>): dict<list<dict<any>>>
  var partition = {}

  for g in groups
    const name = g.DiscrName
    if !partition->has_key(name)
      partition[name] = []
    endif
    partition[name]->add(g)
  endfor

  return partition
enddef

# Main {{{
export def Generate(meta: Metadata, dbase: dict<Database>): list<string>
  CheckMetadata(meta)

  for [bg, dbValue] in items(dbase)
    if meta.backgrounds[bg]
      const db: Database = dbValue
      CheckMissingGroups(db)
      CheckMissingDefaultDefinitions(db)
    endif
  endfor

  var   theme    = Header(meta)
  const variants = meta.variants

  for variant in meta.variants
    theme->add(printf("if # is variant %s", variant))

    for [bg, dbValue] in items(dbase)
      if !meta.backgrounds[bg]
        continue
      endif

      theme->add(printf("# [TODO] Background: %s", bg))

      const db: Database = dbValue
      var   groups       = Variant(db, variant)

      for kind in ['linked', 'base']
        const ToString = kind == 'linked' ? LinkedGroupToString : BaseGroupToString
        var [default, override] = Split(groups[kind], (t) => t.DiscrValue == NO_DISCR)
        var partition = Partition(override)
        ProcessDefaults(theme, default, ToString)
        ProcessOverrides(theme, partition, ToString)
      endfor
    endfor

    theme->add('')->add("finish")->add('endif')->add('')
  endfor

  return theme
enddef
# }}}

# vim: foldmethod=marker nowrap et ts=2 sw=2
