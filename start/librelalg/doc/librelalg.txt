*librelalg.txt*	For Vim version 9.0	Last change: 2022 Dec 30

This library is an implementation of Relational Algebra in Vim 9 script.

Note: Vim 9.0.1108 or later is required.

0. Quick start				|librelalg-quickstart|
1. Tutorial				|librelalg-tutorial|
2. Data definition language		|librelalg-ddl|
3. Data manipulation language		|librelalg-dml|
4. Relational Algebra			|librelalg-ra|
5. Aggregate functions			|librelalg-aggr|
6. Other functions			|librelalg-other|
7. Tips and tricks			|librelalg-tips|

==============================================================================
0. Quick start					*librelalg-quickstart*

A relation instance (or, simply, a relation) is just a list of homogeneous
dictionaries, such as this:
>
	var r = [{A: 1, B: 'bbb'},
		 {A: 2, B: 'aaa'},
		 {A: 3, B: 'bbb'}]
<
Relational Algebra operators (conceptually) transform relations into other
relations. For example:
>
	vim9script
	import 'librelalg.vim' as ra

	var r = [{A: 1, B: 'bbb'},
		 {A: 2, B: 'aaa'},
		 {A: 3, B: 'bbb'}]

	const result = ra.Query( ra.Select(r, (t) => t.B == 'bbb') )
	echo result
	echo ra.Table(result)
<
Output:
>
	[{'A': 1, 'B': 'bbb'}, {'A': 3, 'B': 'bbb'}]

	───────
	 A   B
	───────
	 1 bbb
	 3 bbb
<
So, at the basic level you may perform Relational queries on Vim's data
structures. See |librelalg-ra| to learn about the available operators.

But librelalg also offers support for data definition and data manipulation
with built-in integrity. For that, start by defining a Relational schema:
>
	vim9script

	import "librelalg.vim" as ra

	const Int   = ra.Int
	const Str   = ra.Str
	const Float = ra.Float

	#                    Name  Schema               Keys
	var R = ra.Relation('R',   {A: Int, B: Float},  [['A']])
	var S = ra.Relation('S',   {X: Str, Y: Int},    [['X']])

	ra.ForeignKey(S, ['Y'], R, ['A'])  # FK: S[Y] -> R[A]
	ra.Check(R, (t) => t.B > 0.0, 'B must be greater than zero')
<
Populate the database:
>
	R->ra.InsertMany([
	  {A: 10, B: 3.2},
	  {A: 20, B: 0.6},
	])

	S->ra.InsertMany([
	  {X: 'xyz', Y: 10},
	  {X: 'abc', Y: 20},
	  {X: 'klm', Y: 10},
	])
<
Query the database:
>
	# Find all X that are related to a tuple in R with B > 1.5,
	# sorted lexicographically:

	var rel = ra.Query(
	    ra.EquiJoin(S, R, ['Y'], ['A'])
	    ->ra.Select((t) => t.B > 1.5)
	    ->ra.Project(['X'])
	    ->ra.SortBy(['X'])
	)
	echo ra.Table(rel)
<
Output:
>
	─────
	   X
	─────
	 klm
	 xyz
<
Update the database:
>
	R->ra.Insert({A: 30, B: 4.3})
	S->ra.Update({X: 'klm', Y: 30})
	S->ra.Delete((t) => t.Y == 10)
	rel = ra.Query(ra.EquiJoin(R, S, ['A'], ['Y']))
	echo ra.Table(rel)
<
Output:
>
	───────────────
	  A   B   X  Y
	───────────────
	 20 0.6 abc 20
	 30 4.3 klm 30
<
==============================================================================
1. Tutorial					*librelalg-tutorial*

Suppose that you want to write a script that keeps track of some “tags”
associated to each buffer. Since data is king, a good place to start is by
defining a (Relational) data model for your script. Suppose that, after
carefully evaluating the requirements for your script, your model looks like
this (using standard IDEF1X notation):
>
	 Buffer
	┌───────────────┐
	│ BufId     Int │
	├───────────────┤
	│ BufName   Str │ AK
	└───────┬───────┘
	        │
	  is tagged by /
	    appears in
	        │
	 Tag    ●
	╭───────────────╮
	│ BufId     Str │ FK
	│ TagName   Str │
	├───────────────┤
	│ Line      Int │ (1)
	│ Column    Int │ (1)
	╰───────────────╯
	(1) Lines and columns must be greater than zero.
<
If you are not familiar with IDEF1X or similar diagramming tools, each box
represents an "entity" (your script will deal with “buffers” and “tags”, so
there are two entities in this model). Each entity has a name, written above
its box, and attributes, which are written inside the box. The attributes will
be the actual pieces of data stored and manipulated by your script. Each box
also contains a separator line: the attributes above the separator form the
"primary key" of the entity—that is, the main identifier of each entity
instance; the attributes below the separator are further descriptors of the
entity. For instance, each tag is identified by the pair {TagName, BufId}, and
it is described by the attributes Line and Column.

Entities are connected by "relationships" represented by lines joining two
entities. The above diagram contains a one-to-many relationship, the dot
representing the “many” side: such relationship establishes that each buffer
is possibly associated to many tags, but each tag is always associated to one
and only one buffer. The entity on the “one” side of the relationship (Buffer,
in this example) is called the "parent" entity; the entity on the “many” side
of the relationship (Tag, in this example) is called a "child" entity. Each
relationship is described by two verb phrases separated by a slash: the first
verb phrase is read from parent to child (in this example: “A buffer is tagged
by zero or more tags”); the second is read from child to parent (“a tag
appears in one buffer”).

AK stands for Alternate Key, and FK stands for Foreign Key. An alternate key
is an alternative identifier for the entity: in this example, it is assumed
that no two buffers share the same name, so `BufName` can be used as an
identifier as well as `BufId`. A foreign key is the primary key of a parent
entity, which is “migrated” into the child entity by virtue of its
relationship with the parent. When a foreign key is entirely part of the
primary key of the child (as in Tag), the child entity is "dependent" on its
parent: in this example, that means that it is not possible to designate a tag
without referencing the buffer to which the tag belongs (dependent entities
are drawn as rectangles with rounded corners, although the rounded corners may
not be particularly prominent in the extended ASCII rendition above). In this
example, Buffer is an "independent" entity: the existence of a buffer does not
depend on anything else in this model. The distinction between independent and
dependent entities has a number of implications: among the rest, it determines
the order in which the database is populated (you cannot insert tags before
inserting the corresponding buffers).

To summarize, the diagram above captures the following facts:

- Buffer is independent;
- a buffer is identified by BufId;
- a buffer is alternatively identified by BufName;
- a buffer is tagged by zero or more tags;
- Tag is dependent on Buffer;
- a tag is identified by {BufId, TagName};
- a tag is described by {Line, Column};
- a tag appears in one (an only one) buffer.
- a tag's line must be an integer greater than zero.
- a tag's column must be an integer greater than zero.

The last two constraints derive from footnote (1) in the data model.

Note: IDEF1X is the ISO standard for Relational modelling (ISO/IEC/IEEE
31320-2). The ISO document is not available for free, but the sections
relevant for Relational modelling are derived (essentially verbatim) from the
older FIPS 184, which is available, for instance, from the Internet Archive:
https://archive.org/details/federalinformati184nati/. Despite its age, the
latter document, and its Annex A in particular, is a good introduction to data
modelling.

Data Definition ~

Now that you have a data model, translating it into code is a relatively
straightforward task:

1. Import the library and optionally define aliases for the imported items you
   are going to use:
>
	vim9script

	import 'librelalg.vim' as ra

	const Bool     = ra.Bool
	const Int      = ra.Int
	const Str      = ra.Str
	const Relation = ra.Relation
	const Insert   = ra.Insert
        # etc.
<
   Note: in the following, for clarity and conciseness, we will write
   librelalg's names without prefix, as if aliases such as those above had
   been defined for all the imported items.

2. Define one base relation for each entity:
>
	var Buffer = Relation('Buffer', {
	    BufId:   Int,
	    BufName: Str,
	  },
	  [['BufId'], ['BufName']]
	)

	var Tag = Relation('Tag', {
	    BufId:   Int,
	    TagName: Str,
	    Line:    Int,
	    Column:  Int,
	  },
	  [['BufId', 'TagName']]
	)
<
   The three mandatory arguments of `Relation()` are

   a. a descriptive relation name;
   b. the relation schema: this is a |dict| mapping attribute names to the
   corresponding data types;
   c. the |list| of keys. Each relation must have at least one key. Each key is
      a |list| of attributes.

   Note: librelalg does not explicitly distinguish between a primary key and
   the alternate keys. The first listed key is conventionally considered the
   primary key.

3. Add the relevant constraints:
>
	Check(Tag, (t) => t.Line > 0 && t.Column > 0,
	      'Line and column numbers must be positive')
<
   A `Check` clause defines a generic constraint, which is simply a function
   or a lambda that, given a tuple t, returns |true| if t satisfies the given
   constraint, and returns |false| otherwise.
>
	ForeignKey(Tag, ['BufId'], Buffer, ['BufId'], 'is tagged by')
<
   `ForeignKey()` defines a foreign key constraint from `BufId` in `Tag` to
   `BufId` in `Buffer`. The verb associated to the constraint (as read from
   the parent to the child entity in the data model) can be optionally
   specified: the verb phrase is used in error messages when the referential
   integrity is violated.

   Note: constraints are checked in the order in which they are declared.

Data Manipulation ~

When the database is defined, you may start populating each base relation with
tuples. Each tuple is just a dictionary conforming to the corresponding
relation schema. Let us insert some data:
>
	Buffer->InsertMany([
	  {BufId: 1, BufName: 'foo'},
	  {BufId: 2, BufName: 'bar'},
	  {BufId: 3, BufName: 'xyz'},
	])

	Tag->InsertMany([
	  {BufId: 1, TagName: 'zzz', Line: 2,  Column: 1},
	  {BufId: 1, TagName: 'abc', Line: 3,  Column: 9},
	  {BufId: 1, TagName: 'xyz', Line: 4,  Column: 1},
	  {BufId: 1, TagName: 'lll', Line: 4,  Column: 8},
	  {BufId: 2, TagName: 'abc', Line: 14, Column: 15},
	  {BufId: 3, TagName: 'abc', Line: 6,  Column: 3},
	])
<
If you want to inspect the content of a relation, you may print it as a table:
>
	echo Table(Buffer)
	echo Table(Tag)
<
The output is (note that the columns are in an arbitrary order):
>
	 Buffer
	───────────────
	 BufName BufId
	───────────────
	     foo     1
	     bar     2
	     xyz     3

	 Tag
	───────────────────────────
	 TagName Column Line BufId
	───────────────────────────
	     zzz      1    2     1
	     abc      9    3     1
	     xyz      1    4     1
	     lll      8    4     1
	     abc     15   14     2
	     abc      3    6     3
<
Of course, any attempt to violate a constraint is rejected with an error.
Trying to insert another buffer called `foobar` will fail with a duplicate key
error, because BufName is a key:
>
	Buffer->Insert({BufId: 2, BufName: 'foobar'})

	# Duplicate key value: ['BufId'] = (2) already exists
<
Referential integrity is also guaranteed. For instance:
>
	Tag->Insert({BufId: 5, TagName: 'x', Line: 3, Column: 9})

	# Buffer is tagged by Tag: Tag['BufId'] = (5) is not present
	# in Buffer['BufId']
<
And, of course, you are not allowed to insert an invalid line number either:
>
	Tag->Insert({BufId: 1, TagName: 'x', Line: 0, Column: 40})
<
This insertion is rejected with the error defined by the `Check` clause:
>
	Line and column numbers must be positive
<
Updates and deletions are possible, too:
>
	Tag->Update({BufId: 1, TagName: 'abc', Line: 7, Column: 12})
	Tag->Delete((t) => t.Line < 2)
	echo Table(Tag)
<
	Output:
>
	 Tag
	───────────────────────────
	 TagName Column Line BufId
	───────────────────────────
	     zzz      1    2     1
	     abc     12    7     1
	     xyz      1    4     1
	     lll      8    4     1
	     abc     15   14     2
	     abc      3    6     3
<
For updates, you just pass the updated tuple. For deletions, you provide
a predicate (typically, in the form of a lambda) that the tuples to be deleted
must satisfy.

Queries ~

The power of the Relational Model lies in its powerful query language as well
as in the simplicity and integrity of its data structures: librelalg provides
all the fundamental operations (set operations, selection, projection, joins,
renaming) as well as some extra operations (division, semi-joins, anti-joins,
group-by, etc.). All operators are implemented using a "push-based" strategy:
without entering into technical details, that means that queries are typically
expanded into tight loops and executed as efficiently as hand-written code.

Queries are expressions typically enclosed in a call to |librelalg.Query()|.
For instance, the query “Retrieve the tags in buffer 1 before line 6” can be
formulated as follows:
>
	const result = Query(
	    From(Tag)->Select((t) => t.BufId == 1 && t.Line <= 6)
	)
	echo Table(result)
<
This query uses |librelalg.From()| to scan a relation and |librelalg.Select()|
to filter it. Output:
>
	───────────────────────────
	 TagName Column Line BufId
	───────────────────────────
	     zzz      1    2     1
	     xyz      1    4     1
	     lll      8    4     1
<
The result of a query is just a set of tuples (that is, a |list| of
homogeneous |dict|s), called a "derived" relation. Contrary to base relations,
derived relations do not have any associated keys, constraints or indexes.

If you want to get just the tag names and lines, you may use a projection:
>
	const filteredTags = Query(
	    From(Tag)
	    ->Select((t) => t.BufId == 1 && t.Line <= 6)
	    ->Project(['TagName', 'Line'])
	)
	echo Table(filteredTags)
<
This query also uses |librelalg.Project()|. Output:
>
	──────────────
	 TagName Line
	──────────────
	     zzz    2
	     xyz    4
	     lll    4
<
As another example, the natural join of `Buffer` and `Tag`, sorted by `BufId`
and tag name, can be written as follows:
>
	const btags = Query(
	    From(Buffer)
	    ->NatJoin(Tag)
	    ->SortBy(['BufId', 'TagName'])
	)
        echo Table(btags, 'Buffer tags')
<
This query uses |librelalg.NatJoin()| to perform the join,  and
|librelalg.SortBy()| to sort the result. Output:
>
	 Buffer tags
	───────────────────────────────────
	 Column TagName BufName Line BufId
	───────────────────────────────────
	     12     abc     foo    7     1
	      8     lll     foo    4     1
	      1     xyz     foo    4     1
	      1     zzz     foo    2     1
	     15     abc     bar   14     2
	      3     abc     xyz    6     3
<
==============================================================================
2. Data definition language			*librelalg-ddl*


Check({relobj}, {func} [, {opts}])		*librelalg.Check()*
		Define a generic constraint. The constraint is associated to
		base relation {relobj} and is defined by {func}, which is
		a |Funcref| taking as an input a tuple and returning |true| if
		the tuple satisfies the constraint, and |false| otherwise.

		A check constraint can be triggered before each insertion,
		update or deletion in {relobj}. The operations that should
		trigger the constraint check can be specified by {opts}, which
		is a |list| of one or more of `'I'`, `'U'`, and `'D'`, for
		insertion, update, and deletion, respectively. By default
		(when {opts} is not given), a constraint is checked before
		each insertion and update, but not upon deletion.

						*librelalg.ForeignKey()*
ForeignKey({relobj1}, {list1}, {relobj2}, {list2} [, {verb}])
		Define a referential integrity constraint from attributes
		{list1} in base relation {relobj1} to attributes {list2} in
		base relation {relobj2}.

		An optional string {verb} can be used to specify a verb
		phrase. This should be read from parent to child, that is,
		from {relobj2} to {relobj1}. The verb phrase is used in error
		messages when referential integrity is violated. See
		|librelalg-tutorial| for an example.

Key({relobj}, {key})				*librelalg.Key()*
		Define the |list| of attributes {key} to be a key of base
		relation {relobj}. Since multiple keys can be specified when
		a base relation is created (see |librelalg.Relation()|), in
		general using this function is not necessary. For example:
>
		var R = Relation('R', {A: Int, B: Str}, [['A'], ['B']])
<
		is equivalent to:
>
		var R = Relation('R', {A: Int, B: Str}, [['A']])
		Key(R, ['B'])
<
						*librelalg.Relation()*
Relation({name}, {schema}, {keys} [, {typecheck}])
		Define a base relation (aka “relation object”). A base
		relation has a descriptive {name} (a |string| used in error
		messages) and is defined over a {schema}, which is a |dict|
		mapping attributes to their corresponding data types. The
		supported data types are:

		- Int: integers
		- Str: strings
		- Float: floats
		- Bool: booleans

		{keys} is a |list| of keys, where each key is a |list| of
		attributes. Every base relation must have at least one key.

		Example: A relation object with schema:
>
		R(A: integer, B: string, C: integer)
<
		with a composite primary key A,B and an alternate key C can be
		defined in Vim 9 script as follows:
>
		var R = Relation('R', {
		    A: Int,
		    B: Str,
		    C: Int,
		  }, [['A', 'B'], ['C']])
<
		Only tuples conforming to the specified schema may be inserted
		into a base relation. By default, an error is raised if
		a tuple is not compatible with the relation schema. This type
		checking can be turned off by setting {typecheck} to |false|.
		Omitting type checking may slightly improve the performance
		when inserting or updating tuples, but it is not recommended,
		because the gain may be negligible, and type checking is
		useful to detect errors.

		The value returned by `Relation()`, which in this document is
		referred to as a “base relation” or as a “relation object”, is
		a complex object consisting of the relation instance itself
		(that is, the set of tuples of the relation) together with its
		schema, keys, constraints, and indexes. If you want to
		retrieve just the relation instance, you may access the
		`instance` attribute of the relation object (e.g.,
		`Tag.instance`).

==============================================================================
3. Data manipulation language			*librelalg-dml*

Note: you should never use Vim's functions (|add()|, |filter()|, etc.) to
insert, update, or delete from base relations, because the integrity of the
data may be compromised. Only the functions described in this section should
be used. Derived relations, however, can be manipulated with any function.

Delete({rel} [, {func}])			*librelalg.Delete()*
		Delete all the tuples of a base or derived relation {rel}
		satisfying predicate {func}, which is a function that takes as
		an input a tuple t and returns |true| if and only if t must be
		deleted. When {func} is not provided, all the tuples are
		deleted unconditionally.

Insert({rel}, {tuple})				*librelalg.Insert()*
		Insert a {tuple} into relation {rel}. Return the updated
		relation.

InsertMany({rel}, {list})			*librelalg.InsertMany()*
		Insert a {list} of tuples into relation {rel}.

Update({relobj}, {tuple} [, {upsert}])		*librelalg.Update()*
		Replace a tuple with a new {tuple} in base relation {relobj}.
		The tuple that is replaced is the one with the same key(s) as
		{tuple}. An error is raised if such a tuple does not exist in
		the base relation, unless {upsert} is |true|, in which case
		{tuple} is inserted into the relation and no error is raised.
		For instance:
>
		var R = Relation('R',
			  {A: Int, B: Str},
			  [['A']]
			)
		R->Insert({A: 1, B: 'v'})
		R->Update({A: 1, B: 'w'})  # OK
		R->Update({A: 2, B: 'z'})  # ERROR: no tuple with A == 2
		R->Update({A: 2, B: 'z'}, true)  # OK (Upsert)
<
		Note that the above semantics implies that only attributes
		that are not part of any key (the "descriptors" of the base
		relation) can be updated. To update a key attribute, remove
		the corresponding tuple and insert a new one.

		Note also that Update() cannot be used with derived relations.

==============================================================================
4. Relational Algebra				*librelalg-ra*

The following paragraphs provide a high-level description of the inner working
of the Relational Algebra operators as defined by this library. Such
understanding is not strictly necessary to be able to use the library; it may
help, however, to make the most out of it.

This section uses the following terminology:

- A "tuple" is a |dict| mapping attributes to values. Values can be strings,
  integers, booleans, or floats.
- A "relation" instance (or simply an “instance”) is a |list| of tuples.
- A "base relation" is an object built with |librelalg.Relation()|.
- A "derived relation" is a relation instance obtained as the result of
  a query.
- A "relation" is a base relation or a relation instance.
- A "consumer" is any function with signature func({tuple}): void.
- A "continuation" is any function with signature func({Consumer}): void.

Intuitively, a consumer is a function that operates in some way on a tuple,
typically by invoking a continuation. A continuation receives as an input
a consumer and applies it to one or more tuples.

This is best described with an example. Consider the following simple query:
>
	From(Relation)->Select(Pred)->Query()
<
|librelalg.From()| returns a continuation that looks like this:
>
	def Cont(Emit: func(Tuple): void): void
	  for t in relation
	    Emit(t)
	  endfor
	enddef
<
where `Emit()` is a consumer. The continuation `Cont` is passed to
|librelalg.Select()| together with a filter `Pred`. Select() builds and
returns another continuation, which look as follows:
>
	def Cont2(Emit: func(Tuple): void): void
	  def Consumer(t: Tuple)
	    if Pred(t)
	      Emit(t)
	    endif
	  enddef

	  Cont(Consumer)
	enddef
<
In practice, Select() defines a consumer to filter the tuples according to its
input predicate `Pred`, and then applies its input continuation `Cont` to that
consumer.

Finally, continuation `Cont2` is passed to |librelalg.Query()|, which defines
a consumer to materialize a relation,  by generating code similar to the
following:
>
	var rel: list<Tuple> = []

	def Consumer2(t: Tuple)
	  add(rel, t)
	enddef

	Cont2(Consumer2)
<
Again, what this operator does is define a consumer (`Consumer2`) and then it
applies a continuation (`Cont2`) to that consumer.

The original chained call:
>
	From(Relation)->Select(Pred)->Query()
<
can be re-written as follows:
>
	Query(Select(From(Relation), Pred))
<
Taking into account the foregoing discussion, if you try expanding the above,
you will realize that the result is equivalent to the following loop:
>
	var rel: list<Tuple> = []

	for t in Relation
	  if Pred(t)
	    add(rel, t)
	  endif
	endfor
<
which is pretty much what one would have written by hand (short of using
a built-in function such as |filternew()|, that is).

It should be clear at this point how Relatinal operators conceptually
transform relations into relations. Most operators fall into one of three
categories:

- "root" operators: these take as input a (base or derived) relation and emit
  tuples;
- "leaf" operators: these collect tuples and build a derived relation;
- "pipeline" operators: these process tuples and emit (transformed) tuples.

The most important rule is that each query should start (or end, if you use
the chaining notation `->`) with a leaf operator, such as |librelalg.Query()|
(other commonly used leaf operators are |librelalg.Sort()| and
|librelalg.SortBy()|, and there are others), which “materialize” a result.
Without a leaf operator, a query will just return a continuation—that is,
a function.

To simplify writing queries, most operators accept various types of arguments:
base relations (relation objects), relation instances (e.g., derived
relations), or continuations. The operators deal with their inputs
transparently, so the user should not typically worry about the above
categorization.

In the following, unless otherwise noted, {rel}, {rel1}, {rel2} always denote
a base relation, a relation instance, or a continuation: any of these three
data types can be used as {rel}, {rel1}, or {rel2}. This allows the user
combining the operators in a natural fashion.

Note: binary operators materialize their second argument {rel2}—that is, they
build a temporary instance from {rel2} (unless {rel2} is already a relation,
of course). It may be worth knowing that, in order to avoid writing queries
that unnecessarily create temporary objects.

Note: some of the examples in the rest of this section are based on the sample
database discussed in |librelalg-tutorial|.

AvgBy({rel}, {list}, {attr} [, {name}])		*librelalg.AvgBy()*
		Group the tuples of relation {rel} with respect to a {list} of
		attributes, and determine the average of the values of
		attribute {attr} in each group. The schema of the output
		relation consists of the grouping attributes plus the
		aggregate attribute. The name of the latter may be specified
		by {name} (the default name is "avg").

		For instance:
>
		var r = [
		    {A: 1, B: 6},
		    {A: 1, B: 4},
		    {A: 2, B: 3}
		]
		const result = From(r)->AvgBy(['A'], 'B')
		echo Table(result)
<
		Output:
>
		───────
		 A avg
		───────
		 1 5.0
		 2 3.0
<
		This is a leaf operator, returning a relation instance.

AntiJoin({rel1}, {rel2}, {func})		*librelalg.AntiJoin()*
		Perform the anti-join of {rel1} and {rel2}. The join condition
		is specified by {func}, which is defined as in
		|librelalg.Join()|. The result is the set of tuples of {rel1}
		that cannot be joined with any tuple in {rel2}.

		For instance, to obtain the buffers that have no tags before
		line 10:
>
		const result = Query(
		    AntiJoin(
		      Buffer,
		      Select(Tag, (t) => t.Line < 10),
		      (t, u) => t.BufId == u.BufId
		    )
		  )
		echo Table(result)
<
		Output:
>
		───────────────
		 BufName BufId
		───────────────
		     bar     2
<
		This is a pipeline operator, returning a continuation.

Build({rel})					*librelalg.Build()*
		A synonym of |librelalg.Query()|.

CoddDivide({rel1}, {rel2}[, {hint}])		*librelalg.CoddDivide()*
		Divide a relation {rel1} by another relation {rel2}. This is
		Relational division as originally defined by Codd, which
		requires the schema of the divisor to be a subset of the
		schema of the dividend—that is, R(X) ÷ S(Y) is defined only if
		Y ⊆ X.

		This operator builds the maximal¹ relation instance Q on
		X such that each tuple in Q joined with any tuple of
		S produces a tuple in R.

		¹Maximality here is relative to the values of the input. More
		precisely, the output is always a subset of π_X(R), the
		projection of R on X.

		For example, to obtain the names of the tags that appear in
		every buffer:
>
		const result = Query(
		    Project(Tag, ['BufId', 'TagName'])
		    ->CoddDivide(Project(Buffer, ['BufId']))
		)
		echo Table(result)
<
		Output:
>
		─────────
		 TagName
		─────────
		     abc
<
		If the divisor is an empty derived relation, then it does not
		carry any explicit information about its schema, because it is
		just an empty |list|. Hence, it is not possible to infer the
		schema of the quotient relation automatically. In this case,
		a |list| of attributes {hint} may be used to specify the
		attributes of the divisor. For instance:
>
		const result = Query(Buffer->CoddDivide([], ['BufId']))
<
		Output:
>
		 BufName
		─────────
		     foo
		     bar
		     xyz
<
		Note that {hint} is ignored if the divisor is not empty or it
		is a base relation (because a base relation has an associated
		schema).

		This is a pipeline operator, returning a continuation. See
		also |Divide()|.

CountBy({rel}, {list}[, {attr}, {name}])	*librelalg.CountBy()*
		Group the tuples of a relation {rel} with respect to a {list}
		of attributes, and count the number of tuples in each group.
		If {attr} is given and is not |null_string|, then count the
		number of distinct values of attribute {attr} in each group.
		The schema of the output relation consists of the grouping
		attributes plus the aggregate attribute. The name of the
		latter may be specified by {name} (the default name is
		"count").

		For instance:
>
		var r = [
		    {A: 1, B: 6},
		    {A: 1, B: 4},
		    {A: 2, B: 6},
		    {A: 1, B: 6}]
		const result1 = From(r)->CountBy(['A'])
		const result2 = From(r)->CountBy(['A'], 'B')
		echo Table(result1, 'Count by A')
		echo Table(result2, 'Count distinct B')
<
		Output:
>
		 Count by A
		────────────
		    A count
		────────────
		    1     3
		    2     1

		 Count distinct B
		──────────────────
		          A count
		──────────────────
		          1     2
		          2     1
<
		This is a leaf operator, returning a relation instance.

Divide({rel1}, {rel2})				*librelalg.Divide()*
		Divide a relation {rel1} by another relation {rel2}. This is
		a form of generalized Relational division, with no restriction
		on the schemas of the operands. Consider two relations R(X,Y)
		and S(Y,Z), where Y is the subset of attributes in common
		between R and S, and X and Z are disjoint sets of attributes
		(any of these subsets may be empty). Then, R ÷ S = Q(X,Z) is
		the maximal¹ relation instance on (X,Z) such that each tuple
		(x,z) in Q, when joined with any tuple of S and projected on
		(X,Y) gives a tuple in R. In other words, Q consists of the
		tuples (x,z) such that a tuple (x,y) exists in R for every
		tuple (y,z) in S.

		¹Maximality here is relative to the values of the input. More
		precisely, the output is always a subset of π_X(R) ⨯ π_Z(S),
		the cross-product of the projection of R on X and the
		projection of S on Z.

		Consider the following example:
>
		const SP = [  # Supplier S# supplies part P#
		  {'S#': 1, 'P#': 10},
		  {'S#': 1, 'P#': 20},
		  {'S#': 1, 'P#': 30},
		  {'S#': 2, 'P#': 10},
		  {'S#': 2, 'P#': 20},
		  {'S#': 3, 'P#': 20},
		  {'S#': 3, 'P#': 40},
		]
		const PJ = [  # Part P# is used in project J#
		  {'P#': 10, 'J#': 100},
		  {'P#': 20, 'J#': 100},
		  {'P#': 20, 'J#': 200},
		  {'P#': 30, 'J#': 200},
		  {'P#': 20, 'J#': 300},
		  {'P#': 40, 'J#': 300},
		]
<
		Then SP ÷ PJ and PJ ÷ SP are computed as follows:
>
		const sp_div_pj = Query(Divide(SP, PJ))
		const pj_div_sp = Query(Divide(PJ, SP))
		echo Table(sp_div_pj, 'SP ÷ PJ')
		echo Table(pj_div_sp, 'PJ ÷ SP')
<
		Output:
>
		 SP ÷ PJ
		─────────
		  S#  J#
		─────────
		   1 100
		   1 200
		   2 100
		   3 300

		 PJ ÷ SP
		─────────
		  S#  J#
		─────────
		   2 100
		   3 300
<
		The first query finds the pairs (S#,J#) such that supplier S#
		supplies all the parts used in project J#; the second query
		finds all the pairs (S#,J#) such that project J# uses all the
		parts supplied by supplier S#.

		A special case is when the schema of the divisor S(Y,Z) is
		a subset of the schema of the dividend R(X,Y)—that is, when
		Z is empty. Then, this operation reduces to |CoddDivide()|
		(although the latter is in general computed more efficiently),
		except for the special case of an empty divisor. If the
		divisor is empty, then |Divide()| always returns an empty
		relation, while |CoddDivide()| always returns π_X(R), the
		projection of the dividend on X.

						*librelalg.EquiJoin()*
EquiJoin({rel1}, {rel2}, {list1}, {list2}, [, {prefix}])
		Perform an equi-join between two relations {rel1} and {rel2}.

		The |list| {list1} is a subset of the attributes of {rel1}.
		{list2} is a matching |list| of attributes in {rel2}. The two
		lists must have the same length. Attributes at the same
		position in the two lists are compared with equality.

		For {prefix}, see |librelalg.Join()|.

		Example:
>
		const result = Query(
		    EquiJoin(Buffer, Tag, ['BufId'], ['BufId'], 't_')
		  )
		echo Table(result)
<
		Output:
>
		─────────────────────────────────────────────
		 TagName Column Line t_BufId BufId t_BufName
		─────────────────────────────────────────────
		     zzz      1    2       1     1       foo
		     abc     12    7       1     1       foo
		     xyz      1    4       1     1       foo
		     lll      8    4       1     1       foo
		     abc     15   14       2     2       bar
		     abc      3    6       3     3       xyz
<
		See |librelalg.Join()| for an equivalent formulation of the
		previous example.

		This is a pipeline operator, returning a continuation.

Extend({rel}, {func})				*librelalg.Extend()*
	Extend each tuple of relation {rel} with a tuple computed by {func}.
	{func} receives a tuple and returns another tuple, which must not have
	any attribute in common with the input tuple. For example:
>
	var r = [{A: 1}, {A: 3}, {A: 5}]

	const result = Query(
	    Extend(r, (t): dict<any> => {
	       return {B: t.A * 2}
	    }))
	echo Table(result)
<
	The output is:
>
	──────
	 A  B
	──────
	 1  2
	 3  6
	 5 10
<
	Note that {func} should consistently return tuples over the same,
	fixed, schema, if the result has to be a valid relation instance.

	This is a pipeline operator, returning a continuation.

Filter({rel}, {func})				*librelalg.Filter()*
		Filter a relation using predicate {func}. Only the tuples for
		which {func} returns |true| are selected. This is similar to
		|librelalg.Select()|, but potentially faster, as it is
		essentially a thin wrapper around |filter()|.

		This is a leaf operator, returning a relation instance.

Foreach({rel})					*librelalg.Foreach()*
		A synonym of |librelalg.From()|.

Frame({rel}, {list}[, {name}])			*librelalg.Frame()*
		Virtually partition a relation {rel} based on a {list} of
		attributes, extend the relation with a new attribute and,
		within this attribute, assign a distinct integer value to each
		distinct member of the partition. The standard name of the
		added attribute is "fid", but a different value can be set
		with {name}. For instance:
>
		var r = [
		    {A: 10, B: 'a', C: 'x'},
		    {A: 20, B: 'b', C: 'y'},
		    {A: 30, B: 'a', C: 'x'},
		    {A: 40, B: 'a', C: 'x'},
		    {A: 50, B: 'b', C: 'x'},
		    {A: 60, B: 'b', C: 'y'},
		    {A: 70, B: 'a', C: 'y'},
		  ]
		const result = Query(From(r)->Frame(['B', 'C']))
		echo Table(result)
<
		Output:
>
		────────────
		  A B C fid
		────────────
		 10 a x   0
		 20 b y   1
		 30 a x   0
		 40 a x   0
		 50 b x   2
		 60 b y   1
		 70 a y   3
<
		This is a pipeline operator, returning a continuation.

From({rel})					*librelalg.From()*
		Return a continuation that iterates over the tuples of
		a relation {rel} and emits each tuple. If {rel} is already
		a continuation, then this function just returns it. This is
		a root operator, that is, an operator that starts a query.

GroupBy({rel}, {list}, {func} [, {string}])	*librelalg.GroupBy()*
		Group the tuples of a relation {rel} with respect to a {list}
		of attributes, and apply an aggregate function {func} to each
		group. The schema of the output relation consists of the
		grouping attributes and the aggregate attribute. The name of
		the aggregate attribute is given by {string}.

		For instance, to count the number of tags in each buffer with
		at least one tag:
>
		const result = Query(
		    GroupBy(Tag, ['BufId'], Count, 'num_tags')
		  )
		echo Table(result)
<
		Output:
>
		────────────────
		 num_tags BufId
		────────────────
		        4     1
		        1     2
		        1     3
<
		|librelalg.Count()| is an aggregate function. To learn about
		aggregate functions, see |librelalg-aggr|.

		For the most common aggregate functions, specialized operators
		exist, which are generally preferrable over GroupBy(): see
		|librelalg.AvgBy()|, |librelalg.CountBy()|,
		|librelalg.MaxBy()|, |librelalg.MinBy()|, |librelalg.SumBy()|.

		This is a pipeline operator, returning a continuation.

Intersect({rel1}, {rel2})			*librelalg.Intersect()*
		Intersect two relations. Note: the relations must be defined
		on the same schema!

		For instance:
>
		var r = [
		  {A: 1, B: 'x'},
		  {A: 3, B: 'y'},
		  {A: 5, B: 'y'},
		]
		var s = [
		  {A: 3, B: 'y'},
		  {A: 6, B: 'y'},
		]
		const result = Query(Intersect(r, s))
		echo Table(result)
<
		The output is:
>
		─────
		 A B
		─────
		 3 y
<
		This is a pipeline operator, returning a continuation.

Join({rel1}, {rel2}, {func} [, {prefix}])	*librelalg.Join()*
		Join two relations {rel1} and {rel2}. The join condition is
		specified by {func}, which is a |Funcref| that takes as an
		input two tuples t1 and t2 and returns |true| if and only if
		t1 and t2 should be joined.

		{prefix} is a string that is added to each attribute name of
		{rel1} in the output relation. The prefix is mandatory if the
		relations to be joined have some attributes in common, because
		the attributes in a relation must be all distinct. The prefix
		must not be used inside {func}.

		For example, to join `Buffer` with `Tag` on the common `BufId`
		attribute:
>
		const result = Query(
		    Join(Buffer, Tag, (t, u) => t.BufId == u.BufId, 't_')
		  )
		echo Table(result)
<
		Output:
>
		─────────────────────────────────────────────
		 TagName Column Line t_BufId BufId t_BufName
		─────────────────────────────────────────────
		     zzz      1    2       1     1       foo
		     abc     12    7       1     1       foo
		     xyz      1    4       1     1       foo
		     lll      8    4       1     1       foo
		     abc     15   14       2     2       bar
		     abc      3    6       3     3       xyz
<
		Failing to add a prefix in the query above will result in an
		error:
>
		Key already exists: BufId
<
		because the attribute `BufId` exists both in `Buffer` and in
		`Tag`.

		This is a pipeline operator, returning a continuation.

LeftNatJoin({rel1}, {rel2}, {filler})		*librelalg.LeftNatJoin()*
		Perform the left natural join of two relations {rel1} and
		{rel2}. {filler} is an arbitrary relation defined on the
		attributes of {rel} minus the join attributes. The result is
		the union of the natural join between the input relations and
		the cross-product of {filler} with the set of tuples in {rel1}
		that do not match any tuple in {rel2}.

		For instance:
>
		var r = [
		    {A: 1, B: 'x'},
		    {A: 2, B: 'x'},
		    {A: 3, B: 'y'},
		    {A: 4, B: 'z'},
		]
		var s = [
		    {B: 'x', C: 10},
		    {B: 'z', C: 20},
		    {B: 'z', C: 30},
		]

		const result = Query(LeftNatJoin(r, s, [{C: -1}]))
		echo Table(result)
<
		Output:
>
		────────
		 A B  C
		────────
		 1 x 10
		 2 x 10
		 3 y -1
		 4 z 20
		 4 z 30
<
		This is a pipeline operator, returning a continuation.

LimitScan({rel}, {n})				*librelalg.LimitScan()*
		Like |librelalg.From()|, but emit at most {n} tuples. For
		instance:
>
		var r = [{A: 10}, {A: 20}, {A: 30}, {A: 40}]
		const result = Query(LimitScan(r, 2))
		echo Table(result)
<
		Output:
>
	  	────
	  	  A
	  	────
	  	 10
	  	 20
<
		Note that, in general, the order of the tuples in a relation
		is arbitrary.

MaxBy({rel}, {list}, {attr} [, {name}])		*librelalg.MaxBy()*
		Group the tuples of a relation {rel} with respect to a {list}
		of attributes, and determine the maximum value of attribute
		{attr} in each group. The schema of the output relation
		consists of the grouping attributes plus the aggregate
		attribute. The name of the latter may be specified by {name}
		(the default name is "max").

		For instance:
>
		var r = [
		    {A: 1, B: 6},
		    {A: 1, B: 4},
		    {A: 2, B: 3}
		]
		const result = From(r)->MaxBy(['A'], 'B')
		echo Table(result)
<
		Output:
>
		───────
		 A max
		───────
		 1   6
		 2   3
<
		This is a leaf operator, returning a relation instance.

MinBy({rel}, {list}, {attr} [, {name}])		*librelalg.MinBy()*
		Group the tuples of a relation {rel} with respect to a {list}
		of attributes, and determine the minimum value of attribute
		{attr} in each group. The schema of the output relation
		consists of the grouping attributes plus the aggregate
		attribute. The name of the latter may be specified by {name}
		(the default name is "min").

		For instance:
>
		var r = [
		    {A: 1, B: 6},
		    {A: 1, B: 4},
		    {A: 2, B: 3}
		]
		const result = From(r)->MinBy(['A'], 'B')
		echo Table(result)
<
		Output:
>
		───────
		 min A
		───────
		   4 1
		   3 2
<
		This is a leaf operator, returning a continuation.

Minus({rel1}, {rel2})				*librelalg.Minus()*
		Subtract relation {rel2} from relation {rel1}. Note: the
		relations must be defined on the same schema!

		For instance:
>
		var r = [
		  {A: 1, B: 'x'},
		  {A: 3, B: 'y'},
		  {A: 5, B: 'y'},
		]
		var s = [
		  {A: 3, B: 'y'},
		  {A: 6, B: 'y'},
		]
		const result = Query(Minus(r, s))
		echo Table(result)
<
		The output is:
>
		─────
		 A B
		─────
		 1 x
		 5 y
<
		This is a pipeline operator, returning a continuation.

NatJoin({rel1}, {rel2})				*librelalg.NatJoin()*
		Perform the natural join of two relations {rel1} and {rel2}.
		For instance:
>
		const result = Query(NatJoin(Buffer, Tag))
		echo Table(result)
<
		Output:
>
		───────────────────────────────────
		 Column TagName BufName Line BufId
		───────────────────────────────────
		      1     zzz     foo    2     1
		     12     abc     foo    7     1
		      1     xyz     foo    4     1
		      8     lll     foo    4     1
		     15     abc     bar   14     2
		      3     abc     xyz    6     3
<
		This is a pipeline operator, returning a continuation.

Query({rel})					*librelalg.Query()*
		Materialize a relation {rel}. If {rel} is a continuation,
		build a new instance by consuming the tuples emitted by the
		continuation. If {rel} is already a (base or derived)
		relation, return the relation instance directly.

		This is a leaf operator, always returning a relation instance.

Rename({rel}, {list1}, {list2})			*librelalg.Rename()*
		Rename the attributes of a relation {rel}. {list1} is a list
		of attributes to rename. {list2} is the corresponding list of
		new attribute names.

		Example:
>
		var r = [
		    {A: 1, B: 'u'},
		    {A: 2, B: 'v'}
		]
		var s = Query(Rename(r, ['A', 'B'], ['X', 'Y']))
		echo Table(s)
<
		The output is:
>
		─────
		 X Y
		─────
		 1 u
		 2 v
<
		Only the schema of the relation (that is, the header of the
		table) is changed: the instance remains the same.

		This is a pipeline operator, returning a continuation.

Product({rel1}, {rel2} [, {prefix}])		*librelalg.Product()*
		Perform the cross product of two relations {rel1} and {rel2}.
		For {prefix}, see |librelalg.Join()|.

		For example, to obtain all the sorted pairs of tag names:
>
		const Tagname = Project(Tag, ['TagName'])
		const result  = Query(
		    Product(Tagname, Tagname, 't_')
		    ->Select((t) => t.TagName < t.t_TagName)
		    ->SortBy(['TagName', 't_TagName'])
		)
		echo Table(result)
<
		Output:
>
		 ───────────────────
		 TagName t_TagName
		───────────────────
		     abc       lll
		     abc       xyz
		     abc       zzz
		     lll       xyz
		     lll       zzz
		     xyz       zzz
<
		This is a pipeline operator, returning a continuation.

Project({rel}, {list})				*librelalg.Project()*
		Perform a projection of a relation {rel} on a {list} of
		attributes. For instance:
>
		const result = Query(Project(Tag, ['TagName']))
		echo Table(result)
<
		Output:
>
		 TagName
		─────────
		     zzz
		     abc
		     xyz
		     lll
<
		This is a pipeline operator, returning a continuation.

Scan({rel})					*librelalg.Scan()*
		A synonym of |librelalg.From()|.

Select({rel}, {func})				*librelalg.Select()*
		Filter the tuples of a relation {rel} based on a predicate.
		The predicate is defined by {func}, which is a |Funcref| that
		takes as an input a tuple t and returns |true| if and only if
		t must be selected.

		For instance, to select all the tags after line 3 in buffer 1:
>
		const result = Query(
		    Select(Tag, (t) => t.BufId == 1 && t.Line > 3)
		  )
		echo Table(result)
<
		Output:
>
		───────────────────────────
		 TagName Column Line BufId
		───────────────────────────
		     abc     12    7     1
		     xyz      1    4     1
		     lll      8    4     1
<
		This is a pipeline operator, returning a continuation. See
		also |librelalg.Lookup()|.

SemiJoin({rel1}, {rel2}, {func})		*librelalg.SemiJoin()*
		Perform the semi-join of two relations {rel1} and {rel2}. This
		is the same as joining {rel1} with {rel2} (see
		|librelalg.Join()|), then projecting the result on the
		attributes of {rel1}.

		For instance, to obtain the buffers that have some tag beyond
		column 10:
>
		const result = Query(
		      SemiJoin(Buffer, Tag,
			(t, u) => t.BufId == u.BufId && u.Column > 10)
		  )
		echo Table(result)
<
		Output:
>
		───────────────
		 BufName BufId
		───────────────
		     foo     1
		     bar     2
<
		This is a pipeline operator, returning a continuation.

Sort({rel}, {func})				*librelalg.Sort()*
		Materialize a relation by sorting its tuples according to the
		criterion specified by {func}. The sorting predicate {func} is
		a |Funcref| that takes as an input two tuples t1 and t2, and
		returns -1, 0, or 1 depending on whether t1 precedes t2, t1
		equals t2 or t1 follows t2, respectively. For instance, to
		sort tags by line number (regardless of the buffers):
>
		def Compare(t1: dict<any>, t2: dict<any>): number
		   return t1.Line < t2.Line ? -1 : t1.Line > t2.Line ? 1 : 0
		enddef

		const result = From(Tag)->Sort(Compare)
<
		Output:
>
		───────────────────────────
		 TagName Column Line BufId
		───────────────────────────
		     zzz      1    2     1
		     xyz      1    4     1
		     lll      8    4     1
		     abc      3    6     3
		     abc     12    7     1
		     abc     15   14     2
<
		See |librelalg.SortBy()| for an equivalent, but simpler,
		formulation of this query.

		This is a leaf operator, returning a relation instance. See
		also |librelalg.SortBy()|.

SortBy({rel}, {list} [, {opts}])		*librelalg.SortBy()*
		Materialize a relation {rel} by sorting the tuples according
		the specified {list} of attributes. For instance:
>
		const result = From(Tag)->SortBy(['Line'])
<
		This gives the same result as the example in
		|librelalg.Sort()|.

		{opts} is a list that specifies, for each sorting attribute,
		whether to sort the values of that attribute in increasing or
		decreasing order. For instance:
>
		const result = From(Tag)
		               ->SortBy(['TagName', 'Column'], ['i', 'd'])
		echo Table(result)
<
		Output:
>
		 TagName Column Line BufId
		───────────────────────────
		     abc     15   14     2
		     abc     12    7     1
		     abc      3    6     3
		     lll      8    4     1
		     xyz      1    4     1
		     zzz      1    2     1
<
		The tuples of `Tag` are sorted in increasing order (`'i'`)
		with respect to `TagName`, and then the tags with the same
		value are sorted in decreasing order (`'d'`) with respect to
		`Column`.

		This is a leaf operator, returning a relation instance. See
		also |librelalg.Sort()|.

SumBy({rel}, {list}, {attr} [, {name}])		*librelalg.SumBy()*
		Group the tuples of a relation {rel} with respect to a {list}
		of attributes, and sum the values of attribute {attr} in each
		group. The schema of the output relation consists of the
		grouping attributes plus the aggregate attribute. The name of
		the latter may be specified by {name} (the default name is
		"sum").

		For instance:
>
		var r = [
		    {A: 1, B: 6},
		    {A: 1, B: 4},
		    {A: 2, B: 3}
		]
		const result = From(r)->SumBy(['A'], 'B')
		echo Table(result)
<
		Output:
>
		───────
		 A sum
		───────
		 1  10
		 2   3
<
		This is a leaf operator, returning a relation instance.

Union({rel1}, {rel2})				*librelalg.Union()*
		Return the union of two relations {rel1} and {rel2}. Note: the
		relations must be defined on the same schema!

		For instance:
>
		var r = [
		    {A: 1, B: 'x'},
		    {A: 3, B: 'y'},
		    {A: 5, B: 'y'}
		]
		var s = [
		    {A: 3, B: 'y'},
		    {A: 6, B: 'y'},
		    {A: 1, B: 'x'},
		]
		const result = Query(Union(r, s))
		echo Table(result)
<
		The output is:
>
		─────
		 A B
		─────
		 1 x
		 3 y
		 5 y
		 6 y
<
		This is a leaf operator, returning a relation instance.

==============================================================================
5. Aggregate functions				*librelalg-aggr*

An aggregate function is a special type of leaf operator: instead of returning
a relation instance, an aggregate function returns a scalar. These functions
can be used as normal operators or as an argument to |librelalg.GroupBy()|
(see also |librelalg.Bind()|), although computing group-by aggregates can be
done more efficiently with the following specialized operators:

- |librelalg.AvgBy()|,
- |librelalg.CountBy()|,
- |librelalg.MinBy()|,
- |librelalg.MaxBy()|,
- |librelalg.SumBy()|.

Avg({rel}, {attr})				*librelalg.Avg()*
		Return the average value of attribute {attr} in a relation
		{rel}. For instance, to return the average tag's column
		number:
>
		const avg = From(Tag)->Avg('Column')  # 6.666667
<
Count({rel})					*librelalg.Count()*
		Return the number of tuples of a relation {rel}. For instance,
		to return the number of buffers:
>
		const nBuf = From(Buffer)->Count()  # 3
<
CountDistinct({rel}, {attr})			*librelalg.CountDistinct()*
		Return the number of distinct values in attribute {attr} of
		a relation {rel}. For instance, to return the number of
		distinct tag names:
>
		const nDistinctTags = From(Tag)->CountDistinct('TagName')  # 4
<
Min({rel}, {attr})				*librelalg.Min()*
		Return the minimum value of attribute {attr} in a relation
		{rel}. For instance, to return the minimum buffer id:
>
		const minBufId = From(Buffer)->Min('BufId')  # 1
<
Max({rel}, {attr})				*librelalg.Max()*
		Return the maximum value of attribute {attr} in a relation
		{rel}. For instance, to return the maximum column of a tag:
>
		const maxCol = From(Tag)->Max('Column')  # 15
<
Sum({rel}, {attr})				*librelalg.Sum()*
		Return the sum of the values of attribute {attr} in a relation
		{rel}. For instance:
>
		const colSum = From(Tag)->Sum('Column')  # 40
<
==============================================================================
6. Other functions				*librelalg-other*

Attributes({relobj})				*librelalg.Attributes()*
		Return the list of attributes of relation object {relobj}.

Bind({func}, {attr})				*librelalg.Bind()*
		Bind the attribute argument {attr} of an aggregate function
		{func}. This makes it more convenient to pass to
		|librelalg.GroupBy()| an aggregate function that takes an
		attribute as a second argument. For example:
>
		# Number of distinct lines containing a tag, in each buffer
		const result = Query(
		           From(Tag)
		           ->GroupBy(['BufId'],
		                     Bind(CountDistinct, 'Line'), 'nLines')
		)
		echo Table(result)
<
		Output:
>
		──────────────
		 nLines BufId
		──────────────
		      3     1
		      1     2
		      1     3
<
Descriptors({relobj})				*librelalg.Descriptors()*
		Return the list of descriptors of relation object {relobj}.
		A descriptor is an attribute that is not part of any key.

EquiJoinPred({list1}, {list2})			*librelalg.EquiJoinPred()*
		Return a predicate comparing the attributes in {list1} and the
		attributes in {list2} for equality elementwise. The returned
		function can be used as an argument to the various join
		operators. For example, to find the tag names that are also
		buffer names:
>
		const Pred = EquiJoinPred(['BufName'], ['TagName'])
		const result = Query(SemiJoin(Buffer, Tag, Pred))
<
		This will join on the condition:
>
		Buffer.BufName == Tag.TagName
<
		Output:
>
		───────────────
		 BufName BufId
		───────────────
		     xyz     3
<
Empty({rel})					*librelalg.Empty()*
		Return |true| if {rel} is an empty base or derived relation;
		return |false| otherwise.

In({tuple}, {rel})				*librelalg.In()*
		Return |true| if {tuple} is in base or derived relation {rel},
		otherwise return |false|.

KeyAttributes({relobj})				*librelalg.KeyAttributes()*
		Return the list of key attributes of relation object {relobj}.
		A key attribute is an attribute that is part of a key.

Lookup({relobj}, {key}, {list})			*librelalg.Lookup()*
		Search for a tuple in relation object {relobj} whose {key}
		matches the value specified by the |list| of values {list}. An
		empty |dict| is returned if no tuple with the given value of
		the key can be found.

		For example:
>
		var R = Relation('R', {A: Int, B: Str}, [['A']])
			->InsertMany([
			  {A: 1, B: 'x'},
			  {A: 3, B: 'y'},
			  {A: 5, B: 'z'}
			])
		echo Lookup(R, ['A'], [3])  # {A: 3, B: 'y'}
<
		When looking up for a tuple by key, using this function is
		generally faster than using |librelalg.Select()|, because
		lookup access uses an index associated to the key, whereas
		|librelalg.Select()| does a linear scan of the relation.

		Note that the returned value is a tuple, not a relation
		instance!

NotIn({tuple}, {rel})				*librelalg.NotIn()*
		Return |true| if {tuple} is not in base or derived relation
		{rel}, otherwise return |false|.

RelEq({rel1}, {rel2})				*librelalg.RelEq()*
		Compare two base or derived relations for equality. Return
		|true| if the relations are equal, that is, the are the same
		set of tuples; return |false| otherwise.

Table({rel} [, {name}, {sep})			*librelalg.Table()*
		Return a tabular representation of a base or derived relation
		as a |string|. The title of the table may be specified with
		{name} (the default is to use the relation name for base
		relations, and no title for derived relations). The horizontal
		separator symbol can be set with {sep}, which must be a single
		character.

		For instance:
>
		echo Table([
		  {X: 10, Y: 'ten'},
		  {X: 20, Y: 'twenty'},
		], 'A table', '~')
<
		Output:
>
		 A table
		~~~~~~~~~~~
		  X      Y
		~~~~~~~~~~~
		 10    ten
		 20 twenty
<
Zip({list1}, {list2})				*librelalg.Zip()*
		Build a tuple by “zipping” the attributes in {list1} with the
		values in {list2}. For example:
>
		const t = Zip(['A', 'B'], [7, 'v'])
		echo t
<
		outputs:
>
		{A: 7, B: 'v'}
<
==============================================================================
7. Tips and tricks				*librelalg-tips*

Base relations must be updated only through librelalg's operators, because
that is the only way integrity constraints can be verified.
Derived relations, however, are just lists of dictionaties, and can be further
processed in any way. For instance:
>
	var R = Relation('R', {A: Int, B: Int}, [['A']])

	# […]

	const S = Filter(R, (t) => t.A > 0)    # OK
	filter(R.instance, (_, t) => t.A > 0)  # BAD! R is a base relation

	var s = Scan(R)->Project(['A'])->Build()
	Filter(s, (t) => t.A > 0)     # OK
	filter(s, (_, t) => t.A > 0)  # Also OK: s is a derived instance
<
Keys ~

An index is built for each key. The indexes help speed up some operations and
are used to enforce key constraints. The order of the attributes in a compound
key matters for performance. In the example above, if tags are often looked up
by name, it may be more efficient to define the primary key as `['TagName',
'BufId', 'Line']` rather than `['BufId',` `'TagName', 'Line']` as was done
above. In general, the attributes that are accessed more frequently should
appear earlier in the key.

Nulls ~

Nulls are not supported. A properly designed database never needs nulls, so
this is not a loss of generality, and it is a great gain in simplicity and
semantic clarity.

 vim:tw=78:ts=8:noet:ft=help:norl:
