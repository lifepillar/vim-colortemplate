*librelalg.txt*	For Vim version 9.0	Last change: 2023 Jan 25

This library is an implementation of Relational Algebra in Vim 9 script.

Note: Vim 9.0.1240 or later is required.

0. Quick start				|librelalg-quickstart|
1. Tutorial				|librelalg-tutorial|
2. Data definition language		|librelalg-ddl|
3. Relational Algebra			|librelalg-ra|
4. Aggregate functions			|librelalg-aggr|
5. Other functions			|librelalg-other|

==============================================================================
0. Quick start					*librelalg-quickstart*

A relation instance (or, simply, a relation) is just a list of homogeneous
dictionaries, such as this:
>
	var r = [{A: 1, B: 'bbb'},
	         {A: 2, B: 'aaa'},
	         {A: 3, B: 'bbb'}]
<
Each dictionary is called a "tuple". Each dictionary key is called an
"attribute". A relation must not contain any duplicate tuples.

Relational Algebra operators transform relations into other relations. For
example:
>
	vim9script
	import 'librelalg.vim' as ra

	var r = [{A: 1, B: 'bbb'},
	         {A: 2, B: 'aaa'},
	         {A: 3, B: 'bbb'}]

	const result = ra.Query( ra.Select(r, (t) => t.B == 'bbb') )
	echo result
	echo ra.Table(result)
<
Output:
>
	[{'A': 1, 'B': 'bbb'}, {'A': 3, 'B': 'bbb'}]

	───────
	 A   B
	───────
	 1 bbb
	 3 bbb
<
So, at the basic level you may perform Relational queries on Vim's data
structures. See |librelalg-ra| to learn about the available operators.

But librelalg also offers support for data definition and data manipulation
with built-in integrity. For that, start by defining a Relational schema:
>
	vim9script

	import "librelalg.vim" as ra

	const Int   = ra.Int
	const Str   = ra.Str
	const Float = ra.Float

	#                   Name  Schema               Keys
	var R = ra.Rel.new('R',   {A: Int, B: Float},  'A')
	var S = ra.Rel.new('S',   {X: Str, Y: Int},    'X')

	R.Check((t) => {
	  if t.B <= 0.0
	   throw printf('B must be greater than zero: got %s', t.B)
	  endif
	})

	ra.ForeignKey(S, 'references', R, 'Y', 'A')  # FK: S[Y] -> R[A]
<
Populate the database:
>
	R.InsertMany([
	  {A: 10, B: 3.2},
	  {A: 20, B: 0.6},
	])

	S.InsertMany([
	  {X: 'xyz', Y: 10},
	  {X: 'abc', Y: 20},
	  {X: 'klm', Y: 10},
	])
<
Query the database:
>
	# Find all X that are related to a tuple in R with B > 1.5,
	# sorted lexicographically:

	var rel = ra.Query(
	    ra.EquiJoin(S, R, ['Y'], ['A'])
	    ->ra.Select((t) => t.B > 1.5)
	    ->ra.Project('X')
	    ->ra.SortBy('X')
	)
	echo ra.Table(rel)
<
Output:
>
	─────
	   X
	─────
	 klm
	 xyz
<
Update the database:
>
	R.Insert({A: 30, B: 4.3})
	S.Update({X: 'klm', Y: 30})
	S.Delete((t) => t.Y == 10)
	rel = ra.Query(ra.EquiJoin(R, S, ['A'], ['Y']))
	echo ra.Table(rel)
<
Output:
>
	───────────────
	  A   B   X  Y
	───────────────
	 20 0.6 abc 20
	 30 4.3 klm 30
<
==============================================================================
1. Tutorial					*librelalg-tutorial*

Suppose that you want to write a script that keeps track of some "tags"
associated to each buffer. Since data is king, a good place to start is by
defining a (Relational) data model for your script. Suppose that, after
carefully evaluating your requirements, your model looks like this (using
standard IDEF1X notation):
>
	 Buffer
	┌───────────────┐
	│ BufId     Int │
	├───────────────┤
	│ BufName   Str │ AK
	└───────┬───────┘
	        │
	  is tagged by /
	    appears in
	        │
	 Tag    ●
	╭───────────────╮
	│ BufId     Str │ FK
	│ TagName   Str │
	├───────────────┤
	│ Line      Int │ (1)
	│ Column    Int │ (1)
	╰───────────────╯
	(1) Lines and columns must be greater than zero.
<
If you are not familiar with IDEF1X or similar diagramming tools, each box
represents an "entity" (your script will deal with "buffers" and "tags", so
there are two entities in this model). Each entity has a name, written above
its box, and attributes, which are written inside the box. The attributes will
be the actual pieces of data stored and manipulated by your script. Each box
also contains a separator line: the attributes above the separator form the
"primary key" of the entity—that is, the main identifier of each entity
instance; the attributes below the separator are further descriptors of the
entity. For instance, each tag is identified by the pair {TagName, BufId}, and
it is described by the attributes Line and Column.

Entities are connected by "relationships", represented by lines joining two
entities. The above diagram contains a one-to-many relationship, the dot
representing the "many" side: such relationship establishes that each buffer
is possibly associated to many tags, but each tag is always associated to one
and only one buffer. The entity on the "one" side of the relationship (Buffer,
in this example) is called the "parent" entity; the entity on the "many" side
of the relationship (Tag, in this example) is called a "child" entity. Each
relationship is described by two verb phrases separated by a slash: the first
verb phrase is read from parent to child (in this example: "A buffer is tagged
by zero or more tags"); the second is read from child to parent ("a tag
appears in one buffer").

AK stands for Alternate Key, and FK stands for Foreign Key. An alternate key
is an alternative identifier for the entity: in this example, it is assumed
that no two buffers share the same name, so `BufName` can be used as an
identifier as well as `BufId`. A foreign key is the primary key of a parent
entity, which is "migrated" into the child entity by virtue of its
relationship with the parent.

To summarize, the diagram above captures the following facts:

- a buffer is identified by BufId;
- a buffer is alternatively identified by BufName;
- a buffer is tagged by zero or more tags;
- a tag is identified by {BufId, TagName};
- a tag is described by {Line, Column};
- a tag appears in one (and only one) buffer.
- a tag's line must be an integer greater than zero.
- a tag's column must be an integer greater than zero.

The last two constraints derive from footnote (1) in the data model.

Note: IDEF1X is the ISO standard for Relational modelling (ISO/IEC/IEEE
31320-2). The ISO document is not available for free, but the sections
relevant to Relational modelling are derived (essentially verbatim) from the
older FIPS 184, which is available, for instance, from the Internet Archive:
https://archive.org/details/federalinformati184nati/. Despite its age, the
latter document, and its Annex A in particular, is a good introduction to data
modelling.

Data Definition ~

Now that you have a data model, translating it into code is a relatively
straightforward task:

1. Import the library and optionally define aliases for the imported items you
   are going to use:
>
	vim9script

	import 'librelalg.vim' as ra

	const Bool   = ra.Bool
	const Int    = ra.Int
	const Str    = ra.Str
	const Rel    = ra.Rel
	# etc.
<
   Note: in the following, for clarity and conciseness, we will write
   librelalg's names without prefix, as if aliases such as those above had
   been defined for all the imported items.

2. Define one base relation for each entity:
>
	var Buffer = Rel.new('Buffer', {
	    BufId:   Int,
	    BufName: Str,
	  },
	  [['BufId'], ['BufName']]
	)

	var Tag = Rel.new('Tag', {
	    BufId:   Int,
	    TagName: Str,
	    Line:    Int,
	    Column:  Int,
	  },
	  [['BufId', 'TagName']]
	)
<
   The three mandatory arguments of |librelalg.Rel.new()| are:

   a. a descriptive relation name;
   b. the relation schema: this is a |dict| mapping attribute names to the
      corresponding data types;
   c. the |list| of keys. Each relation must have at least one key. Each key is
      a |list| of attributes.

   Note: librelalg does not explicitly distinguish between a primary key and
   the alternate keys. The first listed key is conventionally considered the
   primary key.

3. Add the relevant constraints:
>
	Tag.Check((t) => {
	   if t.Line <= 0 || t.Column <= 0
	      throw 'Line and column numbers must be positive'
	   endif
	})
<
   A check clause defines a generic constraint, which is simply a function or
   a lambda that, given a tuple t, checks for some condition depending on t,
   and throws an error if the condition is not satisfied.
>
	ForeignKey(Tag, 'must appear in', Buffer, 'BufId')
<
   |librelalg.ForeignKey()| defines a foreign key constraint, in this case
   from `BufId` in `Tag` to `BufId` in `Buffer`. The second argument is the
   verb phrase associated to the constraint as read from the child to the
   parent entity in the data model—see |librelalg-tutorial|: the verb phrase
   is used in error messages when the referential integrity is violated. Using
   a mode of obligation ("must") typically makes the constraint violation
   easier to understand.

Data Manipulation ~

Once the database has been defined, each base relation may be populated with
tuples. Each tuple is just a dictionary conforming to the corresponding
relation schema. Let us insert some data:
>
	Buffer.InsertMany([
	  {BufId: 1, BufName: 'foo'},
	  {BufId: 2, BufName: 'bar'},
	  {BufId: 3, BufName: 'xyz'},
	])

	Tag.InsertMany([
	  {BufId: 1, TagName: 'zzz', Line: 1,  Column: 5},
	  {BufId: 1, TagName: 'zzz', Line: 2,  Column: 1},
	  {BufId: 1, TagName: 'abc', Line: 3,  Column: 9},
	  {BufId: 1, TagName: 'xyz', Line: 4,  Column: 1},
	  {BufId: 1, TagName: 'lll', Line: 4,  Column: 8},
	  {BufId: 2, TagName: 'abc', Line: 14, Column: 15},
	  {BufId: 3, TagName: 'abc', Line: 6,  Column: 3},
	])
<
If you want to inspect the content of a relation, you may print it as a table:
>
	echo Table(Buffer)
	echo Table(Tag)
<
The output looks as follows (note that the columns are in an arbitrary order):
>
	 Buffer
	───────────────
	 BufName BufId
	───────────────
	     foo     1
	     bar     2
	     xyz     3

	 Tag
	───────────────────────────
	 TagName Column Line BufId
	───────────────────────────
	     zzz      1    2     1
	     abc      9    3     1
	     xyz      1    4     1
	     lll      8    4     1
	     abc     15   14     2
	     abc      3    6     3
<
Of course, any attempt to violate a constraint is rejected with an error. For
example, trying to insert another buffer called `foobar` will fail with
a duplicate key error, because `BufName` is a key:
>
	Buffer.Insert({BufId: 2, BufName: 'foobar'})

	# Duplicate key value: ['BufId'] = (2) already exists
<
Referential integrity is also guaranteed. For instance:
>
	Tag.Insert({BufId: 5, TagName: 'x', Line: 3, Column: 9})

	# Tag must appear in Buffer:
	# Tag['BufId'] = (5) is not present in Buffer['BufId']
<
And, of course, you are not allowed to insert an invalid line number either:
>
	Tag.Insert({BufId: 1, TagName: 'x', Line: 0, Column: 40})
<
This insertion is rejected with:
>
	Line and column numbers must be positive
<
Updates and deletions are possible, too:
>
	Tag.Update({BufId: 1, TagName: 'abc', Line: 7, Column: 12})
	Tag.Delete((t) => t.Line < 2)
	echo Table(Tag)
<
	Output:
>
	 Tag
	───────────────────────────
	 TagName Column Line BufId
	───────────────────────────
	     zzz      1    2     1
	     abc     12    7     1
	     xyz      1    4     1
	     lll      8    4     1
	     abc     15   14     2
	     abc      3    6     3
<
For updates, you just pass the updated tuple. For deletions, you provide
a predicate (typically, in the form of a lambda) that the tuples to be deleted
must satisfy.

Note: nulls are not supported. A properly designed database never needs nulls,
so this is not a loss of generality, and it is a great gain in simplicity and
semantic clarity.

Queries ~

The power of the Relational Model lies in its powerful query language as well
as in the simplicity and integrity of its data structures: librelalg provides
all the fundamental operations (set operations, selection, projection, joins,
renaming) as well as some extra operations (division, semi-joins, anti-joins,
group-by, etc.). All operators are implemented using a "push-based" strategy:
without entering into technical details, that means that queries are typically
expanded into tight loops and executed as efficiently as hand-written code.

Queries are expressions that are typically used as an argument to
|librelalg.Query()|. For instance, the query "Retrieve the tags in buffer
1 before line 6" can be formulated as follows:
>
	const result = Query(
	    From(Tag)->Select((t) => t.BufId == 1 && t.Line <= 6)
	)
	echo Table(result)
<
This query uses |librelalg.From()| to scan a relation and |librelalg.Select()|
to filter it. Output:
>
	───────────────────────────
	 TagName Column Line BufId
	───────────────────────────
	     zzz      1    2     1
	     xyz      1    4     1
	     lll      8    4     1
<
The result of a query is just a set of tuples, called a "derived" relation.
Contrary to base relations, derived relations do not have any associated keys,
constraints or indexes. They are just lists of homogeneous dictionaries.

If you want to get just the tag names and lines, you may add a projection:
>
	const filteredTags = Query(
	      From(Tag)
	    ->Select((t) => t.BufId == 1 && t.Line <= 6)
	    ->Project(['TagName', 'Line'])
	)
	echo Table(filteredTags)
<
This query also uses |librelalg.Project()|. Output:
>
	──────────────
	 TagName Line
	──────────────
	     zzz    2
	     xyz    4
	     lll    4
<
As another example, the natural join of `Buffer` and `Tag`, sorted by `BufId`
and `TagName`, can be written as follows:
>
	const btags = Query(
	      From(Buffer)
	    ->NatJoin(Tag)
	    ->SortBy(['BufId', 'TagName'])
	)
        echo Table(btags, 'Buffer tags')
<
This query uses |librelalg.NatJoin()| to perform the join,  and
|librelalg.SortBy()| to sort the result. Output:
>
	 Buffer tags
	───────────────────────────────────
	 Column TagName BufName Line BufId
	───────────────────────────────────
	     12     abc     foo    7     1
	      8     lll     foo    4     1
	      1     xyz     foo    4     1
	      1     zzz     foo    2     1
	     15     abc     bar   14     2
	      3     abc     xyz    6     3
<
==============================================================================
2. Data definition language			*librelalg-ddl*

Classes ~
						*librelalg.Rel*
new{name}, {schema}, {keys} [, {typecheck}])
		Define a base relation (aka "relation object"). A base
		relation has a descriptive {name} (a |string| used in error
		messages) and is defined over a {schema}, which is a |dict|
		mapping attributes to their corresponding data types. The
		supported data types are:

		- Int: integers;
		- Str: strings;
		- Float: floats;
		- Bool: booleans.
		- List: lists.

		{keys} is a |list| of keys, where each key is a |list| of
		attributes. Every base relation must have at least one key.

		Example: A relation object R with two integer attributes A and
		C, a string attribute B, a composite primary key A,B and an
		alternate key C can be defined as follows:
>
		var R = Rel.new('R', {
		    A: Int,
		    B: Str,
		    C: Int,
		  }, [['A', 'B'], ['C']])
<
		When a relation has only one key, the outermost list can
		be omitted:
>
		var S = Rel.new('S', {A: Int, B: Str}, ['A'])
<
		When a key has only one attribute, it may be denoted by
		a |string|. So, the above definition is equivalent to the
		following:
>
		var S = Rel.new('S', {A: Int, B: Str}, 'A')
<
		When there is no ambiguity (see the note below), this rule may
		be extended to multiple keys. For instance, the following
		relation has one composite key `['A', 'B']`, and two
		single-attribute keys `['B']`, and `['C']`:
>
		var T = Rel.new('T', {A: Int, B: Int, C: Int},
		                [['A', 'B'], 'B', 'C'])
<
		Note: the following relation has one composite key, not two
		one-single attribute keys:
>
		var U = Rel.new('U', {A: Int, B: Int}, ['A', 'B'])
<
		To define two single-attribute keys, you must use one of these
		forms:
>
		var V = Rel.new('V', {A: Int, B: Int}, [['A'], ['B'])
		var V = Rel.new('V', {A: Int, B: Int}, [['A'], 'B'])
		var V = Rel.new('V', {A: Int, B: Int}, ['A', ['B']])
<
		The last two forms are valid, but not recommended.

		Only tuples conforming to the specified schema may be inserted
		into a base relation. By default, an error is raised if
		a tuple is not compatible with the relation schema. This type
		checking can be turned off by setting {typecheck} to |false|.
		Omitting type checking may slightly improve the performance
		when inserting or updating tuples, but it is not recommended,
		because the gain may be negligible, and type checking is
		useful to detect errors.

		A |librelalg.Rel| object has the following read-only attributes:

		- "name": the name of the relation.
		- "schema": the relation schema.
		- "instance": the relation instance.
		- "keys": the relation keys.
		- "attributes": the sorted list of attributes.
		- "keyAttributes: the sorted list of key attributes.
		- "descriptors": the sorted list of descriptors (that is,
		  attributes that are not part of any key).

Check({func}[, {opts}])
		Add a generic constraint to this base relation. The constraint
		is defined by {func}, which is a |Funcref| taking as an input
		a tuple and raising an error when the tuple does not satisfy
		the constraint.

		A check constraint can be triggered before each insertion,
		update or deletion in the base relation. The operations that
		should trigger the constraint check can be specified by
		{opts}, which is a |list| of one or more of `'I'`, `'U'`, and
		`'D'`, for insertion, update, and deletion, respectively. By
		default (when {opts} is not given), a constraint is checked
		before each insertion and update, but not upon deletion.

Delete([, {func}, {flag}])
		Delete all the tuples of this base relation satisfying
		predicate {func}, which is a function that takes as an input
		a tuple t and returns |true| if t must be deleted, |false|
		otherwise. When {func} is not provided, all the tuples are
		deleted unconditionally, so the relation object becomes empty.

		When {flag} is passed and it is |true| the deletion is an
		atomic operation: if a constraint is violated while deleting
		some tuple, the relation is not modified at all. The default
		is to delete in a non-atomic way: this is faster, but if an
		error occurs while deletion is executing, there is no
		guarantee on how the resulting instance will look like.

Key({key})
		Add a {key} to this base relation.

		In general, using this function is unnecessary, because
		multiple keys can be specified when a base relation is created
		(see |librelalg.Rel|). For example:
>
		var R = Rel.new('R', {A: Int, B: Str}, [['A'], ['B']])
<
		is equivalent to:
>
		var R = Rel.new('R', {A: Int, B: Str}, 'A')
		R.Key('B')
<
Insert({tuple})
		Insert a {tuple} into this base relation. Return the updated
		relation object.

InsertMany({list}[, {flag}])
		Insert a {list} of tuples into this base relation. Return the
		updated relation object.

		When {flag} is passed and it is |true| the insertion is an
		atomic operation: if a constraint is violated while inserting
		some tuple, the relation is not modified at all. So, either
		all tuples are inserted, or none. The default is to insert in
		a non-atomic way: this is faster, but if an error occurs while
		insertion is executing, then the resulting instance will
		contain some, but not all, the tuples that should have been
		inserted.

IsEmpty()
		Return |true| if this relation is empty, |false| otherwise.

Lookup({key}, {list})
		Search for a tuple in this base relation whose {key}
		attributes match the values specified by the given {list}. A special
		`KEY_NOT_FOUND` value is returned if no tuple with the given
		value of the key can be found.

		For example:
>
		import 'librelalg.vim' as ra

		# [...]

		var R = Rel.new('R', {A: Int, B: Str}, 'A')
		R.InsertMany([
		    {A: 1, B: 'x'},
		    {A: 3, B: 'y'},
		    {A: 5, B: 'z'}
		])
		echo Lookup(R, ['A'], [3])  # {A: 3, B: 'y'}
		echo Lookup(R, ['A'], [9]) is ra.KEY_NOT_FOUND  # true
<
		When looking up for a tuple by key, using this function is
		generally faster than using |librelalg.Select()|, because
		lookup access uses an index associated to the key, whereas
		|librelalg.Select()| does a linear scan of the relation.

		Note that the returned value is a tuple, not a relation!

Update({tuple} [, {upsert}])
		Replace a tuple in this base relation with a new {tuple}. The
		tuple that is replaced is the one with the same values of the
		key(s) as {tuple}. An error is raised if such a tuple does not
		exist in the base relation, unless {upsert} is |true|, in
		which case {tuple} is inserted into the relation and no error
		is raised. For instance:
>
		var R = Rel.new('R', {A: Int, B: Str}, 'A')

		R.Insert({A: 1, B: 'v'})
		R.Update({A: 1, B: 'w'})  # OK
		R.Update({A: 2, B: 'z'})  # ERROR: no tuple with A == 2
		R.Update({A: 2, B: 'z'}, true)  # OK (Upsert)
<
		Note that the above semantics implies that only attributes
		that are not part of any key (the "descriptors" of the base
		relation) can be updated. To update a key attribute, remove
		the corresponding tuple and insert a new one.

Functions ~
						*librelalg.ForeignKey()*
ForeignKey({relobj1}, {verb}, {relobj2}, {list}[, {key})
		Define a referential integrity constraint between the list of
		attributes {list} in base relation {relobj1} and a key in base
		relation {relobj2}. When {key} is omitted, the target key is
		assumed to be {list}; otherwise, the list of attributes {key}
		is the target key.

		The string {verb} specifies a verb phrase to be read from
		{relobj1} to {relobj2}. The verb phrase is used in error
		messages when referential integrity is violated. See
		|librelalg-tutorial| for an example.

==============================================================================
3. Relational Algebra				*librelalg-ra*

The following paragraphs provide a high-level description of the inner working
of the Relational Algebra operators as defined by this library. Such
understanding is not strictly necessary to be able to use the library; it may
help, however, to make the most out of it.

This section uses the following terminology:

- A "tuple" is a |dict| mapping attributes to values. Values can be strings,
  integers, booleans, or floats.
- A "relation" instance (or simply an "instance") is a |list| of tuples.
- A "base relation" is a |librelalg.Rel| object. 
- A "derived relation" is a relation instance obtained as the result of
  a query.
- A "relation" is a base relation or a relation instance.
- A "consumer" is any function with signature func({tuple}): void.
- A "continuation" is any function with signature func({Consumer}): void.

Intuitively, a consumer is a function that operates in some way on a tuple,
typically by invoking a continuation. A continuation receives as an input
a consumer and applies it to one or more tuples.

This is best described with an example. Consider the following simple query,
expressed using chaining:
>
	From(Relation)->Select(Pred)->Query()
<
When executed, |librelalg.From()| returns a continuation that looks like this:
>
	def Cont(Emit: func(dict<any>): void): void
	  for t in relation
	    Emit(t)
	  endfor
	enddef
<
where `Emit()` is a consumer. The continuation `Cont` is passed to
|librelalg.Select()| together with a filter `Pred`. Select() builds and
returns another continuation, which look as follows:
>
	def Cont2(Emit: func(dict<any>): void): void
	  def Consumer(t: dict<any>)
	    if Pred(t)
	      Emit(t)
	    endif
	  enddef

	  Cont(Consumer)
	enddef
<
In practice, Select() defines a consumer to filter the tuples according to its
input predicate `Pred`, and then applies its input continuation `Cont` to that
consumer.

Finally, continuation `Cont2` is passed to |librelalg.Query()|, which defines
a consumer to materialize a relation, by generating code similar to the
following:
>
	var rel: list<dict<any>> = []

	def Consumer2(t: dict<any>)
	  add(rel, t)
	enddef

	Cont2(Consumer2)
<
Again, what this operator does is define a consumer (`Consumer2`) and apply
a continuation (`Cont2`) to that consumer.

The original chained call:
>
	From(Relation)->Select(Pred)->Query()
<
can be equivalently re-written as follows:
>
	Query(Select(From(Relation), Pred))
<
Taking into account the foregoing discussion, if you try to expand the latter
expression, you will realize that the result is equivalent to the following
loop:
>
	var rel: list<dict<any>> = []

	for t in Relation
	  if Pred(t)
	    add(rel, t)
	  endif
	endfor
<
which is pretty much what one would have written by hand (short of using
a built-in function such as |filternew()|, that is).

It should be clear at this point how Relatinal operators conceptually
transform relations into relations. Most operators fall into one of three
categories:

- "root" operators: these take as input a (base or derived) relation and emit
  tuples;
- "leaf" operators: these collect tuples and build a derived relation;
- "pipeline" operators: these process tuples and emit (transformed) tuples.

The most important rule is that each query should start (or end, if you use
the chaining notation `->`) with a leaf operator, such as |librelalg.Query()|
(other commonly used leaf operators are |librelalg.Sort()| and
|librelalg.SortBy()|, and there are others), which "materialize" a result.
Without a leaf operator, a query will just return a continuation—that is,
a function.

To simplify writing queries, most operators accept base relations, relation
instances, and continuations transparently, so the user should not typically
worry about the above categorization, and can just write queries in a natural
way.

In the following, unless otherwise noted, whenever a parameter named {rel},
{rel1}, or {rel2} appears, that parameter denotes a base relation, a relation
instance, or a continuation.

Note: binary operators internally materialize their second argument
{rel2}—that is, they build a temporary instance from {rel2} (unless {rel2} is
already a relation, of course). This is something worth keeping in mind in
order to avoid writing queries that unnecessarily create temporary objects.

Note: some of the examples in the rest of this section are based on the sample
instance at the end of |librelalg-tutorial|, which we report again here:
>
	 Buffer
	───────────────
	 BufName BufId
	───────────────
	     foo     1
	     bar     2
	     xyz     3

	 Tag
	───────────────────────────
	 TagName Column Line BufId
	───────────────────────────
	     zzz      1    2     1
	     abc     12    7     1
	     xyz      1    4     1
	     lll      8    4     1
	     abc     15   14     2
	     abc      3    6     3
<
Functions ~

AvgBy({rel}, {groupby}, {attr} [, {name}])	*librelalg.AvgBy()*
		Group the tuples of relation {rel} with respect to a |list| of
		attributes {groupby}, and determine the average of the values
		of attribute {attr} in each group. When grouping by a single
		attribute, {groupby} can also be a |string|. The schema of the
		output relation consists of the grouping attributes plus the
		aggregate attribute. The name of the aggregate attribute is
		given by {name} (the default name is "avg").

		For instance:
>
		var r = [
		    {A: 1, B: 6},
		    {A: 1, B: 4},
		    {A: 2, B: 3}
		]
		const result = From(r)->AvgBy('A', 'B')
		echo Table(result)
<
		Output:
>
		───────
		 A avg
		───────
		 1 5.0
		 2 3.0
<
		This is a leaf operator, returning a relation instance.

AntiJoin({rel1}, {rel2}, {func})		*librelalg.AntiJoin()*
		Perform the anti-join of {rel1} and {rel2}. The join condition
		is specified by {func}, which is defined as in
		|librelalg.Join()|. The result is the set of tuples of {rel1}
		that cannot be joined with any tuple in {rel2}. Examples:
>
		var r = [
		  {A: 1, B: 6},
		  {A: 1, B: 4},
		]
		var s = [
		  {C: 6, D: 40},
		  {C: 6, D: 50},
		  {C: 2, D: 60},
		]
		const result = Query(AntiJoin(r, s, (t, u) => t.B == u.C))
		echo Table(result)
<
		Output:
>
		─────
		 A B
		─────
		 1 4
<
		To obtain the buffers that have no tags before line 10:
>
		const result = Query(
		    AntiJoin(
		      Buffer,
		      Select(Tag, (t) => t.Line < 10),
		      (t, u) => t.BufId == u.BufId
		    )
		  )
		echo Table(result)
<
		Output:
>
		───────────────
		 BufName BufId
		───────────────
		     bar     2
<
		This is a pipeline operator, returning a continuation.

Build({rel})					*librelalg.Build()*
		A synonym of |librelalg.Query()|.

CoddDivide({rel1}, {rel2}[, {hint}])		*librelalg.CoddDivide()*
		Divide a relation {rel1} by another relation {rel2}. This is
		Relational division as originally defined by Codd, which
		requires the schema of the divisor to be a subset of the
		schema of the dividend—that is, R(X) ÷ S(Y) is defined only if
		Y ⊆ X.

		This operator builds the maximal¹ relation instance Q on
		X such that each tuple in Q joined with any tuple of
		S produces a tuple in R.

		¹Maximality here is relative to the values of the input. More
		precisely, the output is always a subset of π_X(R), the
		projection of R on X.

		Examples:
>
		var r = [
		  {A: 10, B: 'a', C: 6},
		  {A: 10, B: 'a', C: 4},
		  {A: 10, B: 'a', C: 2},
		  {A: 10, B: 'b', C: 2},
		  {A: 20, B: 'c', C: 6},
		  {A: 20, B: 'c', C: 2},
		]
		var s = [
		  {C: 6},
		  {C: 4},
		  {C: 2},
		]
		const result = Query(CoddDivide(r, s))
		echo Table(result)
<
		Output:
>
		──────
		  A B
		──────
		 10 a
<
		To obtain the names of the tags that appear in every buffer:
>
		const result = Query(
		    Project(Tag, ['BufId', 'TagName'])
		    ->CoddDivide(Project(Buffer, ['BufId']))
		)
		echo Table(result)
<
		Output:
>
		─────────
		 TagName
		─────────
		     abc
<
		If the divisor is an empty derived relation, then it does not
		carry any explicit information about its schema, because it is
		just an empty |list|. Hence, it is not possible to infer the
		schema of the quotient relation automatically. In this special
		case, a |list| of attributes {hint} may be used to specify the
		attributes of the divisor (if {hint} is not given, an empty
		schema is assumed). For instance:
>
		const result = Query(Buffer->CoddDivide([], ['BufId']))
<
		Output:
>
		 BufName
		─────────
		     foo
		     bar
		     xyz
<
		Note that {hint} is ignored if the divisor is not empty,
		because the schema can be inferred from each tuple, or if the
		divisor is a base relation, because a base relation has an
		associated schema.

		This is a pipeline operator, returning a continuation. See
		also |Divide()|.

CountBy({rel}, {groupby}[, {attr}, {name}])	*librelalg.CountBy()*
		Group the tuples of a relation {rel} with respect to a |list|
		of attributes {groupby}, and count the number of tuples in
		each group. When grouping by a single attribute, {groupby} can
		also be a |string|. If {attr} is given and is not
		|null_string|, then count the number of distinct values of
		attribute {attr} in each group. The schema of the output
		relation consists of the grouping attributes plus the
		aggregate attribute. The name of the aggregate attribute is
		given by {name} (the default name is "count").

		For instance:
>
		var r = [
		    {N: 0, A: 100, B: 6},
		    {N: 1, A: 100, B: 4},
		    {N: 2, A: 200, B: 3},
		    {N: 3, A: 100, B: 5},
		    {N: 4, A: 200, B: 3},
		    {N: 5, A: 100, B: 6},
		]
		const result1 = From(r)->CountBy('A')
		const result2 = From(r)->CountBy('A', 'B')
		echo Table(result1, 'Count all')
		echo Table(result2, 'Count distinct B')
<
		Output:
>
		 Count all
		───────────
		   A count
		───────────
		 200     2
		 100     4

		 Count distinct B
		──────────────────
		          A count
		──────────────────
		        200     1
		        100     3
<
		This is a leaf operator, returning a relation instance.

Divide({rel1}, {rel2})				*librelalg.Divide()*
		Divide a relation {rel1} by another relation {rel2}. This is
		a form of generalized Relational division with no restriction
		on the schemas of the operands. Consider two relations R(X,Y)
		and S(Y,Z) where Y is the subset of attributes in common
		between R and S, hence X and Z are disjoint (any of these
		subsets may be empty). Then, R ÷ S = Q(X,Z) is the maximal¹
		relation instance on (X,Z) such that each tuple (x,z) in Q,
		when joined with any tuple of S and projected on (X,Y) gives
		a tuple in R. In other words, Q consists of the tuples (x,z)
		such that a tuple (x,y) exists in R for every tuple (y,z) in
		S.

		¹Maximality here is relative to the values of the input. More
		precisely, the output is always a subset of π_X(R) ⨯ π_Z(S),
		the cross-product of the projection of R on X and the
		projection of S on Z.

		Consider the following example:
>
		const SP = [  # Supplier S# supplies part P#
		  {'S#': 1, 'P#': 10},
		  {'S#': 1, 'P#': 20},
		  {'S#': 1, 'P#': 30},
		  {'S#': 2, 'P#': 10},
		  {'S#': 2, 'P#': 20},
		  {'S#': 3, 'P#': 20},
		  {'S#': 3, 'P#': 40},
		]
		const PJ = [  # Part P# is used in project J#
		  {'P#': 10, 'J#': 100},
		  {'P#': 20, 'J#': 100},
		  {'P#': 20, 'J#': 200},
		  {'P#': 30, 'J#': 200},
		  {'P#': 20, 'J#': 300},
		  {'P#': 40, 'J#': 300},
		]
<
		Then SP ÷ PJ and PJ ÷ SP are computed as follows:
>
		const sp_div_pj = Query(Divide(SP, PJ))
		const pj_div_sp = Query(Divide(PJ, SP))
		echo Table(sp_div_pj, 'SP ÷ PJ')
		echo Table(pj_div_sp, 'PJ ÷ SP')
<
		Output:
>
		 SP ÷ PJ
		─────────
		  S#  J#
		─────────
		   1 100
		   1 200
		   2 100
		   3 300

		 PJ ÷ SP
		─────────
		  S#  J#
		─────────
		   2 100
		   3 300
<
		The first query finds the pairs (S#,J#) such that supplier S#
		supplies all the parts used in project J#; the second query
		finds all the pairs (S#,J#) such that project J# uses all the
		parts supplied by supplier S#.

		A special case is when the schema of the divisor S(Y,Z) is
		a subset of the schema of the dividend R(X,Y)—that is, when
		Z is empty. Then, this operation reduces to |CoddDivide()|
		(although the latter is in general computed more efficiently),
		except for the special case of an empty divisor. If the
		divisor is empty, then |Divide()| always returns an empty
		relation, while |CoddDivide()| always returns π_X(R), the
		projection of the dividend on X.

						*librelalg.EquiJoin()*
EquiJoin({rel1}, {rel2}, {list1}, {list2}, [, {prefix}])
		Perform an equi-join between two relations {rel1} and {rel2}.

		The |list| {list1} is a subset of the attributes of {rel1}.
		{list2} is a matching |list| of attributes of {rel2}, that is,
		the two lists must have the same length. Attributes at the
		same position in the two lists are compared for equality. For
		{prefix}, see |librelalg.Join()|. Examples:
>
		var r = [
		  {A: 1, B: 6},
		  {A: 1, B: 4},
		]
		var s = [
		  {C: 6, D: 40},
		  {C: 6, D: 50},
		  {C: 2, D: 60},
		]
		const result = Query(EquiJoin(r, s, ['B'], ['C']))
		echo Table(result)
<
		Output:
>
		──────────
		 A B C  D
		──────────
		 1 6 6 40
		 1 6 6 50
<
		To join all the buffers with all their tags:
>
		const result = Query(
		    EquiJoin(Buffer, Tag, ['BufId'], ['BufId'], 't_')
		  )
		echo Table(result)
<
		Output:
>
		─────────────────────────────────────────────
		 TagName Column Line t_BufId BufId t_BufName
		─────────────────────────────────────────────
		     zzz      1    2       1     1       foo
		     abc     12    7       1     1       foo
		     xyz      1    4       1     1       foo
		     lll      8    4       1     1       foo
		     abc     15   14       2     2       bar
		     abc      3    6       3     3       xyz
<
		See |librelalg.Join()| for an equivalent formulation of the
		previous example.

		This is a pipeline operator, returning a continuation.

Extend({rel}, {func})				*librelalg.Extend()*
	Extend each tuple of relation {rel} with a tuple computed by {func}.
	{func} receives a tuple and returns another tuple, which must not have
	any attribute in common with the input tuple. For example:
>
	var r = [{A: 1}, {A: 3}, {A: 5}]

	const result = Query(
	    Extend(r, (t): dict<any> => {
	       return {B: t.A * 2, C: -t.A}
	    }))
	echo Table(result)
<
	The output is:
>
	─────────
	 A  B  C
	─────────
	 1  2 -1
	 3  6 -3
	 5 10 -5
<
	Note that {func} should consistently return tuples over the same,
	fixed, schema, for the result to be a valid relation instance.

	This is a pipeline operator, returning a continuation.

Filter({rel}, {func})				*librelalg.Filter()*
		Filter a relation using predicate {func}. Only the tuples for
		which {func} returns |true| are selected. This is similar to
		|librelalg.Select()|, but potentially faster, as it is
		essentially a thin wrapper around |filter()|.

		This is a leaf operator, returning a relation instance.

Foreach({rel})					*librelalg.Foreach()*
		A synonym of |librelalg.From()|.

Frame({rel}, {list}[, {name}])			*librelalg.Frame()*
		Virtually partition a relation {rel} based on a {list} of
		attributes, extend the relation with a new attribute and,
		within this attribute, assign a distinct integer value to each
		distinct member of the partition. The standard name of the
		added attribute is "fid" (for "frame ID"), but a different
		value can be set with {name}. For instance:
>
		var r = [
		    {A: 10, B: 'a', C: 'x'},
		    {A: 20, B: 'b', C: 'y'},
		    {A: 30, B: 'a', C: 'x'},
		    {A: 40, B: 'a', C: 'x'},
		    {A: 50, B: 'b', C: 'x'},
		    {A: 60, B: 'b', C: 'y'},
		    {A: 70, B: 'a', C: 'y'},
		  ]
		const result = Query(From(r)->Frame(['B', 'C']))
		echo Table(result)
<
		Output:
>
		────────────
		  A B C fid
		────────────
		 10 a x   0
		 20 b y   1
		 30 a x   0
		 40 a x   0
		 50 b x   2
		 60 b y   1
		 70 a y   3
<
		This is a pipeline operator, returning a continuation.

From({rel})					*librelalg.From()*
		Return a continuation that iterates over the tuples of
		a relation {rel} and emits each tuple. If {rel} is already
		a continuation, then this function just returns it. This is
		a root operator, that is, an operator that starts a query.

GroupBy({rel}, {groupby}, {func} [, {name}])	*librelalg.GroupBy()*
		Group the tuples of a relation {rel} with respect to a |list|
		of attributes {groupby}, and apply an aggregate function
		{func} to each group. When grouping by a single attribute,
		{groupby} can also be a |string|. The schema of the output
		relation consists of the grouping attributes and the aggregate
		attribute. The name of the aggregate attribute is given by
		{name}. Examples:
>
		var r = [
		    {A: 10, B: 'a', C: 'x', D: 4},
		    {A: 20, B: 'b', C: 'y', D: 7},
		    {A: 30, B: 'a', C: 'x', D: 3},
		    {A: 40, B: 'a', C: 'x', D: 0},
		    {A: 50, B: 'b', C: 'x', D: 3},
		    {A: 60, B: 'b', C: 'y', D: 9},
		    {A: 70, B: 'a', C: 'y', D: 3},
		  ]
		const result = Query(
		   From(r)->GroupBy(['B', 'C'], Min('D'), 'minD')
		)
		echo Table(result)
<
		Output:
>
		──────────
		 B C minD
		──────────
		 a y    3
		 b x    3
		 a x    0
		 b y    7
<
		To count the number of tags in each buffer with tags:
>
		const result = Query(
		    Tag->GroupBy('BufId', Count, 'num_tags')
		  )
		echo Table(result)
<
		Output:
>
		────────────────
		 num_tags BufId
		────────────────
		        4     1
		        1     2
		        1     3
<
		|librelalg.Min()| and |librelalg.Count()| are aggregate
		functions. For more aggregate functions, see |librelalg-aggr|.

		For the most common aggregate functions, specialized operators
		exist, which are generally preferrable over GroupBy(): see
		|librelalg.AvgBy()|, |librelalg.CountBy()|,
		|librelalg.MaxBy()|, |librelalg.MinBy()|, |librelalg.SumBy()|.

		This is a pipeline operator, returning a continuation.

Intersect({rel1}, {rel2})			*librelalg.Intersect()*
		Return the intersection of two relations {rel1} and {rel2}.
		Note: the relations must be defined on the same schema!

		For instance:
>
		var r = [
		  {A: 1, B: 'x'},
		  {A: 3, B: 'y'},
		  {A: 5, B: 'y'},
		]
		var s = [
		  {A: 3, B: 'y'},
		  {A: 6, B: 'y'},
		]
		const result = Query(Intersect(r, s))
		echo Table(result)
<
		The output is:
>
		─────
		 A B
		─────
		 3 y
<
		This is a pipeline operator, returning a continuation.

Join({rel1}, {rel2}, {func} [, {prefix}])	*librelalg.Join()*
		Join two relations {rel1} and {rel2}. The join condition is
		specified by {func}, which is a |Funcref| that takes as an
		input two tuples t1 and t2 and returns |true| if t1 and t2
		should be joined, and returns |false| otherwise.

		{prefix} is a string that is added to each attribute name of
		{rel1} in the output relation. The prefix is mandatory if the
		relations to be joined have some attributes in common, because
		the attributes in a relation must be all distinct. The prefix
		must not be used inside {func}. Examples:
>
		var r = [
		  {A: 1, B: 6},
		  {A: 1, B: 4},
		]
		var s = [
		  {C: 6, D: 40},
		  {C: 6, D: 50},
		  {C: 2, D: 60},
		]
		const result = Query(Join(r, s, (t, u) => t.B == u.C))
		echo Table(result)
<
		Output:
>
		──────────
		 A B C  D
		──────────
		 1 6 6 40
		 1 6 6 50
<
		This join can also be done with |librelalg.EquiJoin()|. But
		with this operator you may join on arbitrary conditions:
>
		const result2 = Query(Join(r, s, (t, u) => t.B > u.C))
		echo Table(result2)
<
		Output:
>
		──────────
		 A B C  D
		──────────
		 1 6 2 60
		 1 4 2 60
<
		To join `Buffer` with `Tag` on the common `BufId` attribute:
>
		const result = Query(
		    Join(Buffer, Tag, (t, u) => t.BufId == u.BufId, 't_')
		  )
		echo Table(result)
<
		Output:
>
		─────────────────────────────────────────────
		 TagName Column Line t_BufId BufId t_BufName
		─────────────────────────────────────────────
		     zzz      1    2       1     1       foo
		     abc     12    7       1     1       foo
		     xyz      1    4       1     1       foo
		     lll      8    4       1     1       foo
		     abc     15   14       2     2       bar
		     abc      3    6       3     3       xyz
<
		Failing to add a prefix in the query above will result in an
		error:
>
		Key already exists: BufId
<
		because the attribute `BufId` exists both in `Buffer` and in
		`Tag`.

		This is a pipeline operator, returning a continuation.

LeftNatJoin({rel1}, {rel2}, {filler})		*librelalg.LeftNatJoin()*
		Perform the left natural join of two relations {rel1} and
		{rel2}. {filler} is an arbitrary relation defined on the
		attributes of {rel2} minus the join attributes. The result is
		the natural join between the input relations extended (by
		union) with the cross-product of {filler} and the set of
		tuples in {rel1} that do not match any tuple in {rel2}.

		For instance:
>
		var r = [
		    {A: 1, B: 'x'},
		    {A: 2, B: 'x'},
		    {A: 3, B: 'y'},
		    {A: 4, B: 'z'},
		    {A: 5, B: 'w'},
		]
		var s = [
		    {B: 'x', C: 10},
		    {B: 'z', C: 20},
		    {B: 'z', C: 30},
		]
		const result = Query(LeftNatJoin(r, s, [{C: -1}]))
		echo Table(result)
<
		Output:
>
		────────
		 A B  C
		────────
		 1 x 10
		 2 x 10
		 3 y -1
		 4 z 20
		 4 z 30
		 5 w -1
<
		This is a pipeline operator, returning a continuation.

MaxBy({rel}, {groupby}, {attr} [, {name}])	*librelalg.MaxBy()*
		Group the tuples of a relation {rel} with respect to a |list|
		of attributes {groupby}, and determine the maximum value of
		attribute {attr} in each group. When grouping by a single
		attribute, {groupby} can also be a |string|. The schema of the
		output relation consists of the grouping attributes plus the
		aggregate attribute. The name of the aggregate attribute is
		given by {name} (the default name is "max").

		For instance:
>
		var r = [
		    {A: 100, B: 6},
		    {A: 100, B: 4},
		    {A: 200, B: 3}
		]
		const result = From(r)->MaxBy('A', 'B')
		echo Table(result)
<
		Output:
>
		─────────
		   A max
		─────────
		 200   3
		 100   6
<
		This is a leaf operator, returning a relation instance.

MinBy({rel}, {groupby}, {attr} [, {name}]	*librelalg.MinBy()*
		Group the tuples of a relation {rel} with respect to a |list|
		of attributes {groupby}, and determine the minimum value of
		attribute {attr} in each group. When grouping by a single
		attribute, {groupby} can also be a |string|. The schema of the
		output relation consists of the grouping attributes plus the
		aggregate attribute. The name of the aggregate attribute is
		given by {name} (the default name is "min").

		For instance:
>
		var r = [
		    {A: 100, B: 6},
		    {A: 100, B: 4},
		    {A: 200, B: 3}
		]
		const result = From(r)->MinBy('A', 'B')
		echo Table(result)
<
		Output:
>
		─────────
		 min   A
		─────────
		   3 200
		   4 100
<
		This is a leaf operator, returning a continuation.

Minus({rel1}, {rel2})				*librelalg.Minus()*
		Subtract relation {rel2} from relation {rel1}. Note: the
		relations must be defined on the same schema!

		For instance:
>
		var r = [
		  {A: 1, B: 'x'},
		  {A: 3, B: 'y'},
		  {A: 5, B: 'y'},
		]
		var s = [
		  {A: 3, B: 'y'},
		  {A: 6, B: 'y'},
		]
		const result = Query(Minus(r, s))
		echo Table(result)
<
		The output is:
>
		─────
		 A B
		─────
		 1 x
		 5 y
<
		This is a pipeline operator, returning a continuation.

NatJoin({rel1}, {rel2})				*librelalg.NatJoin()*
		Perform the natural join of two relations {rel1} and {rel2}.
		Examples:
>
		var r = [
		  {A: 1, B: 6},
		  {A: 1, B: 4},
		]
		var s = [
		  {B: 6, C: 40},
		  {B: 6, C: 50},
		  {B: 2, C: 60},
		]
		const result = Query(NatJoin(r, s))
		echo Table(result)
<
		Output:
>
		────────
		 A B  C
		────────
		 1 6 40
		 1 6 50
<
		To join `Buffer` with `Tag` on the common `BufId` attribute:
>
		const result = Query(NatJoin(Buffer, Tag))
		echo Table(result)
<
		Output:
>
		───────────────────────────────────
		 Column TagName BufName Line BufId
		───────────────────────────────────
		      1     zzz     foo    2     1
		     12     abc     foo    7     1
		      1     xyz     foo    4     1
		      8     lll     foo    4     1
		     15     abc     bar   14     2
		      3     abc     xyz    6     3
<
		This is a pipeline operator, returning a continuation.

Query({rel})					*librelalg.Query()*
		Materialize a relation {rel}. If {rel} is a continuation,
		build a new instance by consuming the tuples emitted by the
		continuation. If {rel} is already a (base or derived)
		relation, return the relation instance directly.

		This is a leaf operator, always returning a relation instance.

Rename({rel}, {list1}, {list2})			*librelalg.Rename()*
		Rename the attributes of a relation {rel}. {list1} is a list
		of attributes to rename. {list2} is the corresponding list of
		new attribute names.

		Example:
>
		var r = [
		    {A: 1, B: 'u'},
		    {A: 2, B: 'v'}
		]
		var s = Query(Rename(r, ['A', 'B'], ['X', 'Y']))
		echo Table(s)
<
		The output is:
>
		─────
		 X Y
		─────
		 1 u
		 2 v
<
		Only the schema of the relation (that is, the header of the
		table) is changed: the instance remains the same.

		This is a pipeline operator, returning a continuation.

Product({rel1}, {rel2} [, {prefix}])		*librelalg.Product()*
		Perform the cross product of two relations {rel1} and {rel2}.
		For {prefix}, see |librelalg.Join()|. Examples:
>
		var r = [
		  {A: 1, B: 6},
		  {A: 1, B: 4},
		]
		var s = [
		  {C: 9, D: 40},
		  {C: 7, D: 50},
		  {C: 4, D: 60},
		]
		const result = Query(Product(r, s))
		echo Table(result)
<
		Output:
>
		──────────
		 A B C  D
		──────────
		 1 6 9 40
		 1 6 7 50
		 1 6 4 60
		 1 4 9 40
		 1 4 7 50
		 1 4 4 60
<
		To obtain all the sorted pairs of tag names:
>
		const Tagname = Project(Tag, 'TagName')
		const result  = Query(
		      Product(Tagname, Tagname, 't_')
		    ->Select((t) => t.TagName < t.t_TagName)
		    ->SortBy(['TagName', 't_TagName'])
		)
		echo Table(result)
<
		Output:
>
		 ───────────────────
		 TagName t_TagName
		───────────────────
		     abc       lll
		     abc       xyz
		     abc       zzz
		     lll       xyz
		     lll       zzz
		     xyz       zzz
<
		This is a pipeline operator, returning a continuation.

Project({rel}, {attrs})				*librelalg.Project()*
		Perform a projection of a relation {rel} on the list of
		attributes {attrs}. When {attrs} is a single attribute,
		a |string| can also be used. Examples:
>
		var r = [
		  {A: 1, B: 'one', C: 10},
		  {A: 2, B: 'one', C: 10},
		  {A: 3, B: 'one', C: 15},
		  {A: 4, B: 'two', C: 20},
		  {A: 5, B: 'two', C: 20},
		  {A: 5, B: 'six', C: 60},
		]
		const result = Query(Project(r, ['B', 'C']))
		echo Table(result)
<
		Output:
>
		────────
		   B  C
		────────
		 one 10
		 one 15
		 two 20
		 six 60
<
		To obtain all the tag names:
>
		const result = Query(Project(Tag, 'TagName'))
		echo Table(result)
<
		Output:
>
		 TagName
		─────────
		     zzz
		     abc
		     xyz
		     lll
<
		This is a pipeline operator, returning a continuation.

Scan({rel})					*librelalg.Scan()*
		A synonym of |librelalg.From()|.

Select({rel}, {func})				*librelalg.Select()*
		Filter the tuples of a relation {rel} based on a predicate
		{func}, which is a |Funcref| that takes as an input a tuple t
		and returns |true| if and only if t must be selected.
		Examples:
>
		var r = [
		  {A: 1, B: 5, C: 10},
		  {A: 2, B: 8, C: 10},
		  {A: 3, B: 7, C: 14},
		  {A: 4, B: 8, C: 20},
		  {A: 5, B: 2, C: 20},
		  {A: 5, B: 1, C:  2},
		]
		const result = Query(Select(r, (t) => t.C == 2 * t.B))
		echo Table(result)
<
		Output:
>
		────────
		 A B  C
		────────
		 1 5 10
		 3 7 14
		 5 1  2
<
		To select all the tags after line 3 in buffer 1:
>
		const result = Query(
		    Select(Tag, (t) => t.BufId == 1 && t.Line > 3)
		  )
		echo Table(result)
<
		Output:
>
		───────────────────────────
		 TagName Column Line BufId
		───────────────────────────
		     abc     12    7     1
		     xyz      1    4     1
		     lll      8    4     1
<
		This is a pipeline operator, returning a continuation. See
		also |librelalg.Lookup()|.

SemiJoin({rel1}, {rel2}, {func})		*librelalg.SemiJoin()*
		Perform the semi-join of two relations {rel1} and {rel2}. This
		is the same as joining {rel1} with {rel2} (see
		|librelalg.Join()|), then projecting the result on the
		attributes of {rel1}. Examples:
>
		var r = [
		  {A: 1, B: 6},
		  {A: 1, B: 4},
		]
		var s = [
		  {C: 6, D: 40},
		  {C: 6, D: 50},
		  {C: 2, D: 60},
		]
		const result = Query(SemiJoin(r, s, (t, u) => t.B == u.C))
		echo Table(result)
<
		Output:
>
		─────
		 A B
		─────
		 1 6
<
		To obtain the buffers with tags beyond column 10:
>
		const result = Query(
		      SemiJoin(Buffer, Tag,
		               (t, u) => t.BufId == u.BufId && u.Column > 10)
		  )
		echo Table(result)
<
		Output:
>
		───────────────
		 BufName BufId
		───────────────
		     foo     1
		     bar     2
<
		This is a pipeline operator, returning a continuation.

Sort({rel}, {func})				*librelalg.Sort()*
		Materialize a relation by sorting its tuples according to the
		criterion specified by {func}. The sorting predicate {func} is
		a |Funcref| that takes as an input two tuples t1 and t2, and
		returns a negative |number| if t1 precedes t2, a positive |number|
		if t1 follows t2, and zero if t1 equals t2. Examples:
>
		var r = [
		  {A: 1, B: 6},
		  {A: 2, B: 4},
		  {A: 3, B: 9},
		  {A: 4, B: 2},
		]
		const result = Query(Sort(r, (t, u): number => t.B - u.B))
		echo Table(result)
<
		Output:
>
		─────
		 A B
		─────
		 4 2
		 2 4
		 1 6
		 3 9
<
		To sort tags by line number (regardless of the buffers) in
		decreasing order:
>
		const result = From(Tag)->Sort((t1, t2) => t2.Line - t1.Line)
		echo Table(result)
<
		Output:
>
		───────────────────────────
		 TagName Column Line BufId
		───────────────────────────
		     abc     15   14     2
		     abc     12    7     1
		     abc      3    6     3
		     xyz      1    4     1
		     lll      8    4     1
		     zzz      1    2     1
<
		See |librelalg.SortBy()| for an equivalent, but simpler,
		formulation of this query.

		This is a leaf operator, returning a relation instance. See
		also |librelalg.SortBy()|.

SortBy({rel}, {attrs} [, {opts}])		*librelalg.SortBy()*
		Materialize a relation {rel} by sorting the tuples according
		to the specified list of attributes {attrs}. When {attrs} is
		a single attribute, a |string| may also be used. For instance:
>
		const result = From(Tag)->SortBy('Line')
		echo Table(result)
<
		Output:
>
		───────────────────────────
		 TagName Column Line BufId
		───────────────────────────
		     zzz      1    2     1
		     xyz      1    4     1
		     lll      8    4     1
		     abc      3    6     3
		     abc     12    7     1
		     abc     15   14     2
<
		{opts} is a list that specifies, for each sorting attribute,
		whether to sort the values of that attribute in increasing or
		decreasing order. For instance:
>
		const result = From(Tag)
		               ->SortBy(['TagName', 'Column'], ['i', 'd'])
		echo Table(result)
<
		Output:
>
		 TagName Column Line BufId
		───────────────────────────
		     abc     15   14     2
		     abc     12    7     1
		     abc      3    6     3
		     lll      8    4     1
		     xyz      1    4     1
		     zzz      1    2     1
<
		The tuples of `Tag` are sorted in increasing order (`'i'`)
		with respect to `TagName`, and then the tags with the same
		name are sorted in decreasing order (`'d'`) with respect to
		`Column`.

		This is a leaf operator, returning a relation instance. See
		also |librelalg.Sort()|.

SumBy({rel}, {groupby}, {attr} [, {name}])	*librelalg.SumBy()*
		Group the tuples of a relation {rel} with respect to a list of
		attributes {groupby}, and sum the values of attribute {attr}
		in each group. When grouping by a single attribute, {groupby}
		can also be a |string|. The schema of the output relation
		consists of the grouping attributes plus the aggregate
		attribute. The name of the aggregate attribute is given by
		{name} (the default name is "sum").

		For instance:
>
		var r = [
		    {A: 100, B: 6},
		    {A: 100, B: 4},
		    {A: 200, B: 3}
		]
		const result = From(r)->SumBy('A', 'B')
		echo Table(result)
<
		Output:
>
		─────────
		   A sum
		─────────
		 200   3
		 100  10
<
		This is a leaf operator, returning a relation instance.

Union({rel1}, {rel2})				*librelalg.Union()*
		Return the union of two relations {rel1} and {rel2}. Note: the
		relations must be defined on the same schema!

		For instance:
>
		var r = [
		    {A: 1, B: 'x'},
		    {A: 3, B: 'y'},
		    {A: 5, B: 'y'}
		]
		var s = [
		    {A: 3, B: 'y'},
		    {A: 6, B: 'y'},
		    {A: 1, B: 'x'},
		]
		const result = Query(Union(r, s))
		echo Table(result)
<
		The output is:
>
		─────
		 A B
		─────
		 1 x
		 3 y
		 5 y
		 6 y
<
		This is a leaf operator, returning a relation instance.

==============================================================================
4. Aggregate functions				*librelalg-aggr*

An aggregate function is a special type of leaf operator: instead of returning
a relation instance, an aggregate function returns a scalar. These functions
can be used as normal leaf operators, as in the following example:
>
	# Count the number of tuples
	echo From([{A: 9}, {A: 4}, {A: 6}])->Count()  # 3
<
Aggregate functions can also be used as an argument to |librelalg.GroupBy()|

Avg({rel}, {attr})				*librelalg.Avg()*
		Return the average value of attribute {attr} in a relation
		{rel}. Examples:
>
		echo From([{A: 9}, {A: 7}, {A: 11}])->Avg('A')  # 9.0
<
		To return the average tag's column number:
>
		const avg = From(Tag)->Avg('Column')  # 6.666667
<
Count({rel})					*librelalg.Count()*
		Return the number of tuples of a relation {rel}.  Examples:
>
		echo From([{A: 9}, {A: 7}])->Count()  # 2
<
		To compute the number of buffers:
>
		const nBuf = From(Buffer)->Count()    # 3
<
CountDistinct({rel}, {attr})			*librelalg.CountDistinct()*
		Return the number of distinct values in attribute {attr} of
		a relation {rel}. Examples:
>
		echo From([
		  {X: 0, Y: 1},
		  {X: 1, Y: 1},
		  {X: 2, Y: 3},
		  {X: 3, Y: 3},
		])->CountDistinct('Y')  # 2
<
		To return the number of distinct tag names:
>
		const nDistinctTags = From(Tag)->CountDistinct('TagName')  # 4
<
ListAgg({rel}, {attr})				*librelalg.ListAgg()*
		Return the values of attribute {attr} in a relation {rel} as
		a |list|. Examples:
>
		echo From([{A: 9}, {A: 7}, {A: 11}])
			->ListAgg('A')  # [9, 7, 11]
<
		To return the list of tags in each buffer, sorted by buffer:
>
		const result = From(Tag)
		               ->GroupBy('BufId', ListAgg('TagName'))
		               ->SortBy(['BufId'])
		echo Table(result)
<
		Output:
>
		────────────────────────────────────
		                    aggrValue BufId
		────────────────────────────────────
		 ['zzz', 'abc', 'xyz', 'lll']     1
		                      ['abc']     2
		                      ['abc']     3
<
Min({rel}, {attr})				*librelalg.Min()*
		Return the minimum value of attribute {attr} in a relation
		{rel}. Examples:
>
		echo From([{A: 9}, {A: 7}, {A: 11}])->Min('A')  # 7
<
		To return the minimum buffer id:
>
		const minBufId = From(Buffer)->Min('BufId')     # 1
<
Max({rel}, {attr})				*librelalg.Max()*
		Return the maximum value of attribute {attr} in a relation
		{rel}. Examples:
>
		echo From([{A: 9}, {A: 7}, {A: 11}])->Max('A')  # 11
<
		To return the maximum column of a tag:
>
		const maxCol = From(Tag)->Max('Column')         # 15
<
StringAgg({rel}, {attr}, {sep}, {how})		*librelalg.StringAgg()*
		Return the values of attribute {attr} in a relation {rel}
		joined into a |string|. The values in the string are separated
		by string {sep}. The items are sorted using |sort()|. {how} is
		defined as in |sort()|. Note: all the arguments are mandatory!
		Examples:
>
		echo From([{A: 9}, {A: 7}, {A: 11}])
			->StringAgg('A', ', ', 'n')  # '7, 9, 11'
<
		To return the tags in each buffer joined into a string, sorted
		by buffer:
>
		const result = From(Tag)
		               ->GroupBy('BufId', StringAgg('TagName', ',', ''))
		               ->SortBy(['BufId'])
		echo Table(result)
<
		Output:
>
		───────────────────────
		       aggrValue BufId
		───────────────────────
		 abc,lll,xyz,zzz     1
		             abc     2
		             abc     3
<
Sum({rel}, {attr})				*librelalg.Sum()*
		Return the sum of the values of attribute {attr} in a relation
		{rel}. Examples:
>
		echo From([{A: 9}, {A: 7}, {A: 11}])->Sum('A')  # 27
<
		To compute the sum of all tags' columns:
>
		const colSum = From(Tag)->Sum('Column')         # 40
<
==============================================================================
5. Other functions				*librelalg-other*

EquiJoinPred({list1}[, {list2}])		*librelalg.EquiJoinPred()*
		Return a predicate for comparing two tuples using the
		attributes {list1} of the first tuple and the attributes
		{list2} of the second tuple. The comparison is elementwise
		equality. When {list2} is not provided, {list1} is used for
		the second tuple, too. The returned function can be used as an
		argument to the various join operators. 

		For example, to find the tag names that are also buffer names:
>
		const Pred = EquiJoinPred(['BufName'], ['TagName'])
		const result = Query(SemiJoin(Buffer, Tag, Pred))
<
		This will join on the condition:
>
		Buffer.BufName == Tag.TagName
<
		Output:
>
		───────────────
		 BufName BufId
		───────────────
		     xyz     3
<
In({tuple}, {rel})				*librelalg.In()*
		Return |true| if {tuple} is in base or derived relation {rel},
		otherwise return |false|.

NotIn({tuple}, {rel})				*librelalg.NotIn()*
		Return |true| if {tuple} is not in base or derived relation
		{rel}, otherwise return |false|.

RelEq({rel1}, {rel2})				*librelalg.RelEq()*
		Compare two base or derived relations for equality. Return
		|true| if the relations are equal, that is, they are the same
		set of tuples (the order of the tuples does not matter);
		return |false| otherwise.

Table({rel} [, {columns}, {name}, {sep})	*librelalg.Table()*
		Return a tabular representation of a base or derived relation
		{rel} as a |string|. The title of the table may be specified
		with {name}: the default is to use the relation name for base
		relations, and no title for derived relations.

		The columns are printed in an arbitrary order. If you want the
		columns to be in a particular order or you want to print only
		a subset of the columns, specify the |list| of {columns}. When
		{columns} is a single attribute, it can also be a |string|.

		The horizontal separator symbol can be set with {sep}, and
		must be a single character.

		Examples:
>
		const r = [
		  {X: 10, Y: 'ten'},
		  {X: 20, Y: 'twenty'},
		]

		echo Table(r) "\n"
		echo Table(r, ['Y', 'X'], 'A table', '~') "\n"
		echo Table(r, 'Y')
<
		Output:
>
		───────────
		  X      Y
		───────────
		 10    ten
		 20 twenty
		
		 A table
		~~~~~~~~~~~
		      Y  X
		~~~~~~~~~~~
		    ten 10
		 twenty 20

		────────
		      Y
		────────
		    ten
		 twenty
<
Transform({rel}, {func})				*librelalg.Transform()*
		Transform a base or derived relation {rel} into a list of
		objects, one for each tuple of the relation. This is similar
		to |map()|, but the result does not need to have the same type
		as the input. Note that the result is NOT a relation, in
		general!

		Example:
>
		const r = [{X: 3, Y: 6}, {X: 5, Y: 2}]
		echo Transform(r, (t) => t.X * t.Y))
<
		Output:
>
		[18, 10]
<
Zip({list1}, {list2})				*librelalg.Zip()*
		Build a tuple by "zipping" the attributes in {list1} with the
		values in {list2}. For example:
>
		const t = Zip(['A', 'B'], [7, 'v'])
		echo t
<
		outputs:
>
		{A: 7, B: 'v'}
<
 vim:tw=78:ts=8:noet:ft=help:norl:
