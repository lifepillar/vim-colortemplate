*libtinytest.txt*	For Vim version 9.0	Last change: 2023 Jul 17

Note: Vim 9.0.1501 or later is recommended.

Tiny Test is a minimalist unit testing library for Vim 9 script developers.
A unit test is just a function without arguments and return value whose
name starts with `Test`. Typically, tests contain Vim assertions (see
|assert-functions-details|). For instance:
>
	vim9script

	import 'libtinytest.vim' as tt

	def Test_OnePlusOneIsTwo()
	  assert_equal(2, 1 + 1)
	enddef

	const success = tt.Run()
<
The tests may also be sourced (not imported!) from a separate file:
>
	vim9script

	import 'libtinytest.vim' as tt
	source <sfile>:h/my_tests.vim

	const success = tt.Run()
<
If the imported file executes `Run()` the tests will be executed twice, once
when sourcing the script and another time by `tt.Run()`. To avoid that, set
`dryrun` to `true` before sourcing the tests, and set it back to `false`
afterwards:
>
	vim9script

	import 'libtinytest.vim' as tt

	tt.dryrun = true
	source <sfile>:h/my_tests.vim
	tt.dryrun = false

	const success = tt.Run()
<
The output always appears in a new scratch buffer.

Obviously, all the names that are used in tests must be visible to the tests.
Names that are exported by the script to be tested can be imported in the test
script. Sometimes, however, it is convenient to be able to test the private,
not exported, components of a script. To do so, the tests must be inlined in
the script itself. A variation of the following structure can serve the
purpose:
>
	vim9script

	# Here goes the code to be tested

	if !get(g:, 'test_mode', false)
	  finish
	endif

	import 'libtinytest.vim' as tt

	# Write the tests here
<
Then, to run the tests just set `g:test_mode` to `true` and source the script.

Functions ~

					*libtinytest.AssertApprox()*
AssertApprox({expected}, {num}[, {rtol}, {atol}])
		Check that {num} is approximately equal to the {expected}
		value, where "approximately" means within the relative
		tolerance {rtol} or within the absolute tolerance {atol} (or
		both).

		The default relative threshold is 0.001 (1â€° tolerance), and
		the default absolute tolerance is 0.0. So, by default only the
		relative threshold matters.

		For example:
>
		AssertApprox(1.0, 1.00001)          # OK
		AssertApprox(1.0, 1.01)             # Fails
		AssertApprox(10.0, 11.0, 0.1)       # Relative tolerance OK
		AssertApprox(10.0, 11.0, 0.0, 1.0)  # Absolute tolerance OK
		AssertApprox(10.0, 11.0, 0.05)      # Fails
		AssertApprox(10.0, 11.0, 0.05, 0.9) # Fails

<
AssertFails({func}, {msg})		*libtinytest.AssertFails()*
		Check that {func} throws an error that contains the string
		{msg}. {func} must be a function or lambda with no arguments
		and no return value. For example this assertion succeeds:
>
		AssertFails(() => {
		    throw 'This is a fatal error'
		}, 'fatal')
<
		This assertion fails because the function does not throw any
		error:
>
		AssertFails(() => {
		    return
		}, 'err')
<
		And this assertion fails because the thrown error does not
		contain the expected text:
>
		AssertFails(() => {
		    throw 'This is a silly error'
		}, 'fatal')
<
Round({num}, {digits})			*libtinytest.Round()*
		Round the given number to the specified number of {digits}.
		For example:
>
		echo Round(4.54898, 2)  # 4.55
<
Run([{pattern}])			*libtinytest.Run()*
		Run all the tests. If {pattern} is given, run only the tests
		matching {pattern}. For instance, to run only the tests
		containing `ABC`, you may write:
>
		const success = Run('ABC')
<
		This will run `Test_ABC_Foo()` and `TestABCBar()`, but not
		`Test_XYZ()`.

Options ~

					*g:tinytest_highlight*

Flag to enable or disable syntax highlighting in the output.
>
	g:tinytest_highlight = true
<
 vim:tw=78:ts=8:noet:ft=help:norl:
