*librelalg.txt*	For Vim version 9.0	Last change: 2022 Dec 3

This library is an implementation of Relational Algebra in Vim 9 script.

1. Tutorial				|librelalg-tutorial|
2. Defining a database			|librelalg-ddl|
3. Manipulating a database		|librelalg-dml|
4. Relational Algebra			|librelalg-ra|

==============================================================================
1. Tutorial					*librelalg-tutorial*

Suppose that you want to write a script that keeps track of “tags” associated
to each buffer. Since data is king, a good place to start is by defining
a (Relational) *data* *model* for your script. Suppose that, after carefully
evaluating the requirements for your script, your model looks like this (using
standard IDEF1X notation):
>
	 Buffer
	┌───────────────┐
	│ BufId     Int │
	├───────────────┤
	│ BufName   Str │ AK
	└───────┬───────┘
	        │
	  is tagged by /
	    appears in
	        │
	 Tag    ●
	╭───────────────╮
	│ BufId     Str │ FK
	│ TagName   Str │
	├───────────────┤
	│ Line      Int │ (1)
	│ Column    Int │ (1)
	╰───────────────╯
	(1) Lines and columns must be greater than zero.
<
Note: IDEF1X is the ISO standard for Relational modelling (ISO/IEC/IEEE
31320-2). The ISO document is not available for free, but the sections
relevant for Relational modelling are derived (essentially verbatim) from the
older FIPS 184 (https://archive.org/details/federalinformati184nati/). Despite
its age, the latter document, and its Annex A in particular, is a good
description of the methodology.

If you are not familiar with IDEF1X or similar diagramming tools, each box
represents an *entity* (your script will deal with “buffers” and “tags”). Each
entity has a name, written above the box, and attributes, which are written
inside the box. The attributes will be the actual pieces of data stored and
manipulated by your script. Each box also contains a separator line: the
attributes above the separator form the *primary* *key* of the entity—that is,
the main identifier of each entity instance; the attributes below the
separator are further descriptors of the entity.

Entities are connected by *relationships* represented by lines joining two
entities. The above diagram contains a one-to-many relationship, the dot
representing the “many” side: such relationship establishes that each buffer
is possibly associated to many tags, but each tag is always associated to one
and only one buffer. The entity on the “one” side of the relationship (Buffer,
in this example) is called the *parent* entity; the entity on the “many” side
of the relationship (Tag, in this example) is called a *child* entity. Each
relationship is described by two verb phrases separated by a slash: the first
verb phrase is read from parent to child (in this example: “A buffer is tagged
by zero or more tags”); the second is read from child to parent (“a tag
appears in one buffer”).

AK stands for Alternate Key, and FK stands for Foreign Key. An alternate key
is an alternative identifier for the entity: in this example, it is assumed
that no two buffers share the same `BufName`, so `BufName` could be used to
identify a buffer, as well as `BufId`. A foreign key is the primary key of
a parent entity, which is “migrated” into the child entity by virtue of its
relationship with the parent. When a foreign key is entirely part of the
primary key of the child (as in this example), the child entity is *dependent*
on its parent: in this example, that means that it is not possible to
designate a tag without referencing the buffer to which the tag belongs
(dependent entities are drawn as rectangles with rounded corners, although the
rounded corners may not be particularly prominent in the extended ASCII
rendition above). In this example, Buffer is an *independent* entity: the
existence of a buffer does not depend on anything else in this model. The
distinction between independent and dependent entities has a number of
implications: among the rest, it determines the order in which the database is
populated (you cannot insert tags before inserting the corresponding buffers).

To summarize, the diagram above captures the following facts:

- Buffer is independent;
- a buffer is identified by BufId;
- a buffer is alternatively identified by BufName;
- a buffer is tagged by zero or more tags;
- Tag is dependent on Buffer;
- a tag is identified by {BufId, TagName, Line};
- a tag is described by {Column};
- a tag appears in one (an only one) buffer.
- a tag's line must be an integer greater than zero.
- a tag's column must be an integer greater than zero.

The last two constraints derive from footnote (1) in the data model.

Data Definition ~

Once your data model is defined, translating it into code is a relatively
straightforward task:

1. Import the library and optionally define aliases for the imported items you
   are going to use:
>
	vim9script

	import 'librelalg.vim' as ra

	const Bool     = ra.Bool
	const Int      = ra.Int
	const Str      = ra.Str
	const Relation = ra.Relation
	const Insert   = ra.Insert
        # etc.
<
   Note: in the following, for clarity and conciseness, we will write
   librelalg's names without prefix, as if aliases such as those above had
   been defined for all the imported items.

2. Define one *base* relation for each entity:
>
	var Buffer = Relation('Buffer', {
	    BufId:   Int,
	    BufName: Str,
	  },
	  [['BufId'], ['BufName']]
	)

	var Tag = Relation('Tag', {
	    BufId:   Int,
	    TagName: Str,
	    Line:    Int,
	    Column:  Int,
	  },
	  [['BufId', 'TagName']]
	)
<
   The three mandatory arguments of `Relation()` are the relation name, the
   relation schema, which is a dictionary mapping attribute names to the
   corresponding data types, and the keys.

   Note: librelalg does not explicitly distinguish between a primary key and
   the alternate keys. The first listed key can be considered the primary key:
   in general, the first listed key should be the smallest and/or the most
   frequently used, because in some cases librelalg internally uses the first
   key for fast lookups.

   Note: an index is built for each key. The indexes help speed up some
   operations and are used to enforce key constraints. The order of the
   attributes in a compound key matters for performance. In the example above,
   if tags are often looked up by name, it may be more efficient to define the
   primary key as `['TagName', 'BufId', 'Line']` rather than `['BufId',`
   `'TagName', 'Line']` as was done above. In general, the attributes that are
   accessed more frequently should appear earlier in the key.

   Note: the value returned by `Relation()`, which in this document is
   referred to as a *relation* *object* or simply as a “relation”, is a complex
   object consisting of the relation instance itself (that is, the set of
   tuples) plus its schema, keys, constraints, and indexes. If you want to
   retrieve just the relation instance, you may access the `instance`
   attribute of the relation object (e.g., `Tag.instance`).

3. Add the relevant constraints:
>
	def PositiveLineColumn(t: dict<any>): void
	  if t.Line < 1 || t.Column < 1
	    throw 'Invalid line or column number'
	  endif
	enddef

	Check(Tag, PositiveLineColumn)

	ForeignKey(Tag, ['BufId'], Buffer, ['BufId'], 'is tagged by')
<
   A `Check` clause defines a generic constraint, which is simply a function
   that takes as input a tuple and throws an error if the tuple does not
   satisfy a certain condition. `ForeignKey()` defines a foreign key
   constraint from `BufId` in `Tag` to `BufId` in `Buffer`. The verb
   associated to the constraint (as read from the parent to the child entity
   in the data model) can be optionally specified: the verb phrase is used in
   error messages when the referential integrity is violated.

   Note: constraints are checked in the order in which they are added to
   a relation.

Data Manipulation ~

When the database is defined, you may start populating each base relation with
tuples. Each tuple is just a dictionary conforming to the corresponding
relation schema. Try inserting a buffer and a couple of tags:
>
	Buffer->Insert({BufId: 1, BufName: 'foobar'})

	Tag->InsertMany([
	  {BufId: 1, TagName: 'abc', Line: 3, Column: 9},
	  {BufId: 1, TagName: 'xyz', Line: 4, Column: 4},
	])
<
If you want to inspect the content of a relation, you may print the
corresponding table:
>
	echo Table(Buffer)
	echo Table(Tag)
<
Of course, any attempt to violate a constraint is rejected with an error.
Trying to insert another buffer called `foobar` will fail with a duplicate key
error:
>
	Buffer->Insert({BufId: 2, BufName: 'foobar'})

	# Duplicate key value: ['BufName'] = ('foobar') already exist
<
because `BufName` is a key. Referential integrity is also guaranteed. For
instance:
>
	Tag->Insert({BufId: 5, TagName: 'x', Line: 3, Column: 9})
<
will raise:
>
	Buffer is tagged by Tag: Tag['BufId'] = (5) is not present in Buffer['BufId']
<
And, of course, you are not allowed to insert an invalid line number either:
>
	Tag->Insert({BufId: 1, TagName: 'x', Line: 0, Column: 40})
<
This insertion is rejected with:
>
	Invalid line or column number
<
Updates and deletions are possible, too:
>
	Tag->Update({BufId: 1, TagName: 'abc', Line: 7, Column: 12})
	echo Table(tag)
	Tag->Delete((t) => t.Line < 5)
	echo Table(tag)
<
For updates, you just pass the updated tuple: a tuple with the same key must
exist in the relation, otherwise you will get an error. That implies that only
attributes that are not part of any key (that is, pure descriptors) can be
updated: if you want to update a key attribute, you must delete the
corresponding tuple and insert a new one.

Note: this may seem an unnecessary restriction, but, besides keeping the
implementation somewhat simple, it is conceptually a sound approach: a key
represents the identity of an entity, and identity is immutable. So, if you
want to change a key, in fact you want to refer to another entity. Hence, you
have to delete the old entity and add a new one.

For deletions, you provide a predicate (typically, in the form of a lambda)
that the tuples to be deleted must satisfy.

Queries ~

The power of Relational Algebra lies in its powerful query language as well as
in the simplicity of its data structures: librelalg provides all the
fundamental operations (set operations, selection, projection, joins,
renaming) as well as some extra operations (division, semi-joins, anti-joins,
group-by). All operators are implemented using a "push-based" strategy:
without entering into technical details, that means that queries are typically
expanded into tight loops and executed as efficiently as hand-written code.

There are three types of operators:

- "root" operators: these take as input a relation instance and emit tuples;
- "leaf" operators: these collect tuples and build a relation instance;
- "pipeline" operators: these process tuples and emit (transformed) tuples.

The most important rule is that each query should start with a root operator
and should end with a leaf operator. A query may chain zero or more
intermediate pipeline operators.

The only root operator is `Scan()` (with `Foreach()` as a synonym). The most
common leaf operator is `Build()` (you may use `Materialize()` or `Query()` as
synonyms). Other leaf operators are `Sort()` and `SortBy()`.

For instance, the query “Retrieve the tags in buffer 1 before line 6” can be
formulated as follows:
>
	const result = Scan(Tag)
	             ->Select((t) => t.BufId == 1 && t.Line <= 6)
		     ->Build()
	echo Table(result)
<
The `Scan()` function iterates over each tuple of the `Tag` relation and
passes it to the next operator (we usually say that `Scan()` "emits" the
tuples of its input relation). The next operator in this example is
`Select()`, which applies the given function (a lambda in this example) to
each received tuple, and emits only the tuples for which the function returns
true. Finally, `Build()` gathers each tuple as it receives it and builds
a *derived* relation instance, which is the query result (we usually say that
`Build()` "consumes" the received tuples and "materializes" a relation
instance).

Note: strictly speaking, Relational Algebra operators act on relation
instances. So, the above query should be written:
>
	const result = Scan(Tag.instance)->etc...
<
As a convenience, however, librelalg's operators accept relation objects, too:
they access the relation instance internally. The result of a query, however,
is always a relation instance (see below).

Note: the result of a query is just a set of tuples (implemented as a list of
dictionaries). Contrary to base relations, such derived relations do not have
any associated keys, constraints or indexes.

Note: Other ways to write the query above, using the synonyms, are the
following:
>
	Query(Scan(Tag)->Select((t) => t.BufId == 1 && t.Line <= 6))
	Foreach(Tag)->Select((t) => t.BufId == 1 && t.Line <= 6)->Materialize()
	Materialize(Scan(Tag)->Select((t) => t.BufId == 1 && t.Line <= 6))
<
When writing queries, chaining operators with `->` is typically more
intuitive, but you may use the style and the synonyms you prefer. Although
`Query()`, `Build()`, and `Materialize()` have the same meaning, `Query()` is
typically used in prefix form, and `Build()` is used when chaining operators;
`Materialize()` can be used in both cases, but it is more verbose.

If you just wanted to access only the tag names and corresponding lines, you
might just pipe a projection operator, too:
>
	const filteredTags = Scan(Tag)
	                   ->Select((t) => t.BufId == 1 && t.Line <= 6)
	                   ->Project(['TagName', 'Line'])
	                   ->Build()
<
Pipelining is straightforward for unary operators. But, what if you want to
perform a join or perform some other binary operation? Pipelining can still be
used, but one of the arguments must be a base or derived relation. For
example, the natural join of `Buffer` and `Tag` can be written as follows:
>
	const btags = Scan(Buffer)->NatJoin(Tag)->SortBy(['TagName'])
        echo Table(btags, 'Buffer tags')
<
In this query, `SortBy()` has been used as a leaf operator, which builds the
output as `Build()` does, but sorted according to the specified attribute(s).
Of course, since the natural join is commutative, the same query can be
equivalently written as follows:
>
	const btags = Scan(Tag)->NatJoin(Buffer)->SortBy(['TagName'])
<

==============================================================================
2. Defining a database				*librelalg-ddl*

==============================================================================
3. Manipulating a database			*librelalg-dml*

==============================================================================
4. Relational Algebra				*librelalg-ra*

To better understand how the functions described in this section work, we will
make use of the following terminology:

- an *attribute* is just a |string|.
- A *tuple* is a |'dictionary'| mapping attributes to values. Values can be
  strings, numbers, booleans, etc.
- A *relation* *instance* is a |list| of tuples.
- A *relation* *object* or simply a *relation* is an object built with
  |librelalg.Relation()|.
- A *consumer* is any function with signature: func({tuple}): void.
- A *continuation* is any function with signature: func({consumer}): void.

Intuitively, a consumer is a function that operates in some way on a tuple,
typically by invoking a continuation. A continuation receives as input
a consumer and applies it to one or more tuples.

This is best described with an example. Consider the following simple query:
>
	Scan(relation)->Select(Pred)->Build()
<
When executed, |librelalg.Scan()| will return a continuation that looks as follows:
>
	def ContScan(Emit: func(Tuple): void): void
	  for t in relation
	    Emit(t)
	  endfor
	enddef
<
where `Emit()` is a consumer. Most operators, except the root operators, take
a continuation as an argument, and either build another continuation (if they
are pipeline operators) or materialize a relation (if they are leaf
operators). In the example above, |librelalg.Select()| receives as input the
continuation `ContScan` returned by |librelalg.Scan()| and a predicate
function `Pred`: it will then return another continuation, defined as follows:
>
	def ContSelect(Emit: func(Tuple): void): void
	  def ConsumerSelect(t: Tuple)
	    if Pred(t)
	      Emit(t)
	    endif
	  enddef
	  ContScan(ConsumerSelect)
	enddef
<
In practice, the Select operator will define a consumer to filter the tuples
according to the input predicate, and will then apply its input continuation
to that consumer.

Finally, the leaf operator |librelalg.Build()| receives as an input the
continuation `ContSelect` generated by the Select operator and applies it to
build a new relation instance, using code similar to the following:
>
	var rel: list<Tuple> = []

	def ConsumerBuild(t: Tuple)
	  add(rel, t)
	enddef

	ContSelect(ConsumerBuild)
<
Again, what the operator does is define a consumer and then apply its input
continuation to that consumer.

The original chained call:
>
	Scan(relation)->Select(Pred)->Build()
<
may now be "unrolled" starting from `ContSelect(ConsumerBuild)`. If you try
expanding the call, the result of such "unrolling" will be a loop similar to
this:
>
	for t in relation
	  if Pred(t)
	    add(rel, t)
	  endif
	endfor
<
which is pretty much what one would have written by hand (short of using
a built-in function such as |filternew()|, that is). Of course, for such
a contrived example, there is little to no benefit in using Relational Algebra
compared to Vim built-in functions. But for more complex queries, one can
obtain the desired output with much more compact code, without giving up on
performance.

Scan({rel})					*librelalg.Scan()*
		Returns a continuation that iterates over the tuples of {rel}
		and emits each tuple. This is a root operator, that is, an
		operator that starts a query.

Foreach({rel})					*librelalg.Foreach()*
		A synonym of |librelalg.Scan()|.

Build({cont})					*librelalg.Build()*
		Materializes a relation. This is a leaf operator, which
		returns a relation instance.

Query({cont})					*librelalg.Query()*
		A synonym of |librelalg.Build()|.

Materialize({cont})				*librelalg.Materialize()*
		A synonym of |librelalg.Build()|.

Sort({cont}, {func})				*librelalg.Materialize()*
		Materializes a relation by sorting the tuples according the
		criterion specified by {func}. {func} is a function that takes
		as input two tuples t1 and t2, and returns -1, 0, or 1 according to
		whether t1 precedes t1, t1 equals t2 or t1 follows t2. for
		instance, to sort a relation `R` with respect one of
		its attributes, say `A`, you may write:
>
		def CompareA(t1: dict<any>, t2: dict<any>): number
		   return t1.A < t1.A ? -1 : t1.A > t2.A ? 1 : 0
		enddef

		const result = Scan(R)->Sort(CompareA)
<
		See also |librelalg.SortBy()|.

SortBy({cont}, {list})				*librelalg.SortBy()*
		Materializes a relation by sorting the tuples according the
		specified list of attributes. For instance:
>
		const result = Scan(R)->SortBy(['A', 'B'])
<
		will sort the tuple of `R` with respect to `A` and, for tuples
		with the same value of `A`, with respect to `B`.


 vim:tw=78:ts=8:noet:ft=help:norl:
