*colortemplate.txt*	For Vim version 8.1	Last change: 2019 May 27

	  .,-:::::     ...      :::         ...    :::::::.. :::::::::::: ~
	,;;;'````'  .;;;;;;;.   ;;;      .;;;;;;;. ;;;;``;;;;;;;;;;;;'''' ~
	[[[        ,[[     \[[, [[[     ,[[     \[[,[[[,/[[['     [[ ~
	$$$        $$$,     $$$ $$'     $$$,     $$$$$$$$$c       $$ ~
	`88bo,__,o,"888,_ _,88Po88oo,.__"888,_ _,88P888b "88bo,   88, ~
	  "YUMMMMMP" "YMMMMMP" """"YUMMM  "YMMMMMP" MMMM   "W"    MMM ~
	.,::::::  .        :::::::::::. :::      :::. ::::::::::::.,:::::: ~
	;;;;''''  ;;,.    ;;;`;;;```.;;;;;;      ;;`;;;;;;;;;;'''';;;;'''' ~
	 [[cccc   [[[[, ,[[[[,`]]nnn]]' [[[     ,[[ '[[,   [[      [[cccc ~
	 $$""""   $$$$$$$$"$$$ $$$""    $$'    c$$$cc$$$c  $$      $$"""" ~
	 888oo,__ 888 Y88" 888o888o    o88oo,.__888   888, 88,     888oo,__ ~
	 """"YUMMMMMM  M'  "MMMYMMMb   """"YUMMMYMM   ""`  MMM     """"YUMMM ~

	The Toolkit for Color Scheme Designers!
	Author:  Lifepillar <https://github.com/lifepillar>
	License: Same terms as Vim itself (see |license|)
==============================================================================
CONTENTS					*ft-colortemplate*

    1. Introduction ......... |colortemplate-intro|
    2. Getting started ...... |colortemplate-quickstart|
    3. Templates' structure . |colortemplate-structure|
    4. Metadata block ....... |colortemplate-meta|
    5. Backgrounds .......... |colortemplate-background|
    6. Variants ............. |colortemplate-variants|
    7. Color definitions .... |colortemplate-colors|
    8. Terminal colors ...... |colortemplate-termcolors|
    9. Highlight groups ..... |colortemplate-hi-groups|
   10. Verbatim blocks ...... |colortemplate-verbatim|
   11. Documentation blocks . |colortemplate-doc-blocks|
   12. Auxiliary files ...... |colortemplate-auxfiles|
   13. Include directive .... |colortemplate-include|
   14. Colors statistics..... |colortemplate-stats|
   15. Mappings ............. |colortemplate-mappings|
   16. Options .............. |colortemplate-options|
   17. Commands ............. |colortemplate-commands|
   18. Window toolbar ....... |colortemplate-toolbar|
   19. Functions ............ |colortemplate-functions|
   20. Best practices ....... |colortemplate-best-practices|
   21. Providing feedback ... |colortemplate-feedback|

==============================================================================
Color templates					*colortemplate-intro*

A colortemplate file is designed to help users create their own color schemes
without much effort. It can also be used to create color schemes suitable for
distribution with Vim. Color schemes created using a colortemplate have the
following features:

- they support (at least) 256-color terminals, true color terminals and gVim;
- they have a consistent structure, they are guaranteed to follow best
  practices and they load quickly;
- they can be easily customised by the user;
- they are licensed under the Vim license by default.

==============================================================================
Getting Started					*colortemplate-quickstart*

To get started quickly, |:edit| `templates/dark.colortemplate`, which is
located in colortemplate's plugin folder, and type:
>
	:Colortemplate ~/.vim
<
If you use Vim 8.0.1123 or later, you may also execute commands by clicking on
a window toolbar. Click on "OutDir" and set the output directory to `~/.vim`,
then click on "Build!" to create the color scheme.

Note: |:Colortemplate| gives an error if the color scheme already exists at
the given location (`~/.vim/colors` in the example above): use
`:Colortemplate!` to overwrite existing files. Vice versa, the "Build!" menu
silently overwrites any existing file.

If there are errors in your template, they are shown in the quickfix window.
If the template builds successfully, Colortemplate tells you so with a message
in the command line.

To view how the generated color scheme looks like, you may use |:colorscheme|
or click on "Show" in the toolbar (the dark template uses only black and
white, so it does not stand out as a catchy color scheme). If you click on
"Show" you may switch back to the original color scheme with "Hide".

You may validate your color scheme against
`$VIMRUNTIME/colors/tools/check_colors.vim` with |:ColortemplateCheck| or by
clicking on "Check" in the toolbar. If there are no issues, you will see this
message:
>
	---------------
	    colors_name: OK
	---------------
<
You may compute some statistics about the colors used by your theme with
|:ColortemplateStats| or by clicking on `Stats` in the toolbar. For more
details, see |colortemplate-stats|. By clicking on `Source` you may edit the
generated color scheme.

You may use `dark.colortemplate`, `light.colortemplate` or
`dark_and_light.colortemplate` as starting points for creating your own color
scheme. The process is divided in five steps:

1. start by editing your color scheme's information;
2. define a color palette;
3. define the necessary highlight groups;
4. document your color scheme's options, if any;
5. build your color scheme.

If you want to start from scratch instead of using one of the predefined
templates, set the modeline in your template to
>
	# vim: ft=colortemplate

==============================================================================
Templates' structure				*colortemplate-structure*

A template consists of:

1. metadata;
2. `Color` and `Term colors` definitions;
3. `Background` and `Variant` directives;
4. `Include` statements;
5. verbatim blocks (`verbatim`/`auxfile`/`documentation`, `#if`, `#let`, ...);
6. highlight group definitions;
7. line comments (starting with `#`), which are ignored by Colortemplate.

Each template has one global section and one or more local sections. The
global section goes from the beginning of the file until the first
`Background` or `Variant` directive is encountered. The global section may
contain anything except highlight group definitions (linked group definitions
are allowed, though). When translated, linked group definitions and verbatim
blocks in the global section appear at the start of the generated color
scheme. This is useful if you need to set up your color scheme in some way or
override some variables. For example, Colortemplate defines two script
variables inside color schemes, called `s:t_Co` and `s:italics`. If you want
to override their default value, you may do so in the global section.

A local section starts at a `Background` or `Variant` directive and lasts
until the next `Background` or `Variant` directive. Each local section
contains the highlight group definitions and `verbatim` blocks that apply to
the current backgrounds and variants. A local section may also contain `Color`
definitions that apply to the current backgrounds. For instance, if a template
contains these two lines:
>
	Variant: gui 256
	Background: dark
<
anything that follows until the next `Variant` or `Background` directive or
until the end of the file will be applied to the dark version of GUI and
256-color variants of your color scheme. `Variant` and `Background` may appear
several times in the same template. Combining them gives you great
flexibility, e.g.:
>
	Variant: gui
	Background: any
	  # Defs. for both backgrounds, apply only to GUI
	Background: dark
	  # Defs. or dark background, apply only to GUI
	Variant: gui 256 16
	  # Defs. for dark background, apply to GUI/256/16 colors
	Background: any
	  # Defs. for both backgrounds, apply to GUI/256/16 colors
	Background: light
	Variant: 16
	  # Defs. for light background, apply only to 16 colors
<
A template like the above will generate code with the following structure:
>
	let s:t_Co = ...
	if [has termguicolors set or is GUI vim]
	  # Defs. for both backgrounds, apply only to GUI
	  # Defs. for both backgrounds, apply to GUI/256/16 colors
	  if &background ==# 'dark'
	    # Defs. for dark background, apply only to GUI
	    # Defs. for dark background, apply to GUI/256/16 colors
	    finish
	  endif
	  finish
	endif
	if s:t_Co >= 256
	  # Defs. for both backgrounds, apply to GUI/256/16 colors
	  if &background ==# 'dark'
	    # Defs. for dark background, apply to GUI/256/16 colors
	    finish
	  endif
	  finish
	endif
	if s:t_Co >= 16
	  # Defs. for both backgrounds, apply to GUI/256/16 colors
	  if &background ==# 'dark'
	    # Defs. for dark background, apply to GUI/256/16 colors
	    finish
	  endif
	  # Defs. for light background, apply only to 16 colors
	  finish
	endif
<	   
Note how the code is reordered. In particular, code in the scope of `any`
background is put before the background is checked, for each variant to which
it applies (the "local preamble" of each variant).

==============================================================================
Metadata block					*colortemplate-meta*

Information about a color scheme consists of the following mandatory and
optional fields:
>
	# Mandatory information
	Full name:       A unique and attractive name
	Short name:      all_lowercase_with_no_spaces
	Author:          Myself <myself@somewhere.org>

	# Optional information
	Maintainer:      [Uses Author's value by default]
	Website:         [Empty]
	Description:     [Empty]
	License:         [Vim license]
	Option Prefix:   [Uses Short name's value by default]
	Neovim:          [No]
<
The default value for optional fields in shown in square brackets. All the
fields should be self-descriptive. When `Neovim` is set to `yes` or `1` then
additional code is generated to support NeoVim.

==============================================================================
Color scheme background				*colortemplate-background*

You must specify whether color definitions and highlight group definitions
apply to a dark background, to a light background or to any background. You do
so with a `Background` directive, which may have one of three values:
>
	Background: dark
	Background: light
	Background: any
<
All definitions appearing after a `Background` directive until the end of the
file or until another `Background` directive apply to the specified
background(s).

If only one background is mentioned in the template, the generated color
scheme will have a command to set it accordingly, e.g.:
>
	set background=dark
<
If the template uses both backgrounds then the generated color scheme will
adapt to the current background, e.g., the generated code will be equivalent
to:
>
	" Local preamble here
	if &background ==# 'dark'
	  " Dark variant of the color scheme
	else
	  " Light variant of the color scheme
	endif
<
Template code in the scope of `any` background will be put in the "local
preamble", i.e., before checking the value of |background|.

==============================================================================
Variants					*colortemplate-variants*

A `Variant` directive declares to which environments the subsequent
definitions apply. All definitions appearing after a `Variant` directive until
the end of the file or until another `Variant` directive apply to the
specified variant(s).

The permitted values are `gui` (for GUI versions of Vim or Vim with
|termguicolors| set) or a number between `1` and `256` specifying the minimum
|t_Co| required for the following definitions. Multiple values in the same
directive are allowed, separated by spaces.

For example, consider the following snippet:
>
	Color: white #ffffff 231 White
	Color: black #000000 16 Black
	Color: ivory #ebebeb 255 LightGray
	Color: dust  #343436 236 Brown

	Variant: gui 8
	Normal ivory dust
	Variant: 256
	Normal white black
<
This will be translated into something similar to this:
>
	if (has('termguicolors') && &termguicolors) || has('gui_running')
	  hi Normal guifg=#ebebeb guibg=#343436 guisp=NONE gui=NONE cterm=NONE
	  finish
	endif

	if &t_Co >= 256
	  hi Normal ctermfg=231 ctermbg=16 cterm=NONE
	  finish
	endif

	if &t_Co >= 8
	  hi Normal ctermfg=LightGray ctermbg=Brown cterm=NONE
	  finish
	endif

Text before the first `Variant` directive, but after a `Background` directive,
applies by default to `gui` and `256` color variants. This rule exists mostly
for backward compatibility: it is recommended to always use `Variant`
explicitly.

==============================================================================
Color definitions				*colortemplate-colors*

Color definitions consist of lines with the following syntax:
>
	Color: <Name> <GUI spec> <Base-256 spec> <Base-16 spec>

For example:
>
	Color: red  #e64547  167  DarkRed
<
The name is an arbitrary string (only letters, numbers and underscore
allowed). Color definitions that appear before all `Background` directives or
are in the scope of `Background: any`, are assumed to apply to any background.
Color definitions in the scope of `Background: dark` or `Background: light`
apply only to the specified background. So, you may have two different colors
with the same name for light and dark background. You may not have different
colors with the same name for different variants, though: as far as color
definitions are concerned, `Variant` directives are ignored.

The `<GUI spec>` may be given as a hexadecimal value, as in the example above,
or as an RGB value. Standard color names from `$VIMRUNTIME/rgb.txt` may be
used as well, although their use is discouraged. For instance:
>
	Color: white  rgb(255,255,255)  206  White
	Color: gold   dark goldenrod    136  Brown
<
The `<Base-256 spec>` and `<Base-16 spec>` fields are used for terminals that
do not support more than 256 colors, or when |termguicolors| is not set. For
variants with at least 16 colors, the base-256 values are used; base-16 values
are used for variants with less than 16 colors. The color numbers must not
exceeed the limits imposed by the current variants. For example, if you
declare:
>
	Variant: 256 88
<
then you may use only base-256 colors between `0` and `87`. On the other hand,
if you declare:
>
	Variant: 256 8 4
<
you will be able to use all base-256 colors, but only the first four base-16
colors.

In general, only the GUI value of a color specification is necessary. Base-256
values may be replaced by a `~` symbol, which means that the color should be
inferred automatically from the GUI value. Base-16 values may be omitted
entirely: it is safe to do so when no variant with less than 16 colors is
used. So, a minimal color definition looks as follows:
>
	Color: black #000000 ~
<
==============================================================================
Terminal colors					*colortemplate-termcolors*

The 16 ASCII colors for Vim terminal windows should be specified using
a `Term colors` directive:
>
	Term colors: myblack myred mygreen myyellow
	Term colors: myblue mymagenta mycyan mywhite
	Term colors: mybrightblack mybrightred mybrightgreen mybrightyellow
	Term colors: mybrightblue mybrightmagenta mybrightcyan mybrightwhite
<
The directive may be repeated, but it must define 16 colors in total, in the
order in which they should be assigned to the terminal.

==============================================================================
Highlight group definitions			*colortemplate-hi-groups*

Highlight group definitions consist of lines with the following syntax:
>
	<Group name> <foreground color> <background color> <style attributes>
<
For example:
>
	SpellRare  white  black  bold,reverse guisp=cyan
<
Colors must be specified using the color names defined by the `Color`
directives.

The <style attributes> part of a highlight group definition is used to specify
comma-separated lists of attributes (see |attr-list|) and the special color to
use in the GUI (|highlight-guisp|). The following are examples of valid
highlight group specifications:
>
	Normal    white   black
	DiffAdd   orange  blue   reverse
	SpellBad  white   black  guisp=red
<
The foreground and background colors must always be present. You may use the
special values `fg`, `bg`, and `none` for the default foreground color, the
default background color and for disabling the corresponding highlighting,
respectively.

Attributes specified as above are used for both |cterm| and |gui|
highlighting. If you want to use different values for the terminal and the
GUI, you must prepend `term=` or `gui=`, respectively, as is done in Vim color
schemes. For example:
>
	IncSearch  white  black  term=bold,reverse  gui=bold,standout
<
`term=` may be abbreviated `t=`, and `gui=` may be abbreviated `g=`. Instead
of `guisp=`, you may also use `s=`.

Colortemplate also supports |highlight-start| and |highlight-stop|: the syntax
is the same as in Vim color schemes.

Note: variants also determine which attributes are used. For example, if this
definition:
>
	IncSearch white black term=underline
<
is in the scope of `Variant: gui`, the `term` attribute will be ignored.

Linked groups are defined using the following syntax:
>
	<SourceGroup> -> <TargetGroup>

For example:
>
	QuickFixLine  ->  Search
<
==============================================================================
Verbatim blocks					*colortemplate-verbatim*

Colortemplate offers the possibility to add arbitrary code to a color scheme.
Code between `verbatim` and `endverbatim` is copied almost verbatim into the
output. The exception is that you may still use your color names by prepending
an @ sign: such names will be interpolated and replaced by suitable color
values. For example:
>
	verbatim
	if get(g:, 'fancyflag', 0)
	  hi! Normal ctermfg=@red guifg=@red gui=NONE,undercurl guisp=@yellow
	endif
	endverbatim
<
might be translated into something like:
>
	if get(g:, 'fancyflag', 0)
	  hi! Normal ctermfg=88 guifg=#ff6400 gui=NONE,undercurl guisp=#ffff00
	endif
<
If you need to interpolate a color that does not occur in a highlight group
definition, you must specify whether you want to interpolate a GUI value or
a terminal value by using `@gui<color>`, `@term16<color>`, or
`@term256<color>`, where `<color>` is a color name. For example:
>
	let g:terminal_color_@term16black = '@guiblack'
<
might generate the following code:
>
	let g:terminal_color_0 = '#000000'
<
Other values may be interpolated: metadata keywords, converted to lower case
and without spaces (e.g., `@shortname` may be used to insert the value of
`Short name`); `@date` (to insert the current date) and `@vimversion` (to
insert the current Vim version).

Verbatim blocks are most often used for conditionals or to set and get
variables or to invoke functions. Therefore, Colortemplate provides convenient
shortcuts for such cases. When `#if`, `#else`, `#elseif`, `#endif`, `#let`,
`#unlet` and `#call` appear at the start of a line, they act as one-line
verbatim blocks. Such directives are replaced by the corresponding Vim
commands and what follows is copied verbatim (but interpolated). So, for
instance, this template:
>
	#if get(g:, 'some_option', 0)
	  #let s:color = '@guiMyColor'
	#endif
<
is translated into
>
	if get(g:, 'some_option, '0)
	  let s:color  = '#abcef'
	endif
<
assuming `MyColor` is a color with GUI value `#abcdef`.

==============================================================================
Documentation blocks				*colortemplate-doc-blocks*

Any settings that your color scheme provides should be documented in
a documentation block. For instance, if you add a `g:mytheme_transp_bg` flag
to enable a transparent background, you may document it as follows:
>
  documentation
  ===========================================================================
  @fullname options                                *@shortname-options*

                                                   *g:@shortname_transp_bg*

  Set to 1 if you want a transparent background. Takes effect only in the
  terminal.
  >
    let g:@shortname_transp_bg = 0
  <
  enddocumentation

A documentation block starts with a `documentation` keyword and ends with
`enddocumentation`. Interpolation works as in verbatim blocks. Multiple
documentation blocks are chained together in the order in which they are
encountered.

A documentation block will generate a help file in a `doc` directory inside
the output directory. You may suppress the generation of the help file with
|g:colortemplate_no_doc|.

==============================================================================
Auxiliary files				       	*colortemplate-auxfiles*

If you want to generate additional files besides the color scheme itself, you
may put the content of each file into a separate `auxfile` block. For example:
>
	auxfile autoload/airline/themes/mycolorscheme.vim
	" Anything can go here
	endauxfile

This will write the content of the auxfile block into the specified file
(creating the intermediate directories if necessary). The path is mandatory
and must be a relative path (relative to the output directory). No comment may
appear in an `auxline` line. The content of an `auxfile` block is interpolated
as in verbatim blocks. You mau suppress the generation of all auxiliary files
(include the help file) with |g:colortemplate_no_aux_files|.

==============================================================================
Include directive		       		*colortemplate-include*

You may split your template into several files, and include snippets from one
file into another. You do so with an `Include` directive. For example, you
might put the documentation of your color scheme into a separate template, say
`_help` or `_help.colortemplate`, and include it into the main template as
follows:
>
	Include: _help
<
The result is the same as if the content of `_help` or `_help.colortemplate`
had been written at the inclusion point. If the suffix of the included file is
`.colortemplate`, it may be omitted, as in the example above.

Conventionally, templates that are not meant to be used directly, but only
included into other templates, have names starting with an underscore.

You may include the same file more than once. This is useful, for example, if
you have highlight group definitions that are common to a dark and light
background. Then, you may put them into a `_common` file, and include it
twice:
>
	Background: dark
	Include: _common
	# Other definitions specific to dark background
	Background: light
	Include: _common
	# Other definitions specific to light background
<
NOTE: avoid cyclic inclusions: they will cause Colortemplate to run into an
infinite loop!

==============================================================================
Colors statistics				*colortemplate-stats*

Colortemplate can compute some useful statistics to help you assess the
quality of your color scheme. Such information is displayed in a scratch
buffer in a split window by |:ColortemplateStats| or by clicking on "Stats" in
the window toolbar. The following statistics are provided.

Color similarity table ~
A color similarity table contains a detailed summary of the generated color
values, presented in the following form:
>
  red: GUI=#9e0006/rgb(158,0,6) Term=88 #870000/rgb(135,0,0) [delta=4.473285]
<
Here, the delta value is the distance between the GUI value (`#9e0006`) and
the corresponding terminal color (`88`). The used distance is a sophisticated
variant of the CIELAB ΔE* metric, which takes into account the perceptual
characteristics of the human eye. Roughly speaking, colors at distance less
than 2.3 correspond to "just noticeable differences". The greater the
distance, the greater the discrepancy between the GUI color and its base-256
counterpart.

Keep in mind that the "most similar" terminal color may not necessarily be the
"best looking" color, because the overall look&feel of a color scheme
ultimately depends on the interactions among all the colors.

Critical pairs ~
Pairs of colors that are used as a foreground/background combo by at least one
highlight group and have contrast ratio less than 3.0 (as per ISO-9241-3) are
reported in this section, for exact colors and for xterm approximations. For
each pair of colors, its contrast ratio (CR), color brightness (CB) and color
difference (CD) are shown (see below), and the highlight groups using such
pair are listed in the following line. Generally speaking, pairs of fg/bg
colors with low contrast ratio may be acceptable if they are used for
decorative elements (e.g., for |hl-VertSplit|), but should be avoided for
text, and especially for |hl-Normal|.

Contrast ratio matrix ~
The contrast ratio statistics compares the relative luminance of two colors.
This is useful, in particular, to determine whether there is enough contrast
between a foreground color and the background. Values that are too low may be
problematic for people with color deficits and are highlighted. Although
Colortemplate calculates the contrast ratio for each pair of colors, you
should mostly pay attention to the pairs that are used as
a foreground/background combination in your color scheme.

ISO-9241-3 recommends at least a 3:1 contrast ratio between the foreground and
the background color. W3C's WCAG guidelines suggest 4.5:1 as a minimum.

Contrast ratio ranges between 1.0 (no contrast difference) and 21.0 (maximum
contrast).

Brightness and color difference matrices ~
Two colors provide good color visibility if their brightness difference and
their color difference exceed a certain threshold. Colortemplate computes
color and brightness difference for each pair of colors in your color scheme.

Color difference ranges between 0.0 (no difference) and 765.0 (maximum
difference). At least for the Normal highlight group, the difference should be
no less than 500.

Brightness difference ranges between 0.0 (no difference) and 255.0 (maximum
difference). At least for the Normal highlight group, the difference should be
no less than 125.

==============================================================================
Colortemplate mappings				*colortemplate-mappings*

Note: the following mappings are all buffer-local. If you do not want
Colortemplate to define any mapping, set |g:colortemplate_no_mappings|.
Colortemplate also honours |g:no_plugin_maps|.

							*ga*
ga			If the cursor is on a `Color` line, display some
			information about the given color, including [count]
			best xterm approximations for the color.

							*gx*
gx			If the cursor is on a `Color` line, replace `~` with
			the [count]th best xterm approximation of the color.

							*gy*
gy			If the cursor is on a `Color` line, print the xterm
			approximations of the color at distance at most
                        [count] from the GUI value.

							*CTRL-L*
CTRL-L			Show the window toolbar and redraw the screen.

==============================================================================
Colortemplate options				*colortemplate-options*

						*g:colortemplate_creator*
Set to 0 if you do not want the `Generated by Colortemplate` comment in the
output color scheme.
>
	let g:colortemplate_creator = 1
<
						*g:colortemplate_no_aux_files*
Set to 1 if you do not want to generate any auxiliary file (including the help
file).
>
	let g:colortemplate_no_aux_files = 0
<
						*g:colortemplate_no_doc*
Set to 1 if you do not want to generate the help file.
>
	let g:colortemplate_no_doc = 0
<
						*g:colortemplate_no_mappings*
Set to 1 to suppress mappings.
>
	let g:colortemplate_no_mappings = 0
<
						*b:colortemplate_outdir*
The directory for the generated color scheme and optional auxiliary files.
This is set automatically when opening a template and is usually set to
a reasonable default. You may view and change the current value of this option
with |:ColortemplateOutdir| or by clicking on "OutDir" in the window toolbar.

						*g:colortemplate_source_comment*
Set to 0 if you do not want Colortemplate to append the source template as
comments as the end of the generated color scheme.
>
	let g:colortemplate_source_comment = 1
<
						*g:colortemplate_timestamp*
Set to 0 if you do not want a timestamp in the generated color scheme.
>
	let g:colortemplate_timestamp = 1
<
						*g:colortemplate_toolbar*
Set to 0 if you do not want to the toolbar to be visible.
>
	let g:colortemplate_toolbar = 1
<
						*g:colortemplate_toolbar_items*
A List with the names of menu entries to be used in the window toolbar. Each
menu entry must be defined in |g:colortemplate_toolbar_actions|.
>
	let g:colortemplate_toolbar_items = [
	      \ 'Build!',
	      \ 'BuildAll!',
	      \ 'Show',
	      \ 'Hide',
	      \ 'Check',
	      \ 'Stats',
	      \ 'Source',
	      \ 'HiTest',
	      \ 'OutDir',
	      \ ])
<
						*g:colortemplate_toolbar_actions*
A Dictionary mapping menu entries to the corresponding commands. For instance:
>
	let g:colortemplate_toolbar_actions = {
	     \ 'Build!': ':Colortemplate!<cr>'
	     \ }
<
This options only defines the actions associated to each label. For a menu
entry to actually be visible in the toolbar, it must be listed in
|g:colortemplate_toolbar_items| as well.

						*g:colortemplate_quiet*
Set to 0 if you want Colortemplate to open the generated color scheme in
a split window automatically after building it.
>
	let g:colortemplate_quiet = 1
<
						*g:colortemplate_warnings*
Set to 0 if you want Colortemplate to report only errors (not recommended).
>
	let g:colortemplate_warnings = 1
<
==============================================================================
Colortemplate commands		       		*colortemplate-commands*

NOTE: all the following commands are available only in buffers whose
|'filetype'| is set to `colortemplate`.

						*:Colortemplate[!]*

Creates a Vim color scheme from the template in the current buffer. If used
without arguments, the output is written in |b:colortemplate_outdir|. The
command takes an optional argument, which is an alternative path to
a directory where the output should be saved. If `!` is present, any existing
files will be overwritten.

						*:ColortemplateAll[!]*

Builds the template in the current buffer and all the other templates in the
same directory as the current buffer (if any). This is useful to build several
color schemes at once. If used without arguments, the output is written in
|b:colortemplate_outdir|. The command takes an optional argument, which is an
alternative path to a directory where the output should be saved. If `!` is
present, any existing files will be overwritten.

						*:ColortemplateCheck*

Runs a series of checks on the generated color scheme using Vim's validation
script `$VIMRUNTIME/colors/tools/check_colors.vim`.

						*:ColortemplateOutdir*

Prints the current value of |b:colortemplate_outdir| and prompts for a new
path. Leave empty and press Enter or press Esc if you do not want to change
the path.

						*:ColortemplateStats*

Computes some color statistics and shows them in a scratch buffer.
See |colortemplate-stats| for more information.

==============================================================================
Window toolbar		       			*colortemplate-toolbar*

The window toolbar (|WinBar|) is available in Vim 8.0.1123 or later and
provides a quick way to execute the most common tasks, streamlining your
workflow. The toolbar appears automaticaly when you open a template file whose
name does not start with an underscore.

A close button is present at the rightmost end of the toolbar if you wish to
close it. To show a hidden toolbar or refresh the current toolbar, press
CTRL-L. If you do not want the toolbar, unset |g:colortemplate_toolbar|.

The menu entries and the corresponding actions may be customised with
|g:colortemplate_toolbar_items| and |g:colortemplate_toolbar_actions|. By
default, the window toolbar has the following menu entries:

Build! ~
Executes |:Colortemplate!| in the current buffer and writes the output inside
the default output directory (see |b:colortemplate_outdir|).

BuildAll! ~
Executes |:ColortemplateAll!| in the current buffer and writes the output
inside the default output directory (see |b:colortemplate_outdir|).

Show ~
Enables the color scheme corresponding to the template in the current buffer.

Hide ~
Switches back to the original color scheme.

Check ~
Executes |:ColortemplateCheck|.

Stats ~
Executes |:ColortemplateStats|.

Source ~
Edits the generated color scheme in a split window.

HiTest ~
Enables the color scheme and executes `runtime` `syntax/hitest.vim`.

OutDir ~
Shows the current output directory and allows you to change it. See
|b:colortemplate_oudir|.

==============================================================================
Colortemplate functions				*colortemplate-functions*

These are some utility functions that advanced users may find useful.

				*colortemplate#format_palette()*
Formats a Dictionary of color name/value pairs into Colortemplate format. The
returned value is a List, each item of which contains a color definition. To
insert the color definitions at the current cursor's position, you may use
something like:
>
	:call append('.', colortemplate#format_palette(some_color_dictionary))
<

				*colortemplate#vimspectr#palette()*
Returns a Dictionary of color name/value pairs corresponding to the given
Vimspectr parameters. The function takes two arguments: the first argument is
the saturation curve (allowed values are `'grey'`, `'flat'`, `'wflat'`,
`'curve'`, and `'wcurve'`); the second argument is a hue value between 0 and
359. For example:
>
	echo colortemplate#vimspectr#palette('curve', 0)
<
The color names are `g0`, `g1`, ... through `g7`.

See also: https://github.com/nightsense/vimspectr

						*colortemplate#syn#toggle()*
Toggles the display of highlight group information for the text under the
cursor. The information is displayed in the command line and has the following
form:
>
	vimVar ⊂ vimFuncBody xxx vimVar → Identifier    fg=14/#00aba5    bg=/
<
From left to right, this shows:

- the nesting of highlight groups (`⊂`);
- a sample of how the text looks like with the current hi group (`xxx`);
- the hi group to which the current hi group resolves, if any (`→`);
- the terminal/GUI values of the foreground and background color.

You are encouraged to define a global mapping in your |vimrc|, e.g.:
>
	nnoremap <silent> gl :<c-u>call colortemplate#syn#toggle()<cr>
<
==============================================================================
Best practices					*colortemplate-best-practices*

Here are some guidelines to develop outstanding hackable color schemes:

- Give each of your colors a short distinctive name.

- Provide support for all terminals, including those with few colors. You
  should define at least three variants: `gui`, `256`, and `8` (or `16`). You
  may add support for black and white terminals with minimal effort by
  including `templates/_bw.colortemplate` in your own templates.

- Do not use too many colors. For maximum portability, you should define eight
  or sixteen colors that map nicely to terminal ANSI colors (black, red,
  green, yellow, blue, magenta, cyan, white, and their bright variants).

- For base-16 colors, prefer color names to numbers for maximum portability
  (see |cterm-colors|).

- Do not define many options. The ideal number of options for a color scheme
  is… zero. Colortemplate does not define any option by default. Note that
  some features such as italics are detected automatically, so in general you
  won't need an option for italics.

- If your color scheme has some option, document it!

- Do not rely only on boldface, italics, or underlined text to visually
  distinguish an element: some setups do not support any of those.

- Visually check every part of your color scheme. Use as many text samples as
  possible: string-heavy languages may look completely different from
  keyword-heavy ones. If you support transparent backgrounds, make sure to
  test your color scheme both against an opaque and a transparent background.
  A few areas that are often overlooked include:

  a. The tabline (|hl-TabLine|, |hl-TabLineFill|, |hl-TabLineSel|). You may
     open a new tab with |tabnew|. See also |showtabline|.

  b. Folded text (|hl-Folded|, |hl-FoldColumn|). Set |foldcolumn| to
     a positive value to test the latter; for the former, create a buffer and
     execute:
>
	:set fdm=marker
<
     then type something like:
>
	{{{
	some text
	}}}
<
     Position the cursor on the text and use |zc| and |zv| to toggle the fold.

  c. The signs column (|hl-SignColumn|). Try placing a sign as explained in
     |sign-commands|:
>
	:sign define piet text=>>
	:exe ":sign place 2 line=23 name=piet file=" . expand("%:p")
<
  d. The cursor's appearance (|hl-Cursor|), especially with |cursorline| and
     |cursorcolumn| on. For this, you may need to use some GUI version of Vim,
     as most terminals override the cursor's color.

  e. Matching parentheses (|hl-MatchParen|) and the cursor's appearance
     against them. Is the cursor clearly visible over a parenthesis? Is the
     matching parenthesis easily spotted? Even when |cursorline| and
     |cursorcolumn| are set?

  f. Search highlight (|hl-Search|, |hl-IncSearch|), especially with
     |cursorline| and |cursorcolumn| on. The |hl-Search| and |hl-IncSearch|
     highlight groups must be distinguishable: set |incsearch| and |hlsearch|,
     search for a pattern with multiple occurrences and move between them with
     CTRL-G and CTRL-T. Can you spot where the cursor is?
     With |cursorcolumn| and |cursorline| on, the highlighted column and
     cursor line should "pass behind" highlighted search results. You may
     achieve that effect by adapting the following snippet:
>
	CursorLine   none   grey            # No foreground color
	CursorColumn none   grey            # No foreground color
	Search       yellow fg    reverse   # Use reverse
<
  g. Diffs (|hl-DiffAdd|, |hl-DiffChange|, |hl-DiffDelete|, |hl-DiffText|).
     Open two buffers in a split window and execute |diffthis| on both of
     them.

  h. The completion menu (|hl-Pmenu|, |hl-PmenuSbar|, |hl-PmenuSel|,
     |hl-PmenuThumb|). A simple way to test that is to define a dictionary:
>
	:set dictionary=/usr/share/dict/words
<
     then type something like `vi`<c-x><c-k>. Scroll through the entries with
     CTRL-N and CTRL-P to make sure that the sidebar is properly visible.

  i. Line numbers (|hl-LineNr|, |hl-CursorLineNr|). Set |number| and check
     that everything looks right.

  j. Command-line completion (|hl-WildMenu|). Set |wildmenu| and try to
     complete something in the command-line. Can you easily see the possible
     completions and the current completion above the command-line?

  k. The window toolbar (|hl-ToolbarLine|, |hl-ToolbarButton|). See
     |window-toolbar|. This is a feature introduced in Vim 8.0.1123. You may
     test this in a Colortemplate buffer! Just press CTRL-L if the toolbar is
     not already visible.
>
- Execute:
>
	:set showtabline=2 laststatus=2
	:vsplit
<
  Do the statuslines (|hl-StatusLine|, |hl-StatusLineNC|), the tabline (see
  above), and the vertical split (|hl-VertSplit|) merge harmoniously or do
  they appear like disconnected components?

  Keeping in mind the above, make the vertical splits distinguishable from the
  status lines. This can be achieved by using different colors for
  |hl-VertSplit| and |hl-StatusLine|/|hl-StatusLineNC| and/or by using
  different foreground and background colors for |hl-VertSplit|, so that the
  separator character (a vertical bar by default) is visible. The user can
  always suppress (or replace) the separator character with 'fillchars'.

  The rationale for this guideline is that it makes it clear how a windows has
  been split. For example, a vertical split followed by two horizontal splits
  produces this layout:
>
	      |
	      |
	------|-------
	      |
	      |
<
  A horizontal split followed by two vertical splits produces this instead:
>
	      |
	      |
	--------------
	      |
	      |
<
  In the former case, the two status lines can be dragged independently, while
  in the latter case they move together as if they were a single status line.
  Similarly, in the former case there is only one long vertical split, while
  in the latter there are two independent vertical bars.

- Avoid defining filetype-specific highlight groups. They override ftplugin
  definitions causing highlighting to be messed up after switching color
  schemes. For example, suppose that the Vim filetype defines `vimCommand` to
  be a link to `Statement`. If your color scheme sets `vimCommand`'s
  attributes, after switching away from your color scheme `vimCommand` will be
  cleared, and not restored to a link to `Statement` as you might expect. Even
  resetting the filetype will not fix that. If you instead link `vimCommand`
  in your colorscheme, the linking will persist after switching to another
  color scheme (so, again, the default link will not be restored), which will
  likely result in a different highlighting than expected. If you absolutely
  need filetype-specific highlight group definitions in your color scheme,
  define an option that allows the user to turn them on/off (the default
  should be off):
>
	verbatim
	if get(g:, '@optionprefix_extra_hi_groups', 0)
	endverbatim
	  " Filetype-specific highlight group definitions go here
	verbatim
	endif
	endverbatim
<
  See also https://github.com/vim/vim/issues/4405.

- For the same reason, plugin-specific highlight groups should be avoided. If
  you really need to define plugin-specific highlight groups, provide an
  option to suppress them (by default, they should be suppressed).

- Some users like to use a transparent background (e.g., with custom images)
  in the terminal. You may easily support that by adapting this snippet:
  >
	Variant: 256 16 8
	verbatim
	if get(g:, '@optionprefix_transp_bg', 0)
	endverbatim
	  Normal some_color none
	  # Other definitions specific for transparency
	verbatim
	else
	endverbatim
	  Normal some_color some_other_color
	  # Other definitions specific for opaqueness
	verbatim
	endif
	endverbatim
<
  Do not forget to document `@optionprefix_transp_bg`!

- Verbatim blocks and aux files allow you to get fancy. Avoid getting too
  fancy.

=============================================================================
Providing feedback				*colortemplate-feedback*

For bug reports and feature requests please use:

    https://github.com/lifepillar/vim-colortemplate/issues

Pull requests are welcome, too!

 vim:tw=78:ts=8:ft=help:norl:
