*librelalg.txt*	For Vim version 9.0	Last change: 2022 Dec 17

This library is an implementation of Relational Algebra in Vim 9 script.

Note: Vim 9.0.1065 or later is required.

0. Quick start				|librelalg-quickstart|
1. Tutorial				|librelalg-tutorial|
2. Data definition language		|librelalg-ddl|
3. Data manipulation language		|librelalg-dml|
4. Relational Algebra			|librelalg-ra|
5. Aggregate functions			|librelalg-aggr|
6. Other functions			|librelalg-other|
7. Tips and tricks			|librelalg-tips|

==============================================================================
0. Quick start					*librelalg-quickstart*

Define a Relational schema:
>
	vim9script

	import "librelalg.vim" as ra

	const Int   = ra.Int
	const Str   = ra.Str
	const Float = ra.Float

	#                    Name  Schema               Keys
	var R = ra.Relation('R',   {A: Int, B: Float},  [['A']])
	var S = ra.Relation('S',   {X: Str, Y: Int},    [['X']])

	ra.ForeignKey(S, ['Y'], R, ['A'])  # FK: S[Y] -> R[A]
	ra.Check(R, (t) => t.B > 0.0, 'B must be greater than zero')
<
Populate the database:
>
	R->ra.InsertMany([
	  {A: 10, B: 3.2},
	  {A: 20, B: 0.6},
	])

	S->ra.InsertMany([
	  {X: 'xyz', Y: 10},
	  {X: 'abc', Y: 20},
	  {X: 'klm', Y: 10},
	])
<
Query the database:
>
	# Find all X that are related to a tuple in R with B > 1.5,
	# sorted lexicographically:

	var rel = ra.Scan(S)
	          ->ra.EquiJoin(R, ['Y'], ['A'])
	          ->ra.Select((t) => t.B > 1.5)
	          ->ra.Project(['X'])
	          ->ra.SortBy(['X'])
	echo ra.Table(rel)
<
Output:
>
	─────
	   X
	─────
	 klm
	 xyz
<
Update the database:
>
	R->ra.Insert({A: 30, B: 4.3})
	S->ra.Update({X: 'klm', Y: 30})
	S->ra.Delete((t) => t.Y == 10)
	rel = ra.Query(ra.Scan(R)->ra.EquiJoin(S, ['A'], ['Y']))
	echo ra.Table(rel)
<
Output:
>
	───────────────
	  A   B   X  Y
	───────────────
	 20 0.6 abc 20
	 30 4.3 klm 30
<
==============================================================================
1. Tutorial					*librelalg-tutorial*

Suppose that you want to write a script that keeps track of some “tags”
associated to each buffer. Since data is king, a good place to start is by
defining a (Relational) *data* *model* for your script. Suppose that, after
carefully evaluating the requirements for your script, your model looks like
this (using standard IDEF1X notation):
>
	 Buffer
	┌───────────────┐
	│ BufId     Int │
	├───────────────┤
	│ BufName   Str │ AK
	└───────┬───────┘
	        │
	  is tagged by /
	    appears in
	        │
	 Tag    ●
	╭───────────────╮
	│ BufId     Str │ FK
	│ TagName   Str │
	├───────────────┤
	│ Line      Int │ (1)
	│ Column    Int │ (1)
	╰───────────────╯
	(1) Lines and columns must be greater than zero.
<
If you are not familiar with IDEF1X or similar diagramming tools, each box
represents an *entity* (your script will deal with “buffers” and “tags”, so
there are two entities in this model). Each entity has a name, written above
its box, and attributes, which are written inside the box. The attributes will
be the actual pieces of data stored and manipulated by your script. Each box
also contains a separator line: the attributes above the separator form the
*primary* *key* of the entity—that is, the main identifier of each entity
instance; the attributes below the separator are further descriptors of the
entity. For instance, each tag is identified by the pair {TagName, BufId}, and
it is described by the attributes Line and Column.

Entities are connected by *relationships* represented by lines joining two
entities. The above diagram contains a one-to-many relationship, the dot
representing the “many” side: such relationship establishes that each buffer
is possibly associated to many tags, but each tag is always associated to one
and only one buffer. The entity on the “one” side of the relationship (Buffer,
in this example) is called the *parent* entity; the entity on the “many” side
of the relationship (Tag, in this example) is called a *child* entity. Each
relationship is described by two verb phrases separated by a slash: the first
verb phrase is read from parent to child (in this example: “A buffer is tagged
by zero or more tags”); the second is read from child to parent (“a tag
appears in one buffer”).

AK stands for Alternate Key, and FK stands for Foreign Key. An alternate key
is an alternative identifier for the entity: in this example, it is assumed
that no two buffers share the same name, so `BufName` can be used as an
identifier instead of `BufId`. A foreign key is the primary key of a parent
entity, which is “migrated” into the child entity by virtue of its
relationship with the parent. When a foreign key is entirely part of the
primary key of the child (as in this example), the child entity is *dependent*
on its parent: in this example, that means that it is not possible to
designate a tag without referencing the buffer to which the tag belongs
(dependent entities are drawn as rectangles with rounded corners, although the
rounded corners may not be particularly prominent in the extended ASCII
rendition above). In this example, Buffer is an *independent* entity: the
existence of a buffer does not depend on anything else in this model. The
distinction between independent and dependent entities has a number of
implications: among the rest, it determines the order in which the database is
populated (you cannot insert tags before inserting the corresponding buffers).

To summarize, the diagram above captures the following facts:

- Buffer is independent;
- a buffer is identified by BufId;
- a buffer is alternatively identified by BufName;
- a buffer is tagged by zero or more tags;
- Tag is dependent on Buffer;
- a tag is identified by {BufId, TagName};
- a tag is described by {Line, Column};
- a tag appears in one (an only one) buffer.
- a tag's line must be an integer greater than zero.
- a tag's column must be an integer greater than zero.

The last two constraints derive from footnote (1) in the data model.

Note: IDEF1X is the ISO standard for Relational modelling (ISO/IEC/IEEE
31320-2). The ISO document is not available for free, but the sections
relevant for Relational modelling are derived (essentially verbatim) from the
older FIPS 184, which is available, for instance, from the Internet Archive:
https://archive.org/details/federalinformati184nati/. Despite its age, the
latter document, and its Annex A in particular, is a good introduction to data
modelling.

Data Definition ~

Now that you have a data model, translating it into code is a relatively
straightforward task:

1. Import the library and optionally define aliases for the imported items you
   are going to use:
>
	vim9script

	import 'librelalg.vim' as ra

	const Bool     = ra.Bool
	const Int      = ra.Int
	const Str      = ra.Str
	const Relation = ra.Relation
	const Insert   = ra.Insert
        # etc.
<
   Note: in the following, for clarity and conciseness, we will write
   librelalg's names without prefix, as if aliases such as those above had
   been defined for all the imported items.

2. Define one *base* relation for each entity:
>
	var Buffer = Relation('Buffer', {
	    BufId:   Int,
	    BufName: Str,
	  },
	  [['BufId'], ['BufName']]
	)

	var Tag = Relation('Tag', {
	    BufId:   Int,
	    TagName: Str,
	    Line:    Int,
	    Column:  Int,
	  },
	  [['BufId', 'TagName']]
	)
<
   The three mandatory arguments of `Relation()` are

   a. a descriptive relation name;
   b. the relation schema: this is a dictionary mapping attribute names to the
      corresponding data types;
   c. the list of keys. Each relation must have at least one key. Each key is
      a list of attributes.

   Note: librelalg does not explicitly distinguish between a primary key and
   the alternate keys.

3. Add the relevant constraints:
>
	Check(Tag, (t) => {
	  if t.Line < 1 || t.Column < 1
	    throw 'Invalid line or column number'
	  endif
	})

	ForeignKey(Tag, ['BufId'], Buffer, ['BufId'], 'is tagged by')
<
   A `Check` clause defines a generic constraint, which is simply a function
   or a lambda that takes as input a tuple and throws an error if the tuple
   does not satisfy a certain condition. `ForeignKey()` defines a foreign key
   constraint from `BufId` in `Tag` to `BufId` in `Buffer`. The verb
   associated to the constraint (as read from the parent to the child entity
   in the data model) can be optionally specified: the verb phrase is used in
   error messages when the referential integrity is violated.

   Note: constraints are checked in the order in which they are declared.

Data Manipulation ~

When the database is defined, you may start populating each base relation with
tuples. Each tuple is just a dictionary conforming to the corresponding
relation schema. Let us insert some data:
>
	Buffer->InsertMany([
	  {BufId: 1, BufName: 'foo'},
	  {BufId: 2, BufName: 'bar'},
	  {BufId: 3, BufName: 'xyz'},
	])

	Tag->InsertMany([
	  {BufId: 1, TagName: 'abc', Line: 3,  Column: 9},
	  {BufId: 1, TagName: 'xyz', Line: 4,  Column: 1},
	  {BufId: 1, TagName: 'lll', Line: 4,  Column: 8},
	  {BufId: 2, TagName: 'abc', Line: 14, Column: 15},
	])
<
If you want to inspect the content of a relation, you may print it as a table:
>
	echo Table(Buffer)
	echo Table(Tag)
<
The output is (note that the columns are in an arbitrary order):
>
	 Buffer
	───────────────
	 BufName BufId
	───────────────
	     foo     1
	     bar     2
	     xyz     3

	 Tag
	───────────────────────────
	 TagName Column Line BufId
	───────────────────────────
	     abc      9    3     1
	     xyz      1    4     1
	     lll      8    4     1
	     abc     15   14     2
<
Of course, any attempt to violate a constraint is rejected with an error.
Trying to insert another buffer called `foobar` will fail with a duplicate key
error:
>
	Buffer->Insert({BufId: 2, BufName: 'foobar'})

	# Duplicate key value: ['BufName'] = ('foobar') already exist
<
because `BufName` is a key. Referential integrity is also guaranteed. For
instance:
>
	Tag->Insert({BufId: 5, TagName: 'x', Line: 3, Column: 9})
<
will raise the following error:
>
	Buffer is tagged by Tag: Tag['BufId'] = (5) is not present in Buffer['BufId']
<
And, of course, you are not allowed to insert an invalid line number either:
>
	Tag->Insert({BufId: 1, TagName: 'x', Line: 0, Column: 40})
<
This insertion is rejected with:
>
	Invalid line or column number
<
Updates and deletions are possible, too:
>
	Tag->Update({BufId: 1, TagName: 'abc', Line: 7, Column: 12})
	echo Table(tag)

	Tag->Delete((t) => t.Line < 5)
	echo Table(tag)
<
For updates, you just pass the updated tuple. For deletions, you provide
a predicate (typically, in the form of a lambda) that the tuples to be deleted
must satisfy.

Queries ~

The power of Relational Algebra lies in its powerful query language as well as
in the simplicity of its data structures: librelalg provides all the
fundamental operations (set operations, selection, projection, joins,
renaming) as well as some extra operations (division, semi-joins, anti-joins,
group-by, etc.). All operators are implemented using a "push-based" strategy:
without entering into technical details, that means that queries are typically
expanded into tight loops and executed as efficiently as hand-written code.

There are three types of operators:

- "root" operators: these take as input a (base or derived) relation and emit
  tuples;
- "leaf" operators: these collect tuples and build a derived relation;
- "pipeline" operators: these process tuples and emit (transformed) tuples.

The most important rule is that each query should start with a root operator
and should end with a leaf operator. A query may chain zero or more
intermediate pipeline operators.

The main root operator is `Scan()` (with `Foreach()` as a synonym). The most
common leaf operator is `Build()` (you may use `Materialize()` or `Query()` as
synonyms). Other leaf operators are `Sort()` and `SortBy()`. Aggregate
functions can also be considered leaf operators, although they return a scalar
value and not a relation: see |librelalg-aggr|.

For instance, the query “Retrieve the tags in buffer 1 before line 6” can be
formulated as follows:
>
	const result = Scan(Tag)
	             ->Select((t) => t.BufId == 1 && t.Line <= 6)
		     ->Build()
	echo Table(result)
<
The `Scan()` function iterates over each tuple of the `Tag` relation and
passes it to the next operator (we usually say that `Scan()` "emits" the
tuples of its input relation). The next operator in this example is
`Select()`, which applies the given function (a lambda in this example) to
each received tuple, and emits only the tuples for which the function returns
true. Finally, `Build()` gathers each tuple as it receives it and builds
a *derived* relation instance, which is the query result (we usually say that
`Build()` "consumes" the received tuples and "materializes" a relation
instance).

Note: strictly speaking, Relational Algebra operators act on relation
instances. So, the above query should be written:
>
	const result = Scan(Tag.instance)->etc...
<
As a convenience, however, librelalg's operators accept relation objects, too:
they access the relation instance internally. The result of a query, however,
is always a relation instance (see below).

Note: the result of a query is just a set of tuples (implemented as a list of
dictionaries). Contrary to base relations, such derived relations do not have
any associated keys, constraints or indexes.

Note: Other ways to write the query above, using the synonyms, are the
following:
>
	Query(Scan(Tag)->Select((t) => t.BufId == 1 && t.Line <= 6))
	Foreach(Tag)->Select((t) => t.BufId == 1 && t.Line <= 6)->Materialize()
	Materialize(Scan(Tag)->Select((t) => t.BufId == 1 && t.Line <= 6))
<
When writing queries, chaining operators with `->` is typically more
intuitive, but you may use the style and the synonyms you prefer. Although
`Query()`, `Build()`, and `Materialize()` have the same meaning, `Query()` is
typically used in prefix form, and `Build()` is used when chaining operators;
`Materialize()` can be used in both cases, but it is more verbose.

If you just wanted to access only the tag names and corresponding lines, you
might just pipe a projection operator, too:
>
	const filteredTags = Scan(Tag)
	                   ->Select((t) => t.BufId == 1 && t.Line <= 6)
	                   ->Project(['TagName', 'Line'])
	                   ->Build()
<
Pipelining is straightforward for unary operators. But, what if you want to
perform a join or perform some other binary operation? Pipelining can still be
used, but one of the arguments must be a base or derived relation. For
example, the natural join of `Buffer` and `Tag` can be written as follows:
>
	const btags = Scan(Buffer)->NatJoin(Tag)->SortBy(['TagName'])
        echo Table(btags, 'Buffer tags')
<
In this query, `SortBy()` has been used as a leaf operator, which builds the
output as `Build()` does, but sorted according to the specified attribute(s).
Of course, since the natural join is commutative, the same query can be
equivalently written as follows:
>
	const btags = Scan(Tag)->NatJoin(Buffer)->SortBy(['TagName'])
<

==============================================================================
2. Data definition language			*librelalg-ddl*


Check({relobj}, {func} [, {opts}])		*librelalg.Check()*
		Define a generic constraint. The constraint is associated to
		base relation {relobj} and is defined by {func}, which is
		a |Funcref| taking as an input a tuple and raising an error
		when a certain condition is not satisfied.

		A check constraint can be triggered before each insertion,
		update or deletion in {relobj}. The operations that should
		trigger the constraint check can be specified by {opts}, which
		is a list of one or more of `'I'`, `'U'`, and `'D'`, for
		insertion, update, and deletion, respectively. By default
		(when {opts} is not given), a constraint is checked before
		each insertion and update, but not upon deletion.

						*librelalg.ForeignKey()*
ForeignKey({relobj1}, {list1}, {relobj2}, {list2} [, {string}])
		Define a referential integrity constraint from attributes
		{list1} in base relation {relobj1} to attributes {list2} in
		base relation {relobj2}.

		An optional verb phrase scan be specified in {string}. This
		should be read from parent to child, that is, from {relobj2}
		to {relobj1}. The verb phrase is used in error messages when
		referential integrity is violated.

Key({relobj}, {key})				*librelalg.Key()*
		Add {key} to base relation {relobj}. The key is a |list| of
		attributes. Since multiple keys can be specified when a base
		relation is defined (see |librelalg.Relation()|), in general
		using this function is not necessary. For example:
>
		var R = Relation('R', {A: Int, B: Str}, [['A'], ['B']])
<
		is equivalent to:
>
		var R = Relation('R', {A: Int, B: Str}, [['A']])
		Key(R, ['B'])
<
						*librelalg.Relation()*
Relation({name}, {schema}, {keys} [, {typecheck}])
		Define a base relation (aka “relation object”). A base
		relation has a descriptive {name} (a |string| used in error
		messages) and is defined over a {schema}, which is a |dict|
		mapping attributes to their corresponding data types. The
		supported data types are:

		- Int: integers
		- Str: strings
		- Float: floats
		- Bool: booleans

		{keys} is a |list| of keys, where each key is a |list| of
		attributes. Every base relation must have at least one key.

		By default, only tuples conforming to the specified schema may
		be inserted into a base relation. When {typecheck} is |false|,
		type checking is suppressed. Omitting type checking may
		slightly improve the performance when inserting or updating
		tuples, but it is not recommended, because the gain may be
		negligible, and type checking is useful to detect errors.

		Example: A relation object with schema:
>
		R(A: integer, B: string, C: integer)
<
		with a composite primary key {A,B} and an alternate key {C}
		can be defined in Vim 9 script as follows:
>
		var R = Relation('R', {
		    A: Int,
		    B: Str,
		    C: Int,
		  }, [['A', 'B'], ['C']])
<
		The value returned by `Relation()`, which in this document is
		referred to as a “base relation” or as a “relation object”, is
		a complex object consisting of the relation instance itself
		(that is, the set of tuples of the relation) together with its
		schema, keys, constraints, and indexes. If you want to
		retrieve just the relation instance, you may access the
		`instance` attribute of the relation object (e.g.,
		`Tag.instance`). A relation instance is just a |list| of
		tuples, and each tuple is just a |dict| mapping attributes to
		values.

==============================================================================
3. Data manipulation language			*librelalg-dml*

Delete({relobj} [, {func}])			*librelalg.Delete()*
		Delete all the tuples of {relobj} satisfying predicate {func},
		which is a function that takes as an input a tuple t and
		returns |true| if and only if t must be deleted. When {pred}
		is not provided, all the tuples are deleted unconditionally.

		Note: for derived relations only, deletion may be performed
		with |filter()|, too. You should never use |filter()| with
		base relations, though, otherwise some integrity constraints
		may be violated.

Insert({relobj}, {tuple})			*librelalg.Insert()*
		Insert {tuple} into {relobj}.

InsertMany({relobj}, {list})			*librelalg.InsertMany()*
		Insert a {list} of tuples into {relobj}.

Update({relobj}, {tuple} [, {upsert}])		*librelalg.Update()*
		Replace a tuple with a new {tuple}. The tuple that is replaced
		is the one with the same key(s) as {tuple}. An error is raised
		if such a tuple does not exist in the base relation, unless
		{upsert} is |true|, in which case {tuple} is inserted into the
		relation and no error is raised.
>
		var R = Relation('R', {A: Int, B: Str}, [['A']])
		        ->Insert({A: 1, B: 'v'})
		R->Update({A: 1, B: 'w'})  # OK
		R->Update({A: 2, B: 'z'})  # ERROR: no tuple with A == 2
		R->Update({A: 2, B: 'z'}, true)  # OK (Upsert)
<
		Note that the above semantics implies that only attributes
		that are not part of any key (the "descriptors" of the base
		relation) can be updated. To update a key attribute, remove
		the corresponding tuple and insert a new one.

==============================================================================
4. Relational Algebra				*librelalg-ra*

The following paragraphs provide a high-level description of the inner working
of the Relational Algebra operators as defined by this library. Although such
understanding is not strictly necessary to be able to use the library, it may
increase your confidence, and it might even be enlightening.

To better understand how the functions described in this section work, we will
make use of the following terminology:

- A *tuple* is a |'dictionary'| mapping attributes to values. Values can be
  strings, integers, booleans, or floats.
- A *relation* *instance* (or simply an “instance”) is a |list| of tuples.
- A *base* *relation* is an object built with |librelalg.Relation()|.
- A *derived* *relation* is a relation instance obtained as the result of
  a query.
- A *relation* is a base relation or a derived relation.
- A *consumer* is any function with signature func({tuple}): void.
- A *continuation* is any function with signature func({consumer}): void.

Intuitively, a consumer is a function that operates in some way on a tuple,
typically by invoking a continuation. A continuation receives as an input
a consumer and applies it to one or more tuples.

This is best described with an example. Consider the following simple query:
>
	Scan(relation)->Select(Pred)->Build()
<
|librelalg.Scan()| returns a continuation that looks as follows:
>
	def Cont(Emit: func(Tuple): void): void
	  for t in relation
	    Emit(t)
	  endfor
	enddef
<
where `Emit()` is a consumer. Most operators, except the root operators, take
a continuation as their first argument, and either build another continuation
(if they are pipeline operators) or materialize a relation (if they are leaf
operators). In the example above, |librelalg.Select()| receives as input the
continuation `Cont` returned by |librelalg.Scan()| and a predicate function
`Pred`: it will then return another continuation, defined as follows:
>
	def Cont2(Emit: func(Tuple): void): void
	  def Consumer(t: Tuple)
	    if Pred(t)
	      Emit(t)
	    endif
	  enddef

	  Cont(Consumer)
	enddef
<
In practice, the Select operator will define a consumer to filter the tuples
according to its input predicate, and will then apply its input continuation
to that consumer.

Finally, the leaf operator |librelalg.Build()| receives as an input the
continuation `Cont2` generated by the Select operator and invokes it to build
a new relation instance, using code similar to the following:
>
	var rel: list<Tuple> = []

	def Consumer2(t: Tuple)
	  add(rel, t)
	enddef

	Cont2(Consumer2)
<
Again, what this operator does is define a consumer and then apply
a continuation (`Cont2`) to that consumer.

The original chained call:
>
	Scan(relation)->Select(Pred)->Build()
<
can be re-written as follows:
>
	Build(Select(Scan(relation), Pred))
<
If you try to expand that taking into account the foregoing discussion, you
will realize that the result is equivalent to the following loop:
>
	var rel: list<Tuple> = []

	for t in relation
	  if Pred(t)
	    add(rel, t)
	  endif
	endfor
<
which is pretty much what one would have written by hand (short of using
a built-in function such as |filternew()|, that is). Of course, for such
a contrived example, there is little to no benefit in using Relational Algebra
compared to Vim's built-in functions. But for more complex queries, one can
obtain the desired output with very compact code, without giving up on
performance.

Some of the examples in the rest of this section are based on the Relational
schema discussed in |librelalg-tutorial|.

AntiJoin({cont}, {rel}, {func})			*librelalg.AntiJoin()*
		Perform the anti-join of two relations. The first relation is
		pipelined from continuation {cont}. The second relation {rel}
		is a base or derived relation. The join condition is specified
		by {func}, which is defined as in |librelalg.Join()|. The
		result is the set of tuples of the first relation that cannot
		be joined with any tuple in {rel}.

		For instance, to obtain the buffers that have no associated
		tags:
>
		const result = Query(
		    Scan(Buffer)
		    ->AntiJoin(Tag, (t, u) => t.BufId == u.BufId)
		  )
		echo Table(result)
<
		Output:
>
		───────────────
		 BufName BufId
		───────────────
		     xyz     3
<
		This is a pipeline operator.

Build({cont})					*librelalg.Build()*
		Materialize a relation by consuming the tuples emitted by
		continuation {cont}. The return value is a relation instance.

		This is a leaf operator,

CoddDivide({cont}, {rel}[, {hint}])		*librelalg.CoddDivide()*
		Divide a relation by another relation {rel}. The dividend is
		pipelined from continuation {cont}. This is Relational
		division as originally defined by Codd, which requires the
		schema of the divisor to be a subset of the schema of the
		dividend—that is, R(X) ÷ S(Y) = Q(X) is defined only if Y ⊆ X.

		This operator builds the maximal¹ relation instance Q on
		X such that each tuple in Q joined with any tuple of
		S produces a tuple in R.

		¹Maximality here is relative to the values of the input. That
		is, the output must contain only values that exist in the
		dividend. More precisely, the output is always a subset of
		π_X(R), the projection on X from relation R.

		For example, to obtain the names of the tags that appear in
		every buffer you may proceed as follows:
>
		const tag = Query(Scan(Tag)->Project(['BufId', 'TagName']))
		const bufid = Query(Scan(Buffer)->Project(['BufId']))
		const result = Query(Scan(tag)->CoddDivide(bufid))
<
		If a divisor `S` is an empty derived relation, then `S` is
		just an empty |list|, which does not carry any explicit
		information about its schema (if `S` is a base relation then
		its schema can be retrieved with `S.schema`). Hence, it is not
		possible to infer the schema of the output relation
		automatically. A |list| of attributes {hint} may be used to
		specify which attributes should appear in the result in the
		special case in which the divisor is empty and derived. For
		instance:
>
		const result = Query(Scan(Buffer)->CoddDivide([], ['BufId']))
<
		Output:
>
		 BufName
		─────────
		     foo
		     bar
		     xyz
<
		Note that {hint} is ignored if the divisor is not empty or it
		is a base relation.

		From a logical point of view, division corresponds to
		first-order universal quantification. Hence, division is
		a compact way to express universal conditions (as opposed to
		a join operation, which is an algebraic way of expressing an
		existential condition).

		This is a pipeline operator. See also |Divide()|.

Divide({cont}, {rel})				*librelalg.Divide()*
		Divide a relation by another relation {rel}. The dividend is
		pipelined from continuation {cont}. This is a form of
		generalized Relational division, with no restriction on the
		schemas of the operands. Consider two relations R(X,Y) and
		S(Y,Z), where Y is the subset of attributes in common between
		R and S, and X and Z are disjoint sets of attributes (any of
		these subsets may be empty). Then, R ÷ S = Q(X,Z) is the
		maximal¹ relation instance on (X,Z) such that each tuple (x,z)
		in Q, when joined with any tuple of S and projected on (X,Y)
		gives a tuple in R. In other words, Q consists of the tuples
		(x,z) such that a tuple (x,y) exists in R for every tuple
		(y,z) in S.

		¹Maximality here is relative to the values of the input. That
		is, the output must contain only values that exist in the
		input relations. More precisely, the output is always a subset
		of π_X(R) ⨯ π_Z(S) (the cross-product of the projection of
		R on X and the projection of S on Z).

		Consider the following example:
>
		const SP = [  # Supplier S# supplies part P#
		  {'S#': 1, 'P#': 10},
		  {'S#': 1, 'P#': 20},
		  {'S#': 1, 'P#': 30},
		  {'S#': 2, 'P#': 10},
		  {'S#': 2, 'P#': 20},
		  {'S#': 3, 'P#': 20},
		  {'S#': 3, 'P#': 40},
		]
		const PJ = [  # Part P# is used in project J#
		  {'P#': 10, 'J#': 100},
		  {'P#': 20, 'J#': 100},
		  {'P#': 20, 'J#': 200},
		  {'P#': 30, 'J#': 200},
		  {'P#': 20, 'J#': 300},
		  {'P#': 40, 'J#': 300},
		]
<
		Then SP ÷ PJ and PJ ÷ SP are computed as follows:
>
		const sp_div_pj = Query(Scan(SP)->Divide(PJ))
		const pj_div_sp = Query(Scan(PJ)->Divide(SP))
		echo Table(sp_div_pj, 'SP ÷ PJ')
		echo Table(pj_div_sp, 'PJ ÷ SP')
<
		Output:
>
		 SP ÷ PJ
		─────────
		  S#  J#
		─────────
		   1 100
		   1 200
		   2 100
		   3 300

		 PJ ÷ SP
		─────────
		  S#  J#
		─────────
		   2 100
		   3 300
<
		The first query finds the pairs (S#,J#) such that supplier S#
		supplies all the parts used in project J#; the second query
		finds all the pairs (S#,J#) such that project J# uses all the
		parts supplied by supplier S#.

		A special case is when the schema of S is a proper subset of
		the schema of R—that is, when Z is empty. Then, this operation
		reduces to |CoddDivide()| (although the latter is in general
		computed more efficiently), except for the special case of an
		empty divisor. When computing R(X,Y) ÷ S(Y), if S is empty
		then |Divide()| always returns an empty relation, while
		|CoddDivide()| always returns π_X(R).

						*librelalg.EquiJoin()*
EquiJoin({cont}, {rel}, {list1}, {list2}, [, {prefix}])
		Perform an equi-join between the relation pipelined from
		continuation {cont} and another relation {rel}.

		{list1} is a list of attributes in the first relation. {list2}
		is a matching list of attributes in {rel}. The two lists must
		have the same length. Attributes at the same position in the
		two lists are compared with equality.

		For {prefix}, see |librelalg.Join()|.

		Example:
>
		const result = Query(
		    Scan(Buffer)->EquiJoin(Tag, ['BufId'], ['BufId'], 't_')
		  )
		echo Table(result)
<
		Output:
>
		─────────────────────────────────────────────────
		 t_Column BufName t_BufId BufId t_Line t_TagName
		─────────────────────────────────────────────────
		        9     foo       1     1      3       abc
		        1     foo       1     1      4       xyz
		        8     foo       1     1      4       lll
		       15     bar       2     2     14       abc
<
		See |librelalg.Join()| for an equivalent formulation of the
		previous example.

		This is a pipeline operator.

Extend({cont}, {func})				*librelalg.Extend()*
	Extend each tuple of a relation with a tuple computed by {func}. The
	input relation is pipelined from continuation {cont}. {func} receives
	a tuple and returns another tuple, which must not have any attribute
	in common with the input tuple. For example:
>
	var R = Relation('R', {A: Int}, [['A']])
		->InsertMany([{A: 1}, {A: 3}, {A: 5}])
	const result = Query(
	    Scan(R)->Extend((t): dict<any> => {
	       return {B: t.A * 2}
	    }))
	echo Table(result)
<
	The output is:
>
	──────
	 A  B
	──────
	 1  2
	 3  6
	 5 10
<
	Note that {func} must consistently return tuples over the same, fixed,
	schema, otherwise the result is not a valid relation instance.

	This is a pipeline operator.

FilteredScan({rel}, {func})			*librelalg.FilteredScan()*
		Emit only the tuples of relation {rel} that satisfies a
		given predicate. The predicate is defined by {func}, which is
		a |Funcref| taking as an input a tuple t and returning |true|
		if and only if t should be emitted. For exaple:
>
		const res = Query(
		    FilteredScan(Tag, (t) => t.Line > 3 && t.Line < 9)
		)
<
		emits only the tags between line 4 and 8.

		In practice, this operator fuses a scan with a select, which
		may be more efficient than chaining |librelalg.Scan()| and
		|librelalg.Select()|.

		This is a root operator.

Foreach({rel})					*librelalg.Foreach()*
		A synonym of |librelalg.Scan()|.

GroupBy({cont}, {list}, {func} [, {string}])	*librelalg.GroupBy()*
		Group the tuples of a relation with respect to a {list} of
		attributes, and apply an aggregate function {func} to each
		group. The schema of the output relation consists of the
		grouping attributes and the aggregate attribute. The name of
		the aggregate attribute is given by {string}.

		For instance, to count the number of tags in each buffer with
		at least one tag:
>
		const result = Query(
		    Scan(Tag)
		    ->GroupBy(['BufId'], Count, 'num_tags')
		  )
		echo Table(result)
<
		Output:
>
		────────────────
		 num_tags BufId
		────────────────
		        3     1
		        1     2
<
		|librelalg.Count()| is an aggregate function. To read about
		aggregate functions, see |librelalg-aggr|.

		This is a pipeline operator.

Intersect({cont}, {rel})			*librelalg.Intersect()*
		Intersect two relations. The first relation is pipelined from
		continuation {cont}. The second relation is a base or derived
		relation {rel}.

		Note: the relations must be defined on the same schema!

		For instance:
>
		var R = Relation('R', {A: Int, B: Str}, [['A']])
			->InsertMany([
			  {A: 1, B: 'x'},
			  {A: 3, B: 'y'},
			  {A: 5, B: 'y'},
			])
		var S = Relation('S', {A: Int, B: Str}, [['A']])
			->InsertMany([
			  {A: 3, B: 'y'},
			  {A: 6, B: 'y'},
			])
		const result = Query(Scan(R)->Intersect(S))
		echo Table(result)
<
		The output is:
>
		─────
		 A B
		─────
		 3 y
<
		This is a pipeline operator.

Join({cont}, {rel}, {func} [, {prefix}])	*librelalg.Join()*
		Perform a join with relation {rel}. The first relation is
		pipelined from continuation {cont}. The second relation is
		a base or derived relation {rel}. The join condition is
		specified by {func}, which is a |Funcref| that takes as an
		input two tuples t1 and t2 and returns |true| if and only if
		t1 and t2 should be joined.

		{prefix} is a string that is added to each attribute name of
		the pipelined relation in the output relation. The prefix is
		mandatory if the relations to be joined have some attributes
		in common, because the attributes in a relation must be all
		distinct. The prefix must not be used inside {func}.

		For example, to join `Buffer` with `Tag` on the common `BufId`
		attribute:
>
		const result = Query(
		    Scan(Buffer)
		    ->Join(Tag, (t, u) => t.BufId == u.BufId, 't_')
		  )
		echo Table(result)
<
		Output:
>
		─────────────────────────────────────────────
		 TagName Column Line t_BufId BufId t_BufName
		─────────────────────────────────────────────
		     abc      9    3       1     1       foo
		     xyz      1    4       1     1       foo
		     lll      8    4       1     1       foo
		     abc     15   14       2     2       bar
<
		Failing to add a prefix in the query above will result in an
		error:
>
		Key already exists: BufId
<
		because the attribute `BufId` exists both in `Buffer` and in
		`Tag`.

		This is a pipeline operator.

Lookup({relobj}, {key}, {list})			*librelalg.Lookup()*
		TODO

Materialize({cont})				*librelalg.Materialize()*
		A synonym of |librelalg.Build()|.

Minus({cont}, {rel})				*librelalg.Minus()*
		Subtract a relation from another. The first relation is
		pipelined from continuation {cont}. The second relation is
		a base or derived relation {rel}.

		Note: the relations must be defined on the same schema!

		For instance:
>
		var R = Relation('R', {A: Int, B: Str}, [['A']])
			->InsertMany([
			  {A: 1, B: 'x'},
			  {A: 3, B: 'y'},
			  {A: 5, B: 'y'},
			])
		var S = Relation('S', {A: Int, B: Str}, [['A']])
			->InsertMany([
			  {A: 3, B: 'y'},
			  {A: 6, B: 'y'},
			])
		const result = Query(Scan(R)->Minus(S))
		echo Table(result)
<
		The output is:
>
		─────
		 A B
		─────
		 1 x
		 5 y
<
		This is a pipeline operator.

NatJoin({cont}, {rel})				*librelalg.NatJoin()*
		Perform the natural join of two relations. The first relation
		is pipelined from continuation {cont}. The second relation is
		a base or derived relation {rel}. For instance:
>
		const result = Query(Scan(Buffer)->NatJoin(Tag))
		echo Table(result)
<
		Output:
>
		───────────────────────────────────
		 Column TagName BufName Line BufId
		───────────────────────────────────
		      9     abc     foo    3     1
		      1     xyz     foo    4     1
		      8     lll     foo    4     1
		     15     abc     bar   14     2
<
		This is a pipeline operator.

Noop({cont})					*librelalg.Noop()*
		A pipeline operator that does nothing: it just emits the
		tuples it receives.

Query({cont})					*librelalg.Query()*
		A synonym of |librelalg.Build()|.

Rename({cont}, {list1}, {list2})		*librelalg.Rename()*
		Rename the attributes of a relation. The relation is pipelined
		from continuation {cont}.

		{list1} is a list of attributes to rename.
		{list2} is the corresponding list of new attributes.

		Example:
>
		var R = Relation('R', {A: Int, B: Str}, [['A']])
			->InsertMany([{A: 1, B: 'u'}, {A: 2, B: 'v'}])
		var S = Query(Scan(R)->Rename(['A', 'B'], ['X', 'Y']))
		echo Table(S)
<
		The output is:
>
		─────
		 X Y
		─────
		 1 u
		 2 v
<
		Only the schema of the relation (that is, the header of the
		table) is changed: the instance remains the same.

		This is a pipeline operator.

Product({cont}, {rel} [, {prefix}])		*librelalg.Product()*
		Perform the cross product of two relations. The first relation
		is pipelined from continuation {cont}. The second relation is
		a base or derived relation {rel}. For {prefix}, see
		|librelalg.Join()|.

		For example, to obtain all sorted pairs of tag names:
>
		const tagname = Query(Scan(Tag)->Project(['TagName']))
		const result = Scan(tagname)
			       ->Product(tagname, 't_')
			       ->Select((t) => t.TagName < t.t_TagName)
			       ->SortBy(['TagName', 't_TagName'])
		echo Table(result)
<
		Output:
>
		 TagName t_TagName
		───────────────────
		     abc       lll
		     abc       xyz
		     lll       xyz
<
		This is a pipeline operator.

Project({cont}, {list})				*librelalg.Project()*
		Perform a projection of a relation on a {list} of attributes.
		The relation is pipelined from continuation {cont}.

		For instance:
>
		const result = Query(
		    Scan(Tag)
		    ->Project(['TagName'])
		  )
		echo Table(result)
<
		Output:
>
		─────────
		 TagName
		─────────
		     abc
		     xyz
		     lll
<
		This is a pipeline operator.

Scan({rel})					*librelalg.Scan()*
		Return a continuation that iterates over the tuples of
		a relation {rel} and emits each tuple. This is a root
		operator, that is, an operator that starts a query.

Select({cont}, {func})				*librelalg.Select()*
		Filter the tuples of a relation based on a predicate. The
		relation is pipelined from continuation {cont}. The predicate
		is defined by {func}, which is a |Funcref| that takes as an
		input a tuple t and returns |true| if and only if t must be
		emitted.

		For instance, to select all the tags after line 3 in buffer 1:
>
		const result = Query(
		    Scan(Tag)
		    ->Select((t) => t.BufId == 1 && t.Line > 3)
		  )
		echo Table(result)
<
		Output:
>
		───────────────────────────
		 TagName Column Line BufId
		───────────────────────────
		     xyz      1    4     1
		     lll      8    4     1
<
		This is a pipeline operator. See also |librelalg.Lookup()|.

SemiJoin({cont}, {rel}, {func})			*librelalg.SemiJoin()*
		Perform the semi-join of two relations. The first relation is
		pipelined from continuation {cont}. The second relation is
		a base or derived relation {rel}.

		This is the same as joining a relation with {rel} (see
		|librelalg.Join()|), then projecting the result on the
		attributes of the first relation.

		For instance, to obtain the buffers that have some tag:
>
		const result = Query(
		      Scan(Buffer)
		      ->SemiJoin(Tag, (t, u) => t.BufId == u.BufId)
		  )
		echo Table(result)
<
		Output:
>
		───────────────
		 BufName BufId
		───────────────
		     foo     1
		     bar     2
<
		This is a pipeline operator.

Sort({cont}, {func})				*librelalg.Materialize()*
		Materialize a relation by sorting its tuples according to the
		criterion specified by {func}. The relation is pipelined from
		continuation {cont}. The sorting predicate {func} is
		a |Funcref| that takes as an input two tuples t1 and t2, and
		returns -1, 0, or 1 depending on whether t1 precedes t2, t1
		equals t2 or t1 follows t2, respectively. For instance, to
		sort a relation `R` with respect to one of its attributes, say
		`A`, you may write:
>
		def Compare(t1: dict<any>, t2: dict<any>): number
		   return t1.A < t2.A ? -1 : t1.A > t2.A ? 1 : 0
		enddef

		const result = Scan(R)->Sort(Compare)
<
		This is a leaf operator. See also |librelalg.SortBy()|.

SortBy({cont}, {list} [, {opts}])		*librelalg.SortBy()*
		Materialize a relation by sorting the tuples according the
		specified {list} of attributes. The relation is pipelined from
		continuation {cont}. For instance:
>
		const result = Scan(R)->SortBy(['A'])
<
		This will sort the tuples of `R` with respect to `A`.

		{opts} is a list that specifies, for each sorting attribute,
		whether to sort the values of that attribute in increasing or
		decreasing order. For instance:
>
		const result = Scan(R)->SortBy(['A', 'B'], ['d', 'i'])
<
		will sort `R` in decreasing order (`'d'`) with respect to `A`,
		and then the tuples with the same value of `A` will be sorted
		in increasing order (`'i'`) with respect to `B`.

		This is a leaf operator. See also |librelalg.Sort()|.

Union({cont}, {rel})				*librelalg.Union()*
		Take the union of two relations. The first relation is
		pipelined from continuation {cont}. The second relation is
		a base or derived relation {rel}.

		Note: the relations must be defined on the same schema!

		For instance:
>
		var R = Relation('R', {A: Int, B: Str}, [['A']])
			->InsertMany([
			  {A: 1, B: 'x'},
			  {A: 3, B: 'y'},
			  {A: 5, B: 'y'},
			])
		var S = Relation('S', {A: Int, B: Str}, [['A']])
			->InsertMany([
			  {A: 3, B: 'y'},
			  {A: 6, B: 'y'},
			  {A: 1, B: 'x'},
			])
		const result = Query(Scan(R)->Union(S))
		echo Table(result)
<
		The output is:
>
		─────
		 A B
		─────
		 3 y
		 6 y
		 1 x
		 5 y
<
		This is a pipeline operator.

==============================================================================
5. Aggregate functions				*librelalg-aggr*

An aggregate function is a special type of leaf operator: instead of returning
a relation instance, an aggregate function returns a scalar.

Count({cont})					*librelalg.Count()*
		Return the number of tuples of a relation. For instance, to
		return the number of buffers:
>
		const nBuf = Scan(Buffer)->Count()
<
Min({cont}, {attr})				*librelalg.Min()*
		Return the Minimum value of attribute {attr} in a relation.
		For instance, to return the minimum buffer id:
>
		const minBufId = Scan(Buffer)->Min('BufId')
<
Max({cont}, {attr})				*librelalg.Max()*
		Return the maximum value of attribute {attr} in a relation.
		For instance, to return the maximum column of a tag:
>
		const maxCol = Scan(Tag)->Max('Column')
<
Sum({cont}, {attr})				*librelalg.Sum()*
		Return the sum of the values of attribute {attr} in
		a relation. For instance:
>
		const colSum = Scan(Tag)->Sum('Column')
<
==============================================================================
6. Other functions				*librelalg-other*

Attributes({relobj})				*librelalg.Attributes()*
		Return the list of attributes of relation object {relobj}.

Descriptors({relobj})				*librelalg.Descriptors()*
		Return the list of descriptors of relation object {relobj}.
		A descriptor is an attribute that is not part of any key.

EquiJoinPred({list1}, {list2})			*librelalg.EquiJoinPred()*
		Return a predicate comparing the attributes in {list1} and the
		attributes in {list2} for equality elementwise. The returned
		function can be used as an argument to the various join
		operators. For example:
>
		const Pred = EquiJoinPred(['BufName'], ['TagName'])
		const result = Query(Scan(Buffer)->SemiJoin(Tag, Pred))
<
		This will join on the condition:
>
		Buffer.BufName == Tag.TagName
<
Empty({rel})					*librelalg.Empty()*
		TODO

Filter({rel}, {func})				*librelalg.Filter()*
		TODO

In({tuple}, {rel})				*librelalg.In()*
		TODO

KeyAttributes({relobj})				*librelalg.KeyAttributes()*
		Return the list of key attributes of relation object {relobj}.
		A key attribute is an attribute that is part of a key.

NotIn({tuple}, {rel})				*librelalg.NotIn()*
		TODO

RelEq({rel1}, {rel2})				*librelalg.RelEq()*
		TODO

Table({rel} [, {name}, {sep}])			*librelalg.Table()*
		TODO

Zip({list1}, {list2})				*librelalg.Zip()*
		Build a tuple by "zipping" the attributes in {list1} with the
		values in {list2}. For example:
>
		const t = Zip(['A', 'B'], [7, 'v'])
		echo t
<
		outputs:
>
		{A: 7, B: 'v'}
<
==============================================================================
7. Tips and tricks				*librelalg-tips*

Base relations must be updated only through librelalg's operators, because
that is the only way integrity constraints can be verified.
Derived relations, however, are just lists of dictionaties, and can be further
processed in any way. For instance:
>
	var R = Relation('R', {A: Int, B: Int}, [['A']])

	# […]

	const S = Filter(R, (t) => t.A > 0)    # OK
	filter(R.instance, (_, t) => t.A > 0)  # BAD! R is a base relation

	var s = Scan(R)->Project(['A'])->Build()
	Filter(s, (t) => t.A > 0)     # OK
	filter(s, (_, t) => t.A > 0)  # Also OK: s is a derived instance
<
Keys ~

An index is built for each key. The indexes help speed up some operations and
are used to enforce key constraints. The order of the attributes in a compound
key matters for performance. In the example above, if tags are often looked up
by name, it may be more efficient to define the primary key as `['TagName',
'BufId', 'Line']` rather than `['BufId',` `'TagName', 'Line']` as was done
above. In general, the attributes that are accessed more frequently should
appear earlier in the key.

Nulls ~

Nulls are not supported. A properly designed database never needs nulls, so
this is not a loss of generality, and it is a great gain in simplicity and
semantic clarity.

 vim:tw=78:ts=8:noet:ft=help:norl:
