vim9script

import './version.vim'     as version
import './colorscheme.vim' as cscheme
import 'librelalg.vim'     as ra

const VERSION        = version.VERSION
const NO_DISCR_VALUE = cscheme.DEFAULT_DISCR_VALUE
const Database       = cscheme.Database
const Metadata       = cscheme.Metadata
const Colorscheme    = cscheme.Colorscheme
const Sort           = ra.Sort
const Transform      = ra.Transform

# Helper functions {{{
def In(v: any, items: list<any>): bool
  return index(items, v) != -1
enddef

def CompareDistinct(s1: string, s2: string): number
  return s1 < s2 ? -1 : 1
enddef

def CompareByHiGroupName(t: dict<any>, u: dict<any>): number
  if t.HiGroupName == u.HiGroupName
    return 0
  elseif t.HiGroupName == 'Normal'
    return -1
  elseif u.HiGroupName == 'Normal'
    return 1
  else
    return CompareDistinct(t.HiGroupName, u.HiGroupName)
  endif
enddef

def CompareByDiscrName(t: dict<any>, u: dict<any>): number
  if t.DiscrName == u.DiscrName
    return 0
  elseif t.DiscrName == 't_Co'
    return -1
  elseif u.DiscrName == 't_Co'
    return 1
  else
    return CompareDistinct(t.DiscrName, u.DiscrName)
  endif

enddef

def CompareByDiscrValueAndHiGroupName(t: dict<any>, u: dict<any>): number
  if t.DiscrValue == u.DiscrValue
    return CompareByHiGroupName(t, u)
  elseif t.DiscrValue == NO_DISCR_VALUE
    return 1
  elseif u.DiscrValue == NO_DISCR_VALUE
    return -1
  else
    return CompareDistinct(t.DiscrValue, u.DiscrValue)
  endif
enddef

def LinkedGroupToString(t: dict<any>, indent = 0): string
  const space = repeat(' ', indent)
  return printf("%shi! link %s %s", space, t.HiGroupName, t.TargetGroup)
enddef

def AttributesToString(t: dict<any>, meta: dict<any>, termgui: bool): list<string>
  var attributes = []

  # If the variant supports color attribute `key`, and if the highlight group
  # has a value for it, map the color and add it to the definition
  for key in ['Fg', 'Bg', 'Special']
    if !empty(meta[key]) && !empty(t[key])
      const colorName: string = t[key]
      attributes->add(meta[key] .. '=' .. meta.Colors[colorName])
    endif
  endfor

  # Do the same for the other (non-color) attributes (no mapping needed)
  if !empty(meta.Style) && !empty(t.Style)
    attributes->add(meta.Style .. '=' .. t.Style)

    if termgui
      attributes->add('cterm=' .. t.Style)
    endif
  endif

  for key in ['Font', 'Start', 'Stop']
    if !empty(meta[key]) && !empty(t[key])
      attributes->add(meta[key] .. '=' .. t[key])
    endif
  endfor

  return attributes
enddef

def BaseGroupToString(t: dict<any>, meta: dict<any>, indent = 0, termgui: bool = false): string
  const space = repeat(' ', indent)
  var hiGroupDef = ['hi', t.HiGroupName] + AttributesToString(t, meta, termgui)

  return space .. join(hiGroupDef, ' ')
enddef

# Convert a higlight group tuple into a string.
#
# t       A tuple with enough information to generate a highlight group
#         definition (for example, a tuple from Database.BaseGroup).
# meta    Variant metadata from Database.GetVariantMetadata()
def HiGroupToString(t: dict<any>, meta: dict<any>, indent = 0): string
  if t->has_key('TargetGroup') && !empty(t.TargetGroup)
    return LinkedGroupToString(t, indent)
  endif

  return BaseGroupToString(t, meta, indent)
enddef
# }}}

# Header and footer {{{
def AddMeta(header: list<string>, text: string, value: string): list<string>
  if !empty(value)
    header->add(printf(text, value))
  endif

  return header
enddef

def AddList(header: list<string>, text: string, items: list<string>): list<string>
  if !empty(items)
    header->AddMeta(text, items[0])

    const n = len(items)
    const spaces = repeat(' ', len(text) - 3)
    var i = 1
    while i < n
      header->add(printf('#%s%s', spaces, items[i]))
      ++i
    endwhile
  endif

  return header
enddef

def Header(meta: Metadata): list<string>
  const license     = empty(meta.license) ? 'Vim License (see `:help license`)' : meta.license
  var   header      = ['vim9script', '']

  header->AddMeta('# Name:           %s', meta.fullname)
  header->AddMeta('# Version:        %s', meta.version)
  header->AddList('# Description:    %s', meta.description)
  header->AddList('# Author(s):      %s', meta.author)
  header->AddList('# Maintainers(s): %s', meta.maintainer)
  header->AddList('# URL(s):         %s', meta.url)
  header->AddMeta('# License:        %s', meta.license)
  header->AddMeta('# Last Updated:   %s', strftime("%c"))
  header->add('')
  if meta.options.creator
    header->AddMeta('# Generated by Colortemplate v%s', VERSION)
    header->add('')
  endif

  if !meta.backgrounds.light
    header->add('set background=dark')->add('')
  elseif !meta.backgrounds.dark
    header->add('set background=light')->add('')
  endif

  header->add('hi clear')->add('')
  header->AddMeta("g:colors_name = '%s'", meta.shortname)
  header->AddMeta("g:terminal_ansi_colors = %s", string(meta.termcolors))
  header->add('')
  header->add("const t_Co = exists('&t_Co') && !has('gui_running') ? (str2nr(&t_Co) ?? 0) : -1")

  if !empty(meta.verbatimtext)
    header->add('')
    header += meta.verbatimtext
    header->add('')
  endif

  return header
enddef

def Footer(meta: Metadata): list<string>
  const opts: dict<any> = meta.options
  const et = opts.useTabs ? 'noet' : 'et'

  return ['', printf('# vim: nowrap %s ts=%s sw=%s', et, opts.shiftwidth, opts.shiftwidth)]
enddef

def StartBackground(background: string, indent = 0): list<string>
  const spaces = repeat(' ', indent)
  return ['', printf("%sif &background == '%s'", spaces, background)]
enddef

def EndBackground(indent = 0): list<string>
  const spaces = repeat(' ', indent)
  return [printf('%sendif', spaces)]
enddef

def DiscriminatorToString(t: dict<any>, indent = 0): string
  const spaces = repeat(' ', indent)
  return printf('%sconst %s = %s', spaces, t.DiscrName, t.Definition)
enddef

def GenerateDiscriminators(db: Database, indent = 0): list<string>
  return db.Discriminators()
    ->Transform((t) => DiscriminatorToString(t, indent))
enddef

def GenerateOverridingDefinitions(db: Database, meta: Metadata, variantMeta: dict<any>, indent = 0): list<string>
  const spaces:     string                = repeat(' ', indent)
  const nextIndent: number                = indent + meta.options.shiftwidth
  var   overrides:  dict<list<dict<any>>> = db.OverridingDefsByDiscrName(variantMeta.Variant)
  const discrNames: list<string>          = keys(overrides)->sort()
  var   defs:       list<string>          = []

  for discrName in discrNames
    const hiGroups = overrides[discrName]->sort(CompareByDiscrValueAndHiGroupName)

    if empty(hiGroups)
      continue
    endif

    var discrValue = hiGroups[0].DiscrValue

    defs->add(printf("%sif %s == %s", spaces, discrName, discrValue))

    for t in hiGroups
      if t.DiscrValue != discrValue
        discrValue = t.DiscrValue
        defs->add(printf("%selseif %s == %s", spaces, discrName, discrValue))
      endif
      const overridingDef = HiGroupToString(t, variantMeta, nextIndent)
      defs->add(overridingDef)
    endfor

    defs->add(printf("%sendif", spaces))
  endfor

  return defs
enddef

def StartVariant(variantMeta: dict<any>, indent: number): list<string>
  const spaces  = repeat(' ', indent)

  if variantMeta.Variant == 'gui'
    return [printf("%sif has('gui_running')", spaces)]
  endif

  return [printf('%sif t_Co >= %d', spaces, variantMeta.NumColors)]
enddef

def EndVariant(variantMeta: dict<any>, indent: number): list<string>
  const spaces  = repeat(' ', indent)

  if variantMeta.Variant == 'gui'
    return [printf('%sendif', spaces)]
  endif

  return [printf('%sfinish', spaces), printf('%sendif', spaces)]
enddef

def GenerateVariant(db: Database, meta: Metadata, variant: string, indent = 0, onlyOverrides = false): list<string>
  const variantMeta = db.GetVariantMetadata(variant)
  const opts        = meta.options

  var defaultDefs: list<dict<any>>
  var defs:        list<string>    = []
  var theme:       list<string>    = []

  if onlyOverrides
    defaultDefs = db.VariantSpecificDefinitions(variant)->sort(CompareByHiGroupName)
  else
    defaultDefs = db.DefaultDefinitions(variant)
    # Remove default linked groups because they are added globally
    filter(defaultDefs, (_, t) => t->has_key('Fg') || t->has_key('Variant'))
    defaultDefs->sort(CompareByHiGroupName)
  endif

  defs  = defaultDefs->mapnew((_, t) => HiGroupToString(t, variantMeta, indent + opts.shiftwidth))
  defs += GenerateOverridingDefinitions(db, meta, variantMeta, indent + opts.shiftwidth)

  if !empty(defs)
    theme->add('')
    theme += StartVariant(variantMeta, indent)
    theme += defs
    theme += EndVariant(variantMeta, indent)
  endif

  return theme
enddef
# }}}

def EmitColorscheme(db: Database, meta: Metadata, indent = 0): list<string>
  var nextIndent     = indent
  const metaGUI      = db.GetVariantMetadata('gui')
  const globalLinked = db.LinkedGroup->Sort(CompareByHiGroupName)
  const globalBaseGr = db.BaseGroup  ->Sort(CompareByHiGroupName)

  var defs:  list<string> = []
  var theme: list<string> = []

  if meta.IsLightAndDark()
    theme += StartBackground(db.background, indent)
    nextIndent += meta.options.shiftwidth
  endif

  theme += GenerateDiscriminators(db, nextIndent)->add('')
  defs = globalLinked->Transform((t) => LinkedGroupToString(t, nextIndent))

  if !empty(defs)
    theme += defs->add('')
  endif

  theme += globalBaseGr->Transform((t) => BaseGroupToString(t, metaGUI, nextIndent, true))

  # Add variant-specific definitions and overrides, in the specified order
  for variant in ['gui', '256', '88', '16', '8', '0']
    if variant->In(meta.variants)
      theme += GenerateVariant(db, meta, variant, nextIndent, variant == 'gui')
    endif
  endfor

  if meta.IsLightAndDark()
    theme += EndBackground(indent)
  endif

  return theme
enddef

export def Generate(kolorscheme: Colorscheme): list<string>
  const meta  = kolorscheme.metadata
  const dbase = {"dark": kolorscheme.dark, "light": kolorscheme.light}

  var theme = Header(meta)

  for [bg, db] in items(dbase)
    if meta.HasBackground(bg)
      theme += EmitColorscheme(db, meta)
    endif
  endfor

  theme += Footer(meta)

  return theme
enddef

# vim: foldmethod=marker nowrap et ts=2 sw=2
