*librelalg.txt*	For Vim version 9.0	Last change: 2025 Jan 12

This library is an implementation of Relational Algebra in Vim 9 script.

Note: Vim 9.1.0547 or later is required.

0. Quick start				|librelalg-quickstart|
1. Tutorial				|librelalg-tutorial|
2. Data definition language		|librelalg-ddl|
3. Relational Algebra			|librelalg-ra|
4. Aggregate functions			|librelalg-aggregates|
5. Other functions			|librelalg-other-functions|

==============================================================================
0. Quick start					*librelalg-quickstart*

A relation instance (or, simply, a relation) is just a list of homogeneous
dictionaries, such as this:
>
	var r = [{A: 1, B: 'bbb'},
	         {A: 2, B: 'aaa'},
	         {A: 3, B: 'bbb'}]
<
Each dictionary is called a "tuple" (not to be confused with Vim's |Tuples|:
librelag's Relational tuples are not ordered). Each dictionary key in a tuple
is called an "attribute". In the example above, r is a relation with three
tuples on attributes A and B.

A relation must not contain any duplicate tuples.

Relational Algebra operators transform relations into other relations. For
example:
>
	vim9script
	import 'librelalg.vim' as ra

	var r = [{A: 1, B: 'bbb'},
	         {A: 2, B: 'aaa'},
	         {A: 3, B: 'bbb'}]

	var result = ra.Query(ra.Select(r, (t) => t.B == 'bbb'))
	echo result
	echo ra.Table(result)
<
Output:
>
	[{'A': 1, 'B': 'bbb'}, {'A': 3, 'B': 'bbb'}]

	───────
	 A   B
	───────
	 1 bbb
	 3 bbb
<
So, at the basic level librelalg allows you to perform Relational queries on
Vim's data structures. See |librelalg-ra| to learn about the available
operators.

But librelalg also offers support for data definition and data manipulation
with built-in integrity. For that, start by defining a Relational schema:
>
	vim9script
	import "librelalg.vim" as ra

	type  Rel        = ra.Rel
	const Int        = ra.Int
	const Str        = ra.Str
	const Float      = ra.Float
	const ForeignKey = ra.ForeignKey
	const References = ra.References

	#        Name ───┐  Schema ────┐    Keys ────┐
	#                ▼             ▼             ▼
	var R = Rel.new('R',   {A: Int, B: Float},  'A')
	var S = Rel.new('S',   {X: Str, Y: Int},    'X')

	R.OnInsertCheck('B must be positive', (t) => t.B > 0.0)
	ForeignKey(S, 'Y')->References(R)
<
Populate the database:
>
	R.InsertMany([
	  {A: 10, B: 3.2},
	  {A: 20, B: 0.6},
	])

	S.InsertMany([
	  {X: 'xyz', Y: 10},
	  {X: 'abc', Y: 20},
	  {X: 'klm', Y: 10},
	])
<
Query the database:
>
	# Find all X in S that are related to a tuple in R with B > 1.5,
	# sorted lexicographically:

	var rel = ra.Query(
	    ra.Select(R, (t) => t.B > 1.5)
	    ->ra.EquiJoin(S, {onleft: 'A', onright: 'Y'})
	    ->ra.Project('X')
	    ->ra.SortBy('X')
	)
	echo ra.Table(rel)
<
Output:
>
	─────
	   X
	─────
	 klm
	 xyz
<
Update the database:
>
	# Add a new tuple
	R.Insert({A: 30, B: 4.3})

	# Update tuple with X equal to 'klm' by setting Y equal to 30
	S.Update((t) => t.X == 'klm', (t) => {
	  t.Y = 30
	})

	# Delete tuples satisfying a condition
	S.Delete((t) => t.Y == 10)

	rel = ra.Query(ra.EquiJoin(R, S, {onleft: 'A', onright: 'Y'}))
	echo ra.Table(rel)
<
Output:
>
	───────────────
	  A   B   X  Y
	───────────────
	 20 0.6 abc 20
	 30 4.3 klm 30
<
==============================================================================
1. Tutorial					*librelalg-tutorial*

Suppose that you want to write a script that keeps track of some "tags"
associated to each buffer. Since data is king, a good place to start is by
defining a (Relational) data model for your script. Suppose that, after
carefully evaluating your requirements, your model looks like this (using
standard IDEF1X notation):
>
	 Buffer
	┌───────────────┐
	│ BufId     Int │
	├───────────────┤
	│ BufName   Str │ AK
	└───────┬───────┘
	        │
	  is tagged by /
	    appears in
	        │
	 Tag    ●
	╭───────────────╮
	│ BufId     Str │ FK
	│ TagName   Str │
	├───────────────┤
	│ Line      Int │ (1)
	│ Column    Int │ (1)
	╰───────────────╯
	(1) Lines and columns must be greater than zero.
<
If you are not familiar with IDEF1X or similar diagramming tools, each box
represents an "entity" (your script will deal with "buffers" and "tags", so
there are two entities in this model). Each entity has a name, written above
its box, and attributes, which are written inside the box. The attributes will
be the actual pieces of data stored and manipulated by your script. Each box
also contains a separator line: the attributes above the separator form the
"primary key" of the entity—that is, the main identifier of each entity
instance; the attributes below the separator are further descriptors of the
entity. For instance, each tag is identified by the pair {TagName, BufId}, and
it is described by the attributes Line and Column.

Entities are connected by "relationships", represented by lines joining two
entities. The above diagram contains a one-to-many relationship, the dot
representing the "many" side: such relationship establishes that each buffer
is possibly associated to many tags, but each tag is always associated to one
and only one buffer. The entity on the "one" side of the relationship (Buffer,
in this example) is called the "parent" entity; the entity on the "many" side
of the relationship (Tag, in this example) is called a "child" entity. Each
relationship is described by two verb phrases separated by a slash: the first
verb phrase is read from parent to child (in this example: "A buffer is tagged
by zero or more tags"); the second is read from child to parent ("a tag
appears in one buffer").

AK stands for Alternate Key, and FK stands for Foreign Key. An alternate key
is an alternative identifier for the entity: in this example, it is assumed
that no two buffers share the same name, so `BufName` can be used as an
identifier as well as `BufId`. A foreign key is the primary key of a parent
entity, which is "migrated" into the child entity by virtue of its
relationship with the parent.

To summarize, the diagram above captures the following facts:

- a buffer is identified by BufId;
- a buffer is alternatively identified by BufName;
- a buffer is tagged by zero or more tags;
- a tag is identified by {BufId, TagName};
- a tag is described by {Line, Column};
- a tag appears in one (and only one) buffer.
- a tag's line must be an integer greater than zero.
- a tag's column must be an integer greater than zero.

The last two constraints derive from footnote (1) in the data model.

Note: IDEF1X is the ISO standard for Relational modelling (ISO/IEC/IEEE
31320-2). The ISO document is not available for free, but the sections
relevant to Relational modelling are derived (essentially verbatim) from the
older FIPS 184, which is available, for instance, from the Internet Archive:
https://archive.org/details/federalinformati184nati/. Despite its age, the
latter document, and its Annex A in particular, is a good introduction to data
modelling.

Data Definition ~

Now that you have a data model, translating it into code is a relatively
straightforward task:

1. Import the library and optionally define aliases for the imported items you
   are going to use:
>
	vim9script

	import 'librelalg.vim' as ra

	type  Rel        = ra.Rel
	const Bool       = ra.Bool
	const Int        = ra.Int
	const Str        = ra.Str
	const ForeignKey = ra.ForeignKey
	const References = ra.References
	const Table      = ra.Table
	# etc.
<
   Note: in the following, for clarity and conciseness, we will write
   librelalg's names without prefix, as if aliases such as those above had
   been defined for all the imported items.

2. Define one base relation for each entity:
>
	var Buffer = Rel.new('Buffer', {
	    BufId:   Int,
	    BufName: Str,
	  },
	  [['BufId'], ['BufName']]
	)

	var Tag = Rel.new('Tag', {
	    BufId:   Int,
	    TagName: Str,
	    Line:    Int,
	    Column:  Int,
	  },
	  [['BufId', 'TagName']]
	)
<
   The three mandatory arguments of |librelalg.Rel.new()| are:

   a. a descriptive relation name;
   b. the relation schema: this is a |dict| mapping attribute names to the
      corresponding data types;
   c. the |list| of keys. Each relation must have at least one key. Each key is
      a |list| of attributes.

   Note: librelalg does not explicitly distinguish between a primary key and
   the alternate keys. The first listed key is conventionally considered the
   primary key.

3. Add the relevant constraints:
>
	Tag.OnInsertCheck('Line must be positive', (t) => t.Line > 0)
	Tag.OnInsertCheck('Column must be positive', (t) => t.Column > 0)
<
   A check clause defines a generic constraint, which is simply a function or
   a lambda that, given a tuple t, checks for some condition depending on t.
>
	ForeignKey(Tag, 'BufId')
	  ->References(Buffer, {key: 'BufId', verb: 'must appear in a valid'})
<
   |librelalg.ForeignKey()| defines a foreign key constraint, in this case
   from `BufId` in `Tag` to `BufId` in `Buffer`. A verb phrase (as read from the
   child to the parent entity in the data model) can be also specified: the
   verb phrase is used in error messages when the referential integrity is
   violated (see an example below). Using a mode of obligation ("must")
   typically makes the constraint violation easier to understand.

Data Manipulation ~

Once the database has been defined, each base relation may be populated with
tuples. Each tuple is just a dictionary conforming to the corresponding
relation schema. Let us insert some data:
>
	Buffer.InsertMany([
	  {BufId: 1, BufName: 'foo'},
	  {BufId: 2, BufName: 'bar'},
	  {BufId: 3, BufName: 'xyz'},
	])

	Tag.InsertMany([
	  {BufId: 1, TagName: 'kkk', Line: 1,  Column: 5},
	  {BufId: 1, TagName: 'zzz', Line: 2,  Column: 1},
	  {BufId: 1, TagName: 'abc', Line: 3,  Column: 9},
	  {BufId: 1, TagName: 'xyz', Line: 4,  Column: 1},
	  {BufId: 1, TagName: 'lll', Line: 4,  Column: 8},
	  {BufId: 2, TagName: 'abc', Line: 14, Column: 15},
	  {BufId: 3, TagName: 'abc', Line: 6,  Column: 3},
	])
<
If you want to inspect the content of a relation, you may print it as a table:
>
	echo Table(Buffer)
	echo Table(Tag)
<
The output looks as follows (note that the columns are in an arbitrary order):
>
	 Buffer
	───────────────
	 BufName BufId
	───────────────
	     foo     1
	     bar     2
	     xyz     3

	 Tag
	───────────────────────────
	 TagName Column Line BufId
	───────────────────────────
	     kkk      5    1     1
	     zzz      1    2     1
	     abc      9    3     1
	     xyz      1    4     1
	     lll      8    4     1
	     abc     15   14     2
	     abc      3    6     3
<
Of course, any attempt to violate a constraint is rejected with an error. For
example, trying to insert another buffer called `foo` will fail with
a duplicate key error, because `BufName` is a key:
>
	Buffer.Insert({BufId: 4, BufName: 'foo'})

	# Duplicate key: {BufName: 'foo'} already exists in relation Buffer.
<
Referential integrity is also guaranteed. For instance:
>
	Tag.Insert({BufId: 5, TagName: 'x', Line: 3, Column: 9})

	# Tag must appear in a valid Buffer:
	# {BufId: 5} not found in Buffer[BufId].
<
The error message uses the verb phrase from the corresponding foreign key.

And, of course, you are not allowed to insert an invalid line number either:
>
	Tag.Insert({BufId: 1, TagName: 'x', Line: 0, Column: 40})
<
This insertion is rejected with:
>
	Line must be positive
<
Updates and deletions are possible, too:
>
	Tag.Upsert({BufId: 1, TagName: 'abc', Line: 7, Column: 12})
	Tag.Delete((t) => t.Line < 2)
	echo Table(Tag->SortBy(['Line', 'Column']))
<
	Output:
>
	───────────────────────────
	 TagName Column Line BufId
	───────────────────────────
	     zzz      1    2     1
	     xyz      1    4     1
	     lll      8    4     1
	     abc      3    6     3
	     abc     12    7     1
	     abc     15   14     2
<
Existing tuples can be updated with |librelalg.Update()| based on some
predicate. A single tuple can also be updated using |librelalg.Upsert()| as in
the example above. For deletions, you must provide a predicate (typically, in
the form of a lambda) that the tuples to be deleted must satisfy.

Note: nulls are not supported. A properly designed database never needs nulls,
so this is not a loss of generality, and it is a great gain in simplicity and
semantic clarity.

Queries ~

The power of the Relational Model lies in its powerful query language as well
as in the simplicity and integrity of its data structures: librelalg provides
all the fundamental operations (set operations, selection, projection, joins,
renaming) as well as some extra operations (division, semi-joins, anti-joins,
group-by, etc.). All operators are implemented using a "push-based" strategy:
without entering into technical details, that means that queries are typically
expanded into tight loops and executed as efficiently as hand-written code.

Queries are expressions that are typically used as an argument to
|librelalg.Query()|. For instance, the query "Retrieve the tags in buffer
1 before line 6" can be formulated as follows:
>
	var result = Query(
	  From(Tag)->Select((t) => t.BufId == 1 && t.Line <= 6)
	)
	echo Table(result)
<
This query uses |librelalg.From()| to scan a relation and |librelalg.Select()|
to filter it. The query has been written using chain notation (->), but that
is not mandatory. Besides, using |librelalg.From()| is optional. So, the query
can be alternatively written like this:
>
	var result = Query(Tag->Select((t) => t.BufId == 1 && t.Line <= 6))
<
or like this:
>
	var result = Query(Select(Tag, (t) => t.BufId == 1 && t.Line <= 6))
<
In each case, the output is:
>
	───────────────────────────
	 TagName Column Line BufId
	───────────────────────────
	     zzz      1    2     1
	     xyz      1    4     1
	     lll      8    4     1
<
The result of a query is just a set of tuples, called a "derived" relation.
Contrary to base relations, derived relations do not have any associated keys,
constraints or indexes. They are just lists of homogeneous dictionaries.

If you want to get just the tag names and lines, you may add a projection:
>
	var filteredTags = Query(
	      From(Tag)
	    ->Select((t) => t.BufId == 1 && t.Line <= 6)
	    ->Project(['TagName', 'Line'])
	)
	echo Table(filteredTags)
<
This query also uses |librelalg.Project()|. Output:
>
	──────────────
	 TagName Line
	──────────────
	     zzz    2
	     xyz    4
	     lll    4
<
As another example, the natural join of `Buffer` and `Tag`, sorted by `BufId`
and `TagName`, can be written as follows:
>
	var btags = NatJoin(Buffer, Tag)->SortBy(['BufId', 'TagName'])
	echo Table(btags, {name: 'Buffer tags'})
<
This query uses |librelalg.NatJoin()| to join buffers with tags, and
|librelalg.SortBy()| to sort the result. Since |librelalg.SortBy()| is
a materializing operator (that is, it returns a relation instance), it is not
necessary to wrap the query inside |librelalg.Query()|, although it is not an
error to do so. See |librelalg-ra| for more details.

Output:
>
	 Buffer tags
	───────────────────────────────────
	 Column TagName BufName Line BufId
	───────────────────────────────────
	     12     abc     foo    7     1
	      8     lll     foo    4     1
	      1     xyz     foo    4     1
	      1     zzz     foo    2     1
	     15     abc     bar   14     2
	      3     abc     xyz    6     3
<
==============================================================================
2. Data definition language			*librelalg-ddl*

Classes ~
						*librelalg.Rel*
new{name}, {schema}, {keys} [, {opts}])
		Define a base relation (aka "relation object"). A base
		relation has a descriptive {name} (a |string| used in error
		messages) and is defined over a {schema}, which is a |dict|
		mapping attributes to their corresponding domains. The
		supported domains are:

		- Int: integers;
		- Str: strings;
		- Float: floats;
		- Bool: booleans.
		- List: lists.
		- Obj: objects.

		{keys} is a |list| of keys, where each key is a |list| of
		attributes. Every base relation must have at least one key.

		Example: A relation object R with two integer attributes A and
		C, a string attribute B, a composite primary key A,B and an
		alternate key C can be defined as follows:
>
		var R = Rel.new('R', {
		    A: Int,
		    B: Str,
		    C: Int,
		  }, [['A', 'B'], ['C']])
<
		When a relation has only one key, the outermost list can
		be omitted:
>
		var S = Rel.new('S', {A: Int, B: Str}, ['A', 'B'])
<
		When a key has only one attribute, it may be denoted by
		a |string|:
>
		var S = Rel.new('S', {A: Int, B: Str}, 'A')
<
		When there is no ambiguity (see the note below), this rule may
		be extended to multiple keys. For instance, the following
		relation has one composite key `['A', 'B']`, and two
		single-attribute keys `['B']`, and `['C']`:
>
		var T = Rel.new('T', {A: Int, B: Int, C: Int},
		                [['A', 'B'], 'B', 'C'])
<
		Note: the following relation has one composite key, not two
		one-single attribute keys:
>
		var U = Rel.new('U', {A: Int, B: Int}, ['A', 'B'])
<
		To define two single-attribute keys, you must use one of these
		forms:
>
		var V = Rel.new('V', {A: Int, B: Int}, [['A'], ['B'])
		var V = Rel.new('V', {A: Int, B: Int}, [['A'], 'B'])
		var V = Rel.new('V', {A: Int, B: Int}, ['A', ['B']])
<
		The last two forms are valid, but not recommended.

		{opts} is a dictionary of options. The only supported key is
		a boolean flag called "typecheck". Since only tuples
		conforming to the specified schema may be inserted into a base
		relation, by default an error is raised if a tuple is not
		compatible with the relation schema. This type checking can be
		turned off by setting "typecheck" to |false|. Omitting type
		checking may slightly improve the performance when inserting
		or updating tuples, but it is not recommended, because the
		gain may be negligible, and type checking is useful to detect
		errors.

		A |librelalg.Rel| object has the following read-only attributes:

		- "name": the name of the relation.
		- "schema": the relation schema.
		- "keys": the relation keys.
		- "attributes": the sorted list of attributes.
		- "key_attributes: the sorted list of key attributes.
		- "descriptors": the sorted list of descriptors (that is,
		  attributes that are not part of any key).

Delete([, {func}])
		Delete all the tuples of this base relation satisfying
		predicate {func}, which is a function that takes as an input
		a tuple t and returns |true| if t must be deleted, |false|
		otherwise. When {func} is not provided, all the tuples are
		deleted unconditionally, so the relation object becomes empty.

		Returns the deleted tuples.

Insert({tuple})
		Insert a {tuple} into this base relation. Return the updated
		relation object.

InsertMany({list})
		Insert a {list} of tuples into this base relation. Return the
		updated relation object.

IsEmpty()
		Return |true| if this relation is empty, |false| otherwise.

Lookup({key}, {list})
		Search for a tuple in this base relation whose {key}
		attributes match the values specified by the given {list}.
		A special KEY_NOT_FOUND value is returned if no tuple with
		the given value of the key can be found.

		For example:
>
		import 'librelalg.vim' as ra

		# [...]

		var R = Rel.new('R', {A: Int, B: Str}, 'A')
		R.InsertMany([
		    {A: 1, B: 'x'},
		    {A: 3, B: 'y'},
		    {A: 5, B: 'z'}
		])
		echo R.Lookup(['A'], [3])  # {A: 3, B: 'y'}
		echo R.Lookup(['A'], [9]) is ra.KEY_NOT_FOUND  # true
<
		When looking up for a tuple by key, using this function is
		generally faster than using |librelalg.Select()|, because
		lookup access uses an index associated to the key, whereas
		|librelalg.Select()| does a linear scan of the relation.

		Note that the returned value is a tuple, not a relation!

OnDeleteCheck({name}, {func})
		Add a generic constraint to this base relation. The constraint
		is defined by {func}, which is a |Funcref| taking as an input
		a tuple and returning |true| if the tuple satisfies the check,
		and |false| otherwise. {name} is an arbitrary string, which is
		shown in error messages when the constraint fails.

		{func} may also set additional information to be displayed
		when the constraint fails. See OnInsertCheck() for an example.

OnInsertCheck({name}, {func})
		Add a generic constraint to this base relation. The constraint
		is defined by {func}, which is a |Funcref| taking as an input
		a tuple and returning |true| if the tuple satisfies the check,
		and |false| otherwise. {name} is an arbitrary string, which is
		shown in error messages when the constraint fails.

		{func} may also set additional information to be displayed
		when the constraint fails, using |librelalg.FailedMsg()|. For
		instance, this is a more verbose version of a constraint from
		|librelalg-tutorial|:
>
		Tag.OnInsertCheck('Positive line check', (t) => {
		  if t.Line > 0
		    return true
		  endif

		  FailedMsg($'Line number must be positive. Got {t.Line}.')
		  return false
		})
<
Update({cond}, {func})
		Update all the tuples satisfying unary predicate {cond}.
		{cond} takes as input a tuple and return |true| if the tuple
		must be update, and |false| otherwise. The tuples selected for
		the update are updated by calling {func}, which is a function
		with no return value, which receives a tuples and updates it.

Upsert({tuple} [, {opts}])
		Replace a tuple in this base relation with a new {tuple}. The
		tuple that is replaced is the one with the same values of the
		primary key as {tuple} (recall that the primary key is
		conventionally defined as the first key that is defined when
		a relation is created). If no such tuple exists, by default
		{tuple} is inserted into the relation.

		{opts} is a dictionary of options. The only supported key is
		a boolean flag called "insert": when set to |false|, if no
		tuple exists with the same primary key as {tuple} then an
		error is raised. Examples:
>
		var R = Rel.new('R', {A: Int, B: Str}, 'A')

		R.Insert({A: 1, B: 'v'})
		R.Upsert({A: 1, B: 'w'})  # OK
		R.Upsert({A: 2, B: 'z'}, {insert: false})  # ERROR
		R.Upsert({A: 2, B: 'z'})  # OK (Upsert)

Functions ~
						*librelalg.FailedMsg()*
FailedMsg({msg})
		Used inside constraint checks to log an error message {msg},
		which is displayed when the constraint fails.

						*librelalg.ForeignKey()*
ForeignKey({rel}, {fkey})
		Declare the list of attributes {fkey} of relation {rel}
		a foreign key in {rel}. If the foreign key consists of one
		attribute then {fkey} can also be a string. Return a pair with
		the input arguments.

		This function must always be chained with
		|librelalg.References()|.

						*librelalg.References()*
References({foreignkey}, {rel}[, {opts}])
		Define a referential integrity constraint using {foreignkey}
		as the source, where {foreignkey} is the value returned by
		|librelalg.ForeignKey()|.

		{rel} is the target relation. {opts} is a dictionary of
		options, which may contain the following keys:

		- "key": the list of target attributes: this must be a key of
		  {rel}. If this is omitted, the target key is assumed to be
		  {rel}'s primary key (that is, the first key defined when
		  {rel} was created). When the foreign key consists of
		  a single attribute, this can be a string, too.

		- "verb": specifies a verb phrase read from child to parent.
		  The default verb phrase is "references". The verb phrase is
		  used in error messages when referential integrity is
		  violated. See |librelalg-tutorial| for an example.

						*librelalg.Transaction()*
Transaction({body})
		Execute {body} atomically. {body} is a function with no
		parameters and no return value, which typically contains
		statements that update some relation. If an error occurs
		during a transaction, all the changes operated by the
		transaction are reverted.

==============================================================================
3. Relational Algebra				*librelalg-ra*

The following paragraphs provide a high-level description of the inner working
of the Relational Algebra operators as defined by this library. Such
understanding is not strictly necessary to be able to use the library; it may
help, however, to make the most out of it. Feel free to skip to
|librelalg.operators| for the reference documentation about each operator.

This section uses the following terminology:

- A "tuple" is a |dict| mapping attributes to values. Values can be strings,
  integers, booleans, or floats.
- A "relation" instance (or simply an "instance") is a |list| of tuples.
- A "base relation" is a |librelalg.Rel| object.
- A "derived relation" is a relation instance obtained as the result of
  a query.
- A "relation" is a base relation or a relation instance.
- A "consumer" is any function with signature func({tuple}): void.
- A "continuation" is any function with signature func({Consumer}): void.

Intuitively, a consumer is a function that operates in some way on a tuple,
typically by invoking a continuation. A continuation receives as an input
a consumer and applies it to one or more tuples.

This is best described with an example. Consider the following simple query,
expressed using chaining:
>
	From(Relation)->Select(Pred)->Query()
<
When executed, |librelalg.From()| returns a continuation that looks like this:
>
	def Cont(Emit: Consumer)
	  for t in relation
	    Emit(t)
	  endfor
	enddef
<
The continuation `Cont` is passed to |librelalg.Select()| together with
a filter `Pred`. Select() builds and returns another continuation, which looks
as follows:
>
	def Cont2(Emit: Consumer)
	  def Consumer(t: Tuple)
	    if Pred(t)
	      Emit(t)
	    endif
	  enddef

	  Cont(Consumer)
	enddef
<
In practice, Select() defines a consumer to filter the tuples according to its
input predicate `Pred`, and then applies its input continuation `Cont` to that
consumer.

Finally, continuation `Cont2` is passed to |librelalg.Query()|, which defines
another consumer to materialize a relation, by generating code similar to the
following:
>
	var rel: Relation = []

	def Consumer2(t: Tuple)
	  add(rel, t)
	enddef

	Cont2(Consumer2)
<
Again, what Query() does is define a consumer (`Consumer2`) and apply
the input continuation (`Cont2`) to that consumer.

The original chained call:
>
	From(Relation)->Select(Pred)->Query()
<
can be equivalently re-written as follows:
>
	Query(Select(From(Relation), Pred))
<
Taking into account the foregoing discussion, if you try to expand the latter
expression, you will realize that the result is equivalent to the following
loop:
>
	var rel: Relation = []

	for t in Relation
	  if Pred(t)
	    add(rel, t)
	  endif
	endfor
<
which is pretty much what one would have written by hand (short of using
a built-in function such as |filternew()|, that is).

It should be clear at this point how Relational operators conceptually
transform relations into relations. Most operators fall into one of three
categories:

- "root" operators: these take as input a (base or derived) relation and emit
  tuples;
- "leaf" operators: these collect tuples and build a derived relation;
- "pipeline" operators: these process tuples and emit (transformed) tuples.

The most important rule is that each query should start (or end, if you use
the chaining notation `->`) with a leaf operator, such as |librelalg.Query()|,
which materializes a result (other commonly used leaf operators are
|librelalg.Sort()| and |librelalg.SortBy()|, and there are others). Without
a leaf operator, a query will just return a continuation—that is, a function.

To simplify writing queries, most operators accept base relations, relation
instances, and continuations transparently, so the user should not typically
worry about the above categorization, and can just write queries in a natural
way.

In the following, unless otherwise noted, whenever a parameter named {rel},
{rel1}, or {rel2} appears, that parameter denotes a base relation, a relation
instance, or a continuation.

Note: binary operators internally materialize their second argument
{rel2}—that is, they build a temporary instance from {rel2} (unless {rel2} is
already a relation, of course). This is something worth keeping in mind in
order to avoid writing queries that unnecessarily create temporary objects.

Note: some of the examples in the rest of this section are based on the sample
instance at the end of |librelalg-tutorial|, which we report again here for
reference, and which you may also find in doc/sample_schema.vim.
>
	 Buffer
	───────────────
	 BufName BufId
	───────────────
	     foo     1
	     bar     2
	     xyz     3

	 Tag
	───────────────────────────
	 TagName Column Line BufId
	───────────────────────────
	     zzz      1    2     1
	     abc     12    7     1
	     xyz      1    4     1
	     lll      8    4     1
	     abc     15   14     2
	     abc      3    6     3
<
						*librelalg.operators*
Functions ~
						*librelalg.AntiEquiJoin()*
AntiEquiJoin({rel1}, {rel2}[, {opts}])
		Perform the anti-equi-join of {rel1} and {rel2}. The result is
		the set of tuples of {rel1} that cannot be joined with any
		tuple in {rel2}. {opts} is used as in |librelalg.EquiJoin()|
		to specify the join attributes, except that the "prefix" key
		is not used.
>
		var r = [
		  {A: 0, B: 1},
		  {A: 1, B: 2},
		  {A: 2, B: 1},
		]
		var s = [
		  {B: 3, C: 1},
		  {B: 1, C: 0},
		]
		var result1 = Query(AntiEquiJoin(r, s, {on: 'B'}))
		var result2 = Query(
		  AntiEquiJoin(r, s, {onleft: 'A', onright: 'B'})
		)
		echo Table(result1)
		echo Table(result2)
<
		Result:
>
		─────
		 A B
		─────
		 1 2

		─────
		 A B
		─────
		 0 1
		 2 1
<
AntiJoin({rel1}, {rel2}, {func})		*librelalg.AntiJoin()*
		Perform the anti-join of {rel1} and {rel2}. The join condition
		is specified by {func}, which is defined as in
		|librelalg.Join()|. The result is the set of tuples of {rel1}
		that cannot be joined with any tuple in {rel2}. Examples:
>
		var r = [
		  {A: 1, B: 6},
		  {A: 1, B: 4},
		]
		var s = [
		  {C: 6, D: 40},
		  {C: 6, D: 50},
		  {C: 2, D: 60},
		]
		var result = Query(AntiJoin(r, s, (t, u) => t.B == u.C))
		echo Table(result)
<
		Output:
>
		─────
		 A B
		─────
		 1 4
<
		To obtain the buffers that have no tags before line 10:
>
		var result = Query(
		    AntiJoin(
		      Buffer,
		      Select(Tag, (t) => t.Line < 10),
		      (t, u) => t.BufId == u.BufId
		    )
		  )
		echo Table(result)
<
		Output:
>
		───────────────
		 BufName BufId
		───────────────
		     bar     2
<
		This is a pipeline operator, returning a continuation.

AvgBy({rel}, {groupby}, {attr} [, {name}])	*librelalg.AvgBy()*
		Group the tuples of relation {rel} with respect to a |list| of
		attributes {groupby}, and determine the average of the values
		of attribute {attr} in each group. When grouping by a single
		attribute, {groupby} may also be a |string|. The schema of the
		output relation consists of the grouping attributes plus the
		aggregate attribute. The name of the aggregate attribute is
		given by {name} (the default name is "avg").

		For instance:
>
		var r = [
		    {A: 1, B: 6},
		    {A: 1, B: 4},
		    {A: 2, B: 3}
		]
		var result = r->AvgBy('A', 'B')
		echo Table(result)
<
		Output:
>
		───────
		 A avg
		───────
		 1 5.0
		 2 3.0
<
		This is a leaf operator, returning a relation instance.

Build({rel})					*librelalg.Build()*
		A synonym of |librelalg.Query()|.

CoddDivide({rel1}, {rel2}[, {hint}])		*librelalg.CoddDivide()*
		Divide a relation {rel1} by another relation {rel2}. This is
		Relational division as originally defined by Codd, which
		requires the schema of the divisor to be a subset of the
		schema of the dividend—that is, R(X) ÷ S(Y) is defined only if
		Y ⊆ X.

		This operator builds the maximal¹ relation instance Q on
		X such that each tuple in Q joined with any tuple of
		S produces a tuple in R.

		¹Maximality here is relative to the values of the input. More
		precisely, the output is always a subset of π_X(R), the
		projection of R on X.

		Examples:
>
		var r = [
		  {A: 10, B: 'a', C: 6},
		  {A: 10, B: 'a', C: 4},
		  {A: 10, B: 'a', C: 2},
		  {A: 10, B: 'b', C: 2},
		  {A: 20, B: 'c', C: 6},
		  {A: 20, B: 'c', C: 2},
		]
		var s = [
		  {C: 6},
		  {C: 4},
		  {C: 2},
		]
		var result = Query(CoddDivide(r, s))
		echo Table(result)
<
		Output:
>
		──────
		  A B
		──────
		 10 a
<
		To obtain the names of the tags that appear in every buffer:
>
		var result = Query(
		    Project(Tag, ['BufId', 'TagName'])
		    ->CoddDivide(Project(Buffer, 'BufId'))
		)
		echo Table(result)
<
		Output:
>
		─────────
		 TagName
		─────────
		     abc
<
		If the divisor is an empty derived relation, then it does not
		carry any explicit information about its schema, because it is
		just an empty |list|. Hence, it is not possible to infer the
		schema of the quotient relation automatically. In this special
		case, a |list| of attributes {hint} may be used to specify the
		attributes of the divisor (if {hint} is not given, an empty
		schema is assumed). For instance:
>
		const result = Query(Buffer->CoddDivide([], ['BufId']))
<
		Output:
>
		 BufName
		─────────
		     foo
		     bar
		     xyz
<
		Note that {hint} is ignored if the divisor is not empty,
		because the schema can then be inferred from each tuple. If
		the divisor is a base relation then {hint} is not used either,
		because a base relation has an associated schema.

		This is a pipeline operator, returning a continuation. See
		also |Divide()|.

CountBy({rel}, {groupby}[, {attr}, {name}])	*librelalg.CountBy()*
		Group the tuples of a relation {rel} with respect to a |list|
		of attributes {groupby}, and count the number of tuples in
		each group. When grouping by a single attribute, {groupby} may
		also be a |string|. If {attr} is given and is not
		|null_string|, then count the number of distinct values of
		attribute {attr} in each group. The schema of the output
		relation consists of the grouping attributes plus the
		aggregate attribute. The name of the aggregate attribute is
		given by {name} (the default name is "count").

		For instance:
>
		var r = [
		    {N: 0, A: 100, B: 6},
		    {N: 1, A: 100, B: 4},
		    {N: 2, A: 200, B: 3},
		    {N: 3, A: 100, B: 5},
		    {N: 4, A: 200, B: 3},
		    {N: 5, A: 100, B: 6},
		]
		var result1 = r->CountBy('A')
		var result2 = r->CountBy('A', 'B')
		echo Table(result1, {name: 'Count all'})
		echo Table(result2, {name: 'Count distinct B'})
<
		Output:
>
		 Count all
		───────────
		   A count
		───────────
		 200     2
		 100     4

		 Count distinct B
		──────────────────
		          A count
		──────────────────
		        200     1
		        100     3
<
		This is a leaf operator, returning a relation instance.

Divide({rel1}, {rel2})				*librelalg.Divide()*
		Divide a relation {rel1} by another relation {rel2}. This is
		a form of generalized Relational division with no restriction
		on the schemas of the operands. Consider two relations R(X,Y)
		and S(Y,Z) where Y is the subset of attributes in common
		between R and S, hence X and Z are disjoint (any of these
		subsets may be empty). Then, R ÷ S = Q(X,Z) is the maximal¹
		relation instance on (X,Z) such that each tuple (x,z) in Q,
		when joined with any tuple of S and projected on (X,Y) gives
		a tuple in R. In other words, Q consists of the tuples (x,z)
		such that a tuple (x,y) exists in R for every tuple (y,z) in
		S.

		¹Maximality here is relative to the values of the input. More
		precisely, the output is always a subset of π_X(R) ⨯ π_Z(S),
		the cross-product of the projection of R on X and the
		projection of S on Z.

		Consider the following example:
>
		var SP = [  # Supplier S# supplies part P#
		  {'S#': 1, 'P#': 10},
		  {'S#': 1, 'P#': 20},
		  {'S#': 1, 'P#': 30},
		  {'S#': 2, 'P#': 10},
		  {'S#': 2, 'P#': 20},
		  {'S#': 3, 'P#': 20},
		  {'S#': 3, 'P#': 40},
		]
		var PJ = [  # Part P# is used in project J#
		  {'P#': 10, 'J#': 100},
		  {'P#': 20, 'J#': 100},
		  {'P#': 20, 'J#': 200},
		  {'P#': 30, 'J#': 200},
		  {'P#': 20, 'J#': 300},
		  {'P#': 40, 'J#': 300},
		]
<
		Then SP ÷ PJ and PJ ÷ SP are computed as follows:
>
		var sp_div_pj = Query(Divide(SP, PJ))
		var pj_div_sp = Query(Divide(PJ, SP))
		echo Table(sp_div_pj, {name: 'SP ÷ PJ'})
		echo Table(pj_div_sp, {name: 'PJ ÷ SP'})
<
		Output:
>
		 SP ÷ PJ
		─────────
		  S#  J#
		─────────
		   1 100
		   1 200
		   2 100
		   3 300

		 PJ ÷ SP
		─────────
		  S#  J#
		─────────
		   2 100
		   3 300
<
		The first query finds the pairs (S#,J#) such that supplier S#
		supplies all the parts used in project J#; the second query
		finds all the pairs (S#,J#) such that project J# uses all the
		parts supplied by supplier S#.

		A special case is when the schema of the divisor S(Y,Z) is
		a subset of the schema of the dividend R(X,Y)—that is, when
		Z is empty. Then, this operation reduces to |CoddDivide()|
		(although the latter is in general computed more efficiently),
		except for the special case of an empty divisor. If the
		divisor is empty, then |Divide()| always returns an empty
		relation, while |CoddDivide()| always returns π_X(R), the
		projection of the dividend on X.

						*librelalg.EquiJoin()*
EquiJoin({rel1}, {rel2}[, {opts}])
		Perform an equi-join between two relations {rel1} and {rel2}.

		{opts} is a dictionary that may contain the following keys:

		- "on": the list of common attributes on which to perform the
		  equi-join.

		- "onleft": a list of attributes of {rel1} on which to
		  perform the join. If this key is present then "onright"
		  should also be present.

		- "onright": a list of attributes of {rel2} on which to
		  perform the join. If this key is present then "onleft"
		  should also be present.

		- "prefix": see |librelalg.Join()|.

		When "onleft" and "onright" are used, they must be lists with
		the same length. Attributes at the same position in the two
		lists are compared for equality. Lists of one attribute may be
		replaced by strings. Note: if {opts} is omitted then this
		operator behaves like a Cartesian product.

		Examples:
>
		var r = [
		  {A: 1, B: 6},
		  {A: 1, B: 4},
		]
		var s = [
		  {C: 6, D: 40},
		  {C: 6, D: 50},
		  {C: 2, D: 60},
		]
		var result = Query(EquiJoin(r, s, {onleft: 'B', onright: 'C'}))
		echo Table(result)
<
		Output:
>
		──────────
		 A B C  D
		──────────
		 1 6 6 40
		 1 6 6 50
<
		To join all the buffers with all their tags:
>
		var result = Query(
		    EquiJoin(Buffer, Tag, {on: 'BufId', prefix: 'u_'})
		  )
		echo Table(result)
<
		Output:
>
		───────────────────────────────────────────
		 BufId BufName u_BufId TagName Line Column
		───────────────────────────────────────────
		     1     foo       1     zzz    2      1
		     1     foo       1     xyz    4      1
		     1     foo       1     lll    4      8
		     1     foo       1     abc    7     12
		     2     bar       2     abc   14     15
		     3     xyz       3     abc    6      3
<
		See |librelalg.Join()| for an equivalent formulation of the
		previous example.

		This is a pipeline operator, returning a continuation.

Extend({rel}, {func}[, {opts}])			*librelalg.Extend()*
	Extend each tuple of relation {rel} with a tuple computed by {func}.
	{func} receives a tuple and returns another tuple. {opts} is
	a dictionary of options. The only supported key is:

	- "force": if set to |true|, the extending tuple can have attributes
	  from {rel}, which are replaced by the new values. By default, the
	  tuple returned by {func} must not have any attribute in common with
	  {rel}.

	For example:
>
	var r = [{A: 1}, {A: 3}, {A: 5}]

	var result1 = Query(
	    Extend(r, (t): dict<any> => {
	       return {B: t.A * 2, C: -t.A}
	    })
	)
	var result2 = Query(
	    Extend(r, (t): dict<any> => {
	       return {A: t.A - 1, C: t.A + 1}
	    }, {force: true})
	)
	echo Table(result1)
	echo Table(result2)
<
	The output is:
>
	─────────
	 A  B  C
	─────────
	 1  2 -1
	 3  6 -3
	 5 10 -5

	─────
	 A C
	─────
	 0 2
	 2 4
	 4 6
<
	Note that {func} should consistently return tuples over the same,
	fixed, schema for the result to be a valid relation instance.

	This is a pipeline operator, returning a continuation.

Filter({rel}, {func})				*librelalg.Filter()*
		Filter a relation using predicate {func}. Only the tuples for
		which {func} returns |true| are selected. This is similar to
		|librelalg.Select()|, but potentially faster, as it is
		essentially a thin wrapper around |filter()|.

		This is a leaf operator, returning a relation instance.

Foreach({rel})					*librelalg.Foreach()*
		A synonym of |librelalg.From()|.

Frame({rel}, {list}[, {opts}])			*librelalg.Frame()*
		Virtually partition a relation {rel} based on a {list} of
		attributes, extend the relation with a new attribute and,
		within this attribute, assign a distinct integer value to each
		distinct member of the partition.

		{opts} is a dictionary of options with the following keys:

		- "name": the name of the added attribute. The standard name
		  of the added attribute is "fid" (for "frame ID").

		- "inplace": if |true|, modify the relation in-place instead
		  of creating new tuples. The default is |false|.

		For instance:
>
		var r = [
		    {A: 10, B: 'a', C: 'x'},
		    {A: 20, B: 'b', C: 'y'},
		    {A: 30, B: 'a', C: 'x'},
		    {A: 40, B: 'a', C: 'x'},
		    {A: 50, B: 'b', C: 'x'},
		    {A: 60, B: 'b', C: 'y'},
		    {A: 70, B: 'a', C: 'y'},
		  ]
		var result = Query(r->Frame(['B', 'C']))
		echo Table(result)
<
		Output:
>
		────────────
		  A B C fid
		────────────
		 10 a x   0
		 20 b y   1
		 30 a x   0
		 40 a x   0
		 50 b x   2
		 60 b y   1
		 70 a y   3
<
		This is a pipeline operator, returning a continuation.

From({rel})					*librelalg.From()*
		Return a continuation that iterates over the tuples of
		a relation {rel} and emits each tuple. If {rel} is already
		a continuation, then this function just returns it. This is
		a root operator, that is, an operator that starts a query.

Intersect({rel1}, {rel2})			*librelalg.Intersect()*
		Return the intersection of two relations {rel1} and {rel2}.
		Note: the relations must be defined on the same schema!

		For instance:
>
		var r = [
		  {A: 1, B: 'x'},
		  {A: 3, B: 'y'},
		  {A: 5, B: 'y'},
		]
		var s = [
		  {A: 3, B: 'y'},
		  {A: 6, B: 'y'},
		]
		var result = Query(Intersect(r, s))
		echo Table(result)
<
		The output is:
>
		─────
		 A B
		─────
		 3 y
<
		This is a pipeline operator, returning a continuation.

Join({rel1}, {rel2}, {func} [, {opts}])		*librelalg.Join()*
		Join two relations {rel1} and {rel2}. The join condition is
		specified by {func}, which is a |Funcref| that takes as an
		input two tuples t1 and t2 and returns |true| if t1 and t2
		should be joined, and |false| otherwise.

		{opts} is a a dictionary of options. The only supported
		options is:

		- "prefix": a string that is prepended to each attribute of
		  {rel2} that is also an attribute of {rel1}. The default
		  prefix is an underscore.

		A non-empty prefix is mandatory if the relations to be joined
		have some attributes in common, because the attributes in
		a relation must be all distinct. The prefix must not be used
		inside {func}.

		Examples:
>
		var r = [
		  {A: 1, B: 6},
		  {A: 1, B: 4},
		]
		var s = [
		  {C: 6, D: 40},
		  {C: 6, D: 50},
		  {C: 2, D: 60},
		]
		var result = Query(Join(r, s, (t, u) => t.B == u.C))
		echo Table(result)
<
		Output:
>
		──────────
		 A B C  D
		──────────
		 1 6 6 40
		 1 6 6 50
<
		This join can also be done with |librelalg.EquiJoin()|. But
		with this operator you may join on arbitrary conditions:
>
		var result2 = Query(Join(r, s, (t, u) => t.B > u.C))
		echo Table(result2)
<
		Output:
>
		──────────
		 A B C  D
		──────────
		 1 6 2 60
		 1 4 2 60
<
		To join `Buffer` with `Tag` on the common `BufId` attribute:
>
		var result = Query(
		    Join(Buffer, Tag,
		    (t, u) => t.BufId == u.BufId, {prefix: 'u_'})
		  )
		echo Table(result)
<
		Output:
>
		───────────────────────────────────────────
		 BufId BufName u_BufId TagName Line Column
		───────────────────────────────────────────
		     1     foo       1     zzz    2      1
		     1     foo       1     xyz    4      1
		     1     foo       1     lll    4      8
		     1     foo       1     abc    7     12
		     2     bar       2     abc   14     15
		     3     xyz       3     abc    6      3
<
		If the prefix in the query above were empty then the query
		would produce an error:
>
		Key already exists: BufId
<
		because the attribute `BufId` exists both in `Buffer` and in
		`Tag`.

		This is a pipeline operator, returning a continuation.

						*librelalg.LeftEquiJoin()*
LeftEquiJoin({rel1}, {rel2}[, {opts}])
		Perform the left outer join of two relations {rel1} and {rel2}
		based on an equality condition. {opts} is a dictionary of
		options. In addition to the same keys supported by
		|librelalg.EquiJoin()|, {opts} also supports the following
		keys:

		- "filler": an arbitrary relation with the same schema as
		  {rel2}.

		The result is the equi-join between the input relations,
		extended (by union) with the cross-product of the filler
		relation and the set of tuples in {rel1} that do not match any
		tuple in {rel2}.

		Note that if no filler relation is provided, this operator
		behaves like an equi-join.

		Note also that this function does not check whether the filler
		conforms to the schema of {rel2} (in general, this is not
		possible because {rel2} might be an empty relation instance
		carrying no explicit information about its schema).

		For instance:
>
		var r = [
		    {A: 1, B: 'x'},
		    {A: 2, B: 'x'},
		    {A: 3, B: 'y'},
		    {A: 4, B: 'z'},
		    {A: 5, B: 'w'},
		]
		var s = [
		    {C: 'x', A: 10},
		    {C: 'w', A: 15},
		    {C: 'z', A: 20},
		    {C: 'z', A: 30},
		]
		var result = Query(
		    LeftEquiJoin(r, s,
		      {onleft: 'B', onright: 'C', filler: [{C: 'NA', A: 0}]})
		)
		echo Table(result)
<
		Output:
>
		───────────
		 A B  C _A
		───────────
		 1 x  x 10
		 2 x  x 10
		 3 y NA  0
		 4 z  z 20
		 4 z  z 30
		 5 w NA  0
<
LeftNatJoin({rel1}, {rel2}[, {opts}])		*librelalg.LeftNatJoin()*
		Perform the left natural join of two relations {rel1} and
		{rel2}. {opts} is dictionary of options, which may be used to
		specify a filler relation, as in |librelalg.LeftEquiJoin()|.

		The returned relation is the natural join between the input
		relations extended (by union) with the cross-product of the
		filler relation and the set of tuples in {rel1} that do not
		match any tuple in {rel2}.

		Note that if no filler relation is provided, this operator
		behaves like a natural join.

		For instance:
>
		var r = [
		    {A: 1, B: 'x'},
		    {A: 2, B: 'x'},
		    {A: 3, B: 'y'},
		    {A: 4, B: 'z'},
		    {A: 5, B: 'w'},
		]
		var s = [
		    {B: 'x', C: 10},
		    {B: 'z', C: 20},
		    {B: 'z', C: 30},
		]
		var result = Query(LeftNatJoin(r, s, {filler: [{C: -1}]}))
		echo Table(result)
<
		Output:
>
		────────
		 A B  C
		────────
		 1 x 10
		 2 x 10
		 3 y -1
		 4 z 20
		 4 z 30
		 5 w -1
<
		This is a pipeline operator, returning a continuation.

MaxBy({rel}, {groupby}, {attr} [, {name}])	*librelalg.MaxBy()*
		Group the tuples of a relation {rel} with respect to a |list|
		of attributes {groupby}, and determine the maximum value of
		attribute {attr} in each group. When grouping by a single
		attribute, {groupby} can also be a |string|. The schema of the
		output relation consists of the grouping attributes plus the
		aggregate attribute. The name of the aggregate attribute is
		given by {name} (the default name is "max").

		For instance:
>
		var r = [
		    {A: 100, B: 6},
		    {A: 100, B: 4},
		    {A: 200, B: 3}
		]
		var result = r->MaxBy('A', 'B')
		echo Table(result)
<
		Output:
>
		─────────
		   A max
		─────────
		 200   3
		 100   6
<
		This is a leaf operator, returning a relation instance.

MinBy({rel}, {groupby}, {attr} [, {name}]	*librelalg.MinBy()*
		Group the tuples of a relation {rel} with respect to a |list|
		of attributes {groupby}, and determine the minimum value of
		attribute {attr} in each group. When grouping by a single
		attribute, {groupby} can also be a |string|. The schema of the
		output relation consists of the grouping attributes plus the
		aggregate attribute. The name of the aggregate attribute is
		given by {name} (the default name is "min").

		For instance:
>
		var r = [
		    {A: 100, B: 6},
		    {A: 100, B: 4},
		    {A: 200, B: 3}
		]
		var result = r->MinBy('A', 'B')
		echo Table(result)
<
		Output:
>
		─────────
		 min   A
		─────────
		   3 200
		   4 100
<
		This is a leaf operator, returning a relation instance.

Minus({rel1}, {rel2})				*librelalg.Minus()*
		Subtract relation {rel2} from relation {rel1}. Note: the
		relations must be defined on the same schema!

		For instance:
>
		var r = [
		  {A: 1, B: 'x'},
		  {A: 3, B: 'y'},
		  {A: 5, B: 'y'},
		]
		var s = [
		  {A: 3, B: 'y'},
		  {A: 6, B: 'y'},
		]
		var result = Query(Minus(r, s))
		echo Table(result)
<
		The output is:
>
		─────
		 A B
		─────
		 1 x
		 5 y
<
		This is a pipeline operator, returning a continuation.

NatJoin({rel1}, {rel2})				*librelalg.NatJoin()*
		Perform the natural join of two relations {rel1} and {rel2}.
		Examples:
>
		var r = [
		  {A: 1, B: 6},
		  {A: 1, B: 4},
		]
		var s = [
		  {B: 6, C: 40},
		  {B: 6, C: 50},
		  {B: 2, C: 60},
		]
		var result = Query(NatJoin(r, s))
		echo Table(result)
<
		Output:
>
		────────
		 A B  C
		────────
		 1 6 40
		 1 6 50
<
		To join `Buffer` with `Tag` on the common `BufId` attribute:
>
		var result = Query(NatJoin(Buffer, Tag))
		echo Table(result)
<
		Output:
>
		───────────────────────────────────
		 Column TagName BufName Line BufId
		───────────────────────────────────
		      1     zzz     foo    2     1
		     12     abc     foo    7     1
		      1     xyz     foo    4     1
		      8     lll     foo    4     1
		     15     abc     bar   14     2
		      3     abc     xyz    6     3
<
		This is a pipeline operator, returning a continuation.

Query({rel})					*librelalg.Query()*
		Materialize a relation {rel}. If {rel} is a continuation,
		build a new instance by consuming the tuples emitted by the
		continuation. If {rel} is already a (base or derived)
		relation, return the relation instance directly.

		This is a leaf operator, always returning a relation instance.

Rename({rel}, {what})				*librelalg.Rename()*
		Rename the attributes of a relation {rel}. {what} is
		a dictionary mapping the old names to the new names. For
		example:
>
		var r = [
		    {A: 1, B: 'u'},
		    {A: 2, B: 'v'}
		]
		var s = Query(Rename(r, {A: 'X', B: 'Y'}))
		echo Table(s)
<
		The output is:
>
		─────
		 X Y
		─────
		 1 u
		 2 v
<
		Only the schema of the relation (that is, the header of the
		table) is changed: the instance remains the same.

		This is a pipeline operator, returning a continuation.

Product({rel1}, {rel2} [, {opts}])		*librelalg.Product()*
		Perform the cross product of two relations {rel1} and {rel2}.
		For {opts}, see |librelalg.Join()|. Examples:
>
		var r = [
		  {A: 1, B: 6},
		  {A: 1, B: 4},
		]
		var s = [
		  {C: 9, D: 40},
		  {C: 7, D: 50},
		  {C: 4, D: 60},
		]
		var result = Query(Product(r, s))
		echo Table(result)
<
		Output:
>
		──────────
		 A B C  D
		──────────
		 1 6 9 40
		 1 6 7 50
		 1 6 4 60
		 1 4 9 40
		 1 4 7 50
		 1 4 4 60
<
		To obtain all the sorted pairs of tag names:
>
		var Tagname = Project(Tag, 'TagName')
		var result  = Query(
		      Product(Tagname, Tagname, {prefix: 'u_'})
		    ->Select((t) => t.TagName < t.u_TagName)
		    ->SortBy(['TagName', 'u_TagName'])
		)
		echo Table(result)
<
		Output:
>
		───────────────────
		 TagName u_TagName
		───────────────────
		     abc       lll
		     abc       xyz
		     abc       zzz
		     lll       xyz
		     lll       zzz
		     xyz       zzz
<
		This is a pipeline operator, returning a continuation.

Project({rel}, {attrs})				*librelalg.Project()*
		Perform a projection of a relation {rel} on the list of
		attributes {attrs}. When {attrs} is a single attribute,
		a |string| can also be used. Examples:
>
		var r = [
		  {A: 1, B: 'one', C: 10},
		  {A: 2, B: 'one', C: 10},
		  {A: 3, B: 'one', C: 15},
		  {A: 4, B: 'two', C: 20},
		  {A: 5, B: 'two', C: 20},
		  {A: 5, B: 'six', C: 60},
		]
		var result = Query(Project(r, ['B', 'C']))
		echo Table(result)
<
		Output:
>
		────────
		   B  C
		────────
		 one 10
		 one 15
		 two 20
		 six 60
<
		To obtain all the tag names:
>
		var result = Query(Project(Tag, 'TagName'))
		echo Table(result)
<
		Output:
>
		 TagName
		─────────
		     zzz
		     abc
		     xyz
		     lll
<
		This is a pipeline operator, returning a continuation.

Scan({rel})					*librelalg.Scan()*
		A synonym of |librelalg.From()|.

Select({rel}, {func})				*librelalg.Select()*
		Filter the tuples of a relation {rel} based on a predicate
		{func}, which is a |Funcref| that takes as an input a tuple
		t and returns |true| if t must be selected, otherwise it
		returns |false|. Examples:
>
		var r = [
		  {A: 1, B: 5, C: 10},
		  {A: 2, B: 8, C: 10},
		  {A: 3, B: 7, C: 14},
		  {A: 4, B: 8, C: 20},
		  {A: 5, B: 2, C: 20},
		  {A: 5, B: 1, C:  2},
		]
		var result = Query(Select(r, (t) => t.C == 2 * t.B))
		echo Table(result)
<
		Output:
>
		────────
		 A B  C
		────────
		 1 5 10
		 3 7 14
		 5 1  2
<
		To select all the tags after line 3 in buffer 1:
>
		var result = Query(
		    Select(Tag, (t) => t.BufId == 1 && t.Line > 3)
		  )
		echo Table(result)
<
		Output:
>
		───────────────────────────
		 TagName Column Line BufId
		───────────────────────────
		     abc     12    7     1
		     xyz      1    4     1
		     lll      8    4     1
<
		This is a pipeline operator, returning a continuation. See
		also |librelalg.Lookup()| and |librelalg.Filter()|.

SemiJoin({rel1}, {rel2}, {func})		*librelalg.SemiJoin()*
		Perform the semi-join of two relations {rel1} and {rel2}. This
		is the same as joining {rel1} with {rel2} (see
		|librelalg.Join()|), then projecting the result on the
		attributes of {rel1}. Examples:
>
		var r = [
		  {A: 1, B: 6},
		  {A: 1, B: 4},
		]
		var s = [
		  {C: 6, D: 40},
		  {C: 6, D: 50},
		  {C: 2, D: 60},
		]
		var result = Query(SemiJoin(r, s, (t, u) => t.B == u.C))
		echo Table(result)
<
		Output:
>
		─────
		 A B
		─────
		 1 6
<
		To obtain the buffers with tags beyond column 10:
>
		var result = Query(
		      SemiJoin(Buffer, Tag,
		               (t, u) => t.BufId == u.BufId && u.Column > 10)
		  )
		echo Table(result)
<
		Output:
>
		───────────────
		 BufName BufId
		───────────────
		     foo     1
		     bar     2
<
		This is a pipeline operator, returning a continuation.

Sort({rel}, {func})				*librelalg.Sort()*
		Materialize a relation by sorting its tuples according to the
		criterion specified by {func}. The sorting predicate {func} is
		a |Funcref| that takes as an input two tuples t1 and t2, and
		returns a negative |number| if t1 precedes t2, a positive |number|
		if t1 follows t2, and zero if t1 equals t2. Examples:
>
		var r = [
		  {A: 1, B: 6},
		  {A: 2, B: 4},
		  {A: 3, B: 9},
		  {A: 4, B: 2},
		]
		var result = Query(Sort(r, (t, u): number => t.B - u.B))
		echo Table(result)
<
		Output:
>
		─────
		 A B
		─────
		 4 2
		 2 4
		 1 6
		 3 9
<
		To sort tags by line number (regardless of the buffers) in
		decreasing order:
>
		var result = Tag->Sort((t1, t2): number => t2.Line - t1.Line)
		echo Table(result)
<
		Output:
>
		───────────────────────────
		 TagName Column Line BufId
		───────────────────────────
		     abc     15   14     2
		     abc     12    7     1
		     abc      3    6     3
		     xyz      1    4     1
		     lll      8    4     1
		     zzz      1    2     1
<
		See |librelalg.SortBy()| for an equivalent, but simpler,
		formulation of this query.

		This is a leaf operator, returning a relation instance. See
		also |librelalg.SortBy()|.

SortBy({rel}, {attrs} [, {opts}])		*librelalg.SortBy()*
		Materialize a relation {rel} by sorting the tuples according
		to the specified list of attributes {attrs}. When {attrs} is
		a single attribute, a |string| may also be used. For instance:
>
		var result = Tag->SortBy('Line')
		echo Table(result)
<
		Output:
>
		───────────────────────────
		 TagName Column Line BufId
		───────────────────────────
		     zzz      1    2     1
		     xyz      1    4     1
		     lll      8    4     1
		     abc      3    6     3
		     abc     12    7     1
		     abc     15   14     2
<
		{opts} is a list that specifies, for each sorting attribute,
		whether to sort the values of that attribute in increasing or
		decreasing order. For instance:
>
		var result = From(Tag)
		               ->SortBy(['TagName', 'Column'], ['i', 'd'])
		echo Table(result)
<
		Output:
>
		 TagName Column Line BufId
		───────────────────────────
		     abc     15   14     2
		     abc     12    7     1
		     abc      3    6     3
		     lll      8    4     1
		     xyz      1    4     1
		     zzz      1    2     1
<
		The tuples of `Tag` are sorted in increasing order (`'i'`)
		with respect to `TagName`, and then the tags with the same
		name are sorted in decreasing order (`'d'`) with respect to
		`Column`.

		This is a leaf operator, returning a relation instance. See
		also |librelalg.Sort()|.

SumBy({rel}, {groupby}, {attr} [, {name}])	*librelalg.SumBy()*
		Group the tuples of a relation {rel} with respect to a list of
		attributes {groupby}, and sum the values of attribute {attr}
		in each group. When grouping by a single attribute, {groupby}
		can also be a |string|. The schema of the output relation
		consists of the grouping attributes plus the aggregate
		attribute. The name of the aggregate attribute is given by
		{name} (the default name is "sum").

		For instance:
>
		var r = [
		    {A: 100, B: 6},
		    {A: 100, B: 4},
		    {A: 200, B: 3}
		]
		var result = r->SumBy('A', 'B')
		echo Table(result)
<
		Output:
>
		─────────
		   A sum
		─────────
		 200   3
		 100  10
<
		This is a leaf operator, returning a relation instance.

Union({rel1}, {rel2})				*librelalg.Union()*
		Return the union of two relations {rel1} and {rel2}. Note: the
		relations must be defined on the same schema!

		For instance:
>
		var r = [
		    {A: 1, B: 'x'},
		    {A: 3, B: 'y'},
		    {A: 5, B: 'y'}
		]
		var s = [
		    {A: 3, B: 'y'},
		    {A: 6, B: 'y'},
		    {A: 1, B: 'x'},
		]
		var result = Query(Union(r, s))
		echo Table(result)
<
		The output is:
>
		─────
		 A B
		─────
		 1 x
		 3 y
		 5 y
		 6 y
<
		This is a leaf operator, returning a relation instance.

==============================================================================
4. Aggregate functions				*librelalg-aggregates*

Aggregate functions are implemented as pipeline operators. For example:
>
	# Count the number of tuples
	echo Table([{A: 9}, {A: 4}, {A: 6}]->Sum('A'))
<
The output is a relation:
>
	──────
	  sum
	──────
	 19.0
<
If you want to get a scalar value, you may wrap an aggregate function in your
own scalar leaf operator. For instance:
>
	def ScalarSum(R: any, attr: string): float
	  return Query(R->Sum(attr))[0].sum
	enddef

	echo [{A: 9}, {A: 4}, {A: 6}]->ScalarSum('A')  # 19.0
<
Aggregate functions can also be chained after |librelalg.GroupBy()|.

Aggregate({arg}, {func})			*librelalg.Aggregate()*
		Compute an aggregated result by executing {func} on {arg}.
		{func} is a function that receives a relation instance,
		relation object, or continuation, and outputs another relation
		or continuation (so, in general, an aggregate function does
		not have to return a single value, or even a single tuple).

		If {arg} is a base relation, relation instance or continuation
		then it is passed to {func} directly, and the result is
		returned.

		{arg} may also be the value returned by |librelalg.GroupBy()|.
		In this case, {func} is called once for each group.

		This function can be used to define custom aggregates. For the
		most common cases, you may use the predefined aggregate
		functions provided by librelalg and documented below.

Avg({arg}, {attr}[, {opts}])			*librelalg.avg()*
		Return the average of the values of attribute {attr}. For
		{arg}, see |librelalg.Aggregate()|. {opts} can be used to set
		the name of the aggregate attribute, which is "avg" by
		default. For example:
>
		echo Query(
		  [{A: 9}, {A: 7}, {A: 11}]->Avg('A', {name: 'mean'})
		)
		# [{'mean': 9.0}]
<
		To return the average tag's column number:
>
		var avg = Query(Tag->Avg('Column'))[0].avg  # .666667
<
Count({arg}[, {opts}])				*librelalg.Count()*
		Return the number of tuples of a relation {rel}. For {arg},
		see |librelalg.Aggregate()|. {opts} is the same as in
		|librelalg.Avg()|. Examples:
>
		echo Query([{A: 9}, {A: 7}]->Count())  # [{'count': 2}]
<
		To compute the number of buffers:
>
		var nBuf = Query(Buffer->Count())[0].count    # 3
<
CountDistinct({arg}, {attr}[, {opts}])		*librelalg.CountDistinct()*
		Return the number of distinct values in attribute {attr} of
		a relation {rel}. For {arg}, see |librelalg.Aggregate()|.
		Examples: Examples:
>
		echo Query([
		  {X: 0, Y: 1},
		  {X: 1, Y: 1},
		  {X: 2, Y: 3},
		  {X: 3, Y: 3},
		]->CountDistinct('Y'))  # [{count: 2}]
<
		To return the number of distinct tag names:
>
		var nDistinctTags = Query(
		  Tag->CountDistinct('TagName')
		)[0].count  # 4
<
ListAggregate({arg}, {attr}[, {opts}])		*librelalg.ListAgg()*
		Return the values of attribute {attr} in {arg} as |list|s,
		possibly sorted in some way. For {arg}, see
		|librelalg.Aggregate()|.

		{opts} is a dictionary of options, which may contain the
		following keys:

		- "name": the name of the aggregate attribute. By default,
		  {attr} is used.

		- "how": specifies how to sort each list. For the possible
		  values, see |sort()|. By default, the lists are left
		  unsorted.

		- "unique": if |true| then second and succeeding copies of
		  repeated adjacent values are removed. The defauls it
		  |false|.

		Examples:
>
		echo Query([{A: 9}, {A: 7}, {A: 11}]->ListAggregate('A'))
		# [{A: [9, 7, 11]}]

		echo Query(
		  [{A: 9}, {A: 7}, {A: 11}]->ListAggregate('A', {how: 'f'})
		)
		# [7, 9, 11]

		echo Query(
		  [{A: 9}, {A: 7}, {A: 11}]->ListAggregate('A', {how: ''})
		)
		# [11, 7, 9]

		echo Query([{A: 9}, {A: 7}, {A: 7}]->ListAggregate('A'))
		# [9, 7, 7]

		echo Query(
		  [{A: 9}, {A: 7}, {A: 7}]
		  ->ListAggregate('A', {how: 'f', unique: true})
		)
		# [7, 9]
<
		To build the sorted lists of tags in each buffer, sorted by
		buffer:
>
		var result = From(Tag)
		  ->GroupBy('BufId')
		  ->ListAggregate('TagName', {how: ''})
		  ->SortBy('BufId')

		echo Table(result)
<
		Output:
>
		────────────────────────────────────
		                    aggrValue BufId
		────────────────────────────────────
		 ['abc', 'lll', 'xyz', 'zzz']     1
		                      ['abc']     2
		                      ['abc']     3
<
Min({agr}, {attr}[, {opts}])			*librelalg.Min()*
		Return the minimum value of attribute {attr} in {rel}.
		{opts} is as in |librelalg.Avg()|. Examples:
>
		echo Query(
		  [{A: 9}, {A: 7}, {A: 11}]->Min('A')
		)
		# [{min: 7}]
<
		To return the minimum buffer id:
>
		var minBufId = Query(Buffer->Min('BufId'))[0].min  # 1
<
Max({arg}, {attr}[, {opts}])			*librelalg.Max()*
		Return the maximum value of attribute {attr} in {arg}.
		{opts} is as in |librelalg.Avg()|. Examples:
>
		echo Query(
		  [{A: 9}, {A: 7}, {A: 11}]->Max('A')
		)
		# [{max: 11}]
<
		To return the maximum column of a tag:
>
		var maxCol = Query(Tag->Max('Column'))[0].max  # 15
<
StringAggregate({arg}, {attr}[, {opts}])	*librelalg.StringAgg()*
		Return the values of attribute {attr} in {arg} joined into
		|string|s. For {arg}, see |librelalg.Aggregate()|. {opts} is
		as in |librelalg.ListAggregate(), but in addition it supports
		a "sep" key to define a separator between the joined items.
		The default separator is the empty string.
		Examples:
>
		echo Query(
		  [{A: 9}, {A: 7}, {A: 11}, {A: 9}]
		  ->StringAggregate('A', {sep: ', ', how: 'n'})
		)
		# [{A: '7, 9, 9, 11'}]

		echo Query(
		  [{A: 9}, {A: 7}, {A: 11}, {A: 9}]
		  ->StringAggregate('A', {how: 'n', unique: true})
		)
		# [{A: '7911'}]
<
		To return the tags in each buffer joined into a string, sorted
		by buffer:
>
		var result = Tag
		  ->GroupBy('BufId')
		  ->StringAggregate('TagName', {sep: ',', how: ''})
		  ->SortBy('BufId')

		echo Table(result)
<
		Output:
>
		───────────────────────
		       aggrValue BufId
		───────────────────────
		 abc,lll,xyz,zzz     1
		             abc     2
		             abc     3
<
Sum({arg}, {attr}[, {opts}])			*librelalg.Sum()*
		Return the sum of the values of attribute {attr} in {rel}.
		{opts} is as in |librelalg.Avg()|. Examples:
>
		echo Query([{A: 9}, {A: 7}, {A: 11}]->Sum('A'))
		# [{sum: 27.0}]
<
		To compute the sum of all tags' columns:
>
		var colSum = Query(Tag->Sum('Column'))[0].sum  # 40.0
<
==============================================================================
5. Other functions				*librelalg-other-functions*

DictTransform({rel}, {func}[, {flatten}])	*librelalg.DictTransform()*
		Transform a base or derived relation {rel} into a |dict|
		object. {func} is a function that receives a tuple and returns
		an arbitrary |dict|: the returned dictionary is merged into
		the result, so that items sharing the same dictionary key are
		appended together into a list. For example:
>
		var r = [
		  {X: 'a', Y: 6},
		  {X: 'b', Y: 2},
		  {X: 'a', Y: 4},
		]
		echo DictTransform(r, (t) => ({[t.X]: t.Y}))
<
		Output:
>
		{a: [6, 4], b: [2]}
<
		Note that the order of the items in the lists is arbitrary.

		When {flatten} is |true|, singleton lists are replaced by
		their only item. For instance:
>
		var r = [
		  {X: 'a', Y: 6},
		  {X: 'b', Y: 2}
		]
		echo DictTransform(r, (t) => ({[t.X]: t.Y}), true)
<
		Output:
>
		{a: 6, b: 2}
<
EquiJoinPred({list1}[, {list2}])		*librelalg.EquiJoinPred()*
		Return a predicate for comparing two tuples using the
		attributes {list1} of the first tuple and the attributes
		{list2} of the second tuple. The comparison is elementwise
		equality. When {list2} is not provided, {list1} is used for
		the second tuple, too. The returned function can be used as an
		argument to the various join operators.

		For example, to find the tag names that are also buffer names:
>
		var Pred = EquiJoinPred(['BufName'], ['TagName'])
		var result = Query(SemiJoin(Buffer, Tag, Pred))
<
		This will join on the condition:
>
		Buffer.BufName == Tag.TagName
<
		Output:
>
		───────────────
		 BufName BufId
		───────────────
		     xyz     3
<
GroupBy({rel}, {groupby})			*librelalg.GroupBy()*
		Group the tuples of a relation {rel} with respect to a |list|
		of attributes {groupby}. When grouping by a single attribute,
		{groupby} can also be a |string|. The result is a dictionary
		containing the list of group-by attributes and the groups.
		Typically, the result of GroupBy() is passed to an aggregate
		function: see |librelalg-aggregates| for more examples.
>
		var r = [
		    {A: 10, B: 'a', C: 'x', D: 4},
		    {A: 20, B: 'b', C: 'x', D: 7},
		    {A: 30, B: 'a', C: 'x', D: 3},
		    {A: 40, B: 'a', C: 'x', D: 0},
		    {A: 50, B: 'b', C: 'x', D: 3},
		    {A: 60, B: 'b', C: 'y', D: 9},
		    {A: 70, B: 'a', C: 'y', D: 3},
		  ]
		var result = r->GroupBy(['B', 'C'])
		echo result
<
		Output:
>
		{
		  attributes: ['B', 'C'],
		  groups: {
		    ['a', 'x']': [
		      {A: 10, B: 'a', C: 'x', D: 4},
		      {A: 30, B: 'a', C: 'x', D: 3},
		      {A: 40, B: 'a', C: 'x', D: 0},
		    ],
		    ['a', 'y']': [
		      {A: 70, B: 'a', C: 'y', D: 3},
		    ],
		    ['b', 'x']': [
		     {A: 20, B: 'b', C: 'x', D: 7},
		     {A: 50, B: 'b', C: 'x', D: 3},
		    ],
		    ['b', 'y']': [
		      {A: 60, B: 'b', C: 'y', D: 9},
		    ],
		  }
		}
<
		Note that the result is obviously not a relation!

In({tuple}, {rel})				*librelalg.In()*
		Return |true| if {tuple} is in base or derived relation {rel},
		otherwise return |false|.

NotIn({tuple}, {rel})				*librelalg.NotIn()*
		Return |true| if {tuple} is not in base or derived relation
		{rel}, otherwise return |false|.

PartitionBy({rel}, {groupby}[, {opts}])		*librelalg.PartitionBy()*
		Partition a relation {rel} into several relations by forming
		groups of records with the same value of the {groupby}
		attribute(s). {groupby} may be a |string| or a |list| of
		attributes. The result is a |dict| mapping the values of the
		{groupby} attributes to the corresponding subrelation. If more
		than one {groupby} attribute is given, the dictionary will be
		nested by default: you may set {opts} to `{flat: true}` to get
		a flat dictionary.

		For example:
>
		var r = [
		    {class: 0, name: "A", balance: 10.0},
		    {class: 1, name: "A", balance:  3.5},
		    {class: 1, name: "B", balance: -3.0},
		    {class: 0, name: "A", balance:  1.5},
		    {class: 1, name: "B", balance:  2.5},
		  ]
		echo r->PartitionBy(['name', 'class'])
<
		Output:
>
		{
		  A: {
		    0: [
		         {class: 0, name: "A", balance: 10.0},
		         {class: 0, name: "A", balance: 1.5},
		       ],
		    1: [
		         {class: 1, name: "A", balance: 3.5},
		      ]
		  },
		  B: {
		    1: [
		      {class: 1, name: "B", balance: -3.0},
		      {class: 1, name: "B", balance: 2.5},
		      ]
		  }
		}
<
		For a flat partition:
>
		echo r->PartitionBy(['name', 'class'], {flat: true})
<
		Output:
>
		{
		  "['A', 0]": [
		    {class: 0, name: "A", balance: 10.0},
		    {class: 0, name: "A", balance: 1.5},
		  ],
		  "['A', 1]": [
		    {class: 1, name: "A", balance: 3.5},
		  ],
		  "['B', 1]": [
		    {class: 1, name: "B", balance: -3.0},
		    {class: 1, name: "B", balance: 2.5},
		  ]
		}
<
		Note that the result is obviously not a relation!

Recursive({rel}, {recfunc}[, {unionall}])	*librelalg.Recursive()*
		Perform a recursive query. This works similarly to SQL's WITH
		RECURSIVE. {rel} is a relation. {recfunc} is a function
		receiving a relation instance and returning a new relation.
		The new relation must have the same schema as {rel}.
		Continuations are accepted, too, everywhere a relation is
		expected.

		{recfunc} implements the recursive step of the query. Its
		argument is interpreted as the reference to the query's
		output.

		{unionall} is a Boolean flag telling whether duplicate removal
		should be skipped or not. The default is |false|, that is,
		duplicate tuples are removed. If you know for sure that
		duplicates cannot be generated, you may set {unionall} to
		|true|: that will improve the performance of the query.

		For example, consider the following SQL query:
>
		with recursive cnt(n) as (
		  values(1)
		  union all
		  select n + 1 from cnt where n < 100
		)
		select n from cnt;
<
		That could be translated as follows:
>
		var result = Recursive(
		  [{n: 1}],
		  (R) => Transform(
		    Select(R, (t) => t.n < 100), (t) => {
		      return {n: t.n + 1}
		    }),
		  true
		)
<
		As another example, the reflexive transitive closure of
		a graph can be computed as follows:
>
		var Edge = [
		  {From: 1, To: 2},
		  {From: 2, To: 3},
		  {From: 3, To: 2},
		  {From: 5, To: 5},
		]

		var Path = (R) => NatJoin(
		  Rename(R,    {To:   'X'}),
		  Rename(Edge, {From: 'X'})
		)->Project(['From', 'To'])

		echo Table(Recursive(Edge, Path), {columns: ['From', 'To']})
<
		Output:
>
		─────────
		 From To
		─────────
		    1  2
		    1  3
		    2  2
		    2  3
		    3  2
		    3  3
		    5  5
<
RelEq({rel1}, {rel2})				*librelalg.RelEq()*
		Compare two base or derived relations for equality. Return
		|true| if the relations are equal, that is, they are the same
		set of tuples (the order of the tuples does not matter);
		return |false| otherwise.

Split({rel}, {func})				*librelalg.Split()*
		Split a relation {rel} into two relations based on some
		predicate {func}. {rel} may also be a continuation. {func} is
		defined as in |librelalg.Select()|. The result is a list of
		two relations: the first relation contains the tuples that
		satisfy the predicate, and the second relation contains the
		remaining tuples. For example:
>
		var r = [{A: 1}, {A: 3}, {A: 5}, {A: 2}, {A: 7}]
		var [r1, r2] = r->Split((t) => t.A <= 4)
		echo Table(r1)
		echo Table(r2)
<
		Output:
>
		───
		 A
		───
		 1
		 3
		 2

		───
		 A
		───
		 5
		 7
<
						*librelalg.Table()*
Table({rel} [, {opts}])
		Return a tabular representation of a base or derived relation
		{rel} as a |string|. {opts} is a dictionary of options to
		configure the aspect of the table. The available keys are:

		- "name": the title of the table. The default is to use the
		  relation name for base relations, and no title for derived
		  relations.

		- "columns": the attributes of the relation to use for the
		  table, in the order by which you want them to appear. By
		  default, all the attributes are used and the columns are
		  printed in an arbitrary order. For a table with a single
		  attribute, this can also be a |string|.

		- "gap": a number that determines the spacing between columns.
		  The default is one space.

		- "sep": the horizontal separator symbol. This must be
		  a single character.

		Examples:
>
		var r = [
		  {X: 10, Y: 'ten'},
		  {X: 20, Y: 'twenty'},
		]

		echo Table(r) "\n"

		echo Table(r, {
		  columns: ['Y', 'X'], name: 'A table', gap: 5, sep: '~'
		}) "\n"

		echo Table(r, {columns: 'Y'})
<
		Output:
>
		───────────
		  X      Y
		───────────
		 10    ten
		 20 twenty

		 A table
		~~~~~~~~~~~~~~~~~~~
		          Y      X
		~~~~~~~~~~~~~~~~~~~
		        ten     10
		     twenty     20

		────────
		      Y
		────────
		    ten
		 twenty
<
Transform({rel}, {func})			*librelalg.Transform()*
		Transform a base or derived relation {rel} into a |list|
		object by applying {func} to each tuple of {rel}. This is
		similar to |map()|, but each tuple can be mapped into zero or
		more values.

		For example, this turns each tuple into an integer:
>
		var r = [{X: 3, Y: 6}, {X: 5, Y: 2}]
		echo Transform(r, (t) => t.X * t.Y))
<
		Output:
>
		[18, 10]
<
		In the following example, each tuple is transformed into
		a list of integers. Each list returned by the function is
		automatically flattened in the result:
>
		var r = [{X: 3, Y: 6}, {X: 5, Y: 4}]
		echo Transform(r, (t) => [t.X * 2, t.Y * 3, t.X + t.Y])
<
		Output:
>
		[6, 18, 9, 10, 12, 9]
<
		If you do want to return a nested list, do so in the function:
>
		var r = [{X: 3, Y: 6}, {X: 5, Y: 4}]
		echo Transform(r, (t) => [[t.X + t.Y]])
<
		Output:
>
		[[9], [9]]
<
		If the transformation function returns |null|, then its value
		is ignored. This allows you to skip tuples. For instance, here
		the value of attribute `X` is added to the output only when it
		is positive:
>
		var r = [{X: 2}, {X: -1}, {X: 3}, {X: 0}]
		echo Transform(r, (t) => t.X <= 0 ? null : t.X)
<
		Output:
>
		[2, 3]
<
		Note that the result is NOT a relation, in general!

Zip({list1}, {list2})				*librelalg.Zip()*
		Build a tuple by "zipping" the attributes in {list1} with the
		values in {list2}. For example:
>
		var t = Zip(['A', 'B'], [7, 'v'])
		echo t
<
		outputs:
>
		{A: 7, B: 'v'}
<
 vim:tw=78:ts=8:noet:ft=help:norl:
